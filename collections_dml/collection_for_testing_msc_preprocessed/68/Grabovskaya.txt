an upper bound of unreliability of non branching programs in an arbitrary complete finite basis for one type constant faults at the outputs of computational operators s m grabovskaya 1 and m a alekhina 2 submitted by f m ablayev 1 penza state university krasnaya st 40 penza 440026 russia 2 penza state technological university baidukova passway gagarin st 1 a 11 penza 440039 russia received july 15 2017 abstract the implementation of boolean functions by non branching programs with a condi tional stop operator is considered in an arbitrary complete finite basis we assume that conditional stop operators of the program are absolutely reliable while all computational operators are prone to the output one type constant faults of either type 0 or type 1 an upper bound for unreliability of the programs was found in different bases it was proved that in some cases any boolean function can be implemented by the non branching program of arbitrarily high preassigned reliability 2010 mathematical subject classification 68 r 99 68 m 15 94 c 12 keywords and phrases a circuit a non branching program with conditional stop operators output one type constant faults unreliability a boolean function 1 introduction we consider the implementation of boolean functions by non branching programs with a conditional stop operator 1 2 in an arbitrary complete finite basis the computational operators of the program are assumed to be prone to output constant faults of either only type 0 or only type 1 and conditional stop operators are absolutely reliable the program with a conditional stop operator is characterized by the presence of the conditional stop command giving the possibility of early stoppage of the program work under certain conditions namely under receipt unit at the stop operator input the notion of a non branching program is closely related to the concept of a circuit of functional elements fe diagrams of fe are models of electronic circuits and non branching programs both with a conditional stop and without it model the operation of computing devices despite these differences the results on reliability and complexity obtained for circuits of fe are transferred to non branching programs without stop operators and vice versa generally speaking circuits of fe can be considered a special case of non branching programs when there are no stop operators in them for the first time the problem of synthesis of reliable circuits of unreliable elements was considered j von neumann 3 he supposed that circuit elements are prone to inverse faults at the outputs to raise reliability he used multiple duplication of original circuits which of course led to increase in complexity therefore complexity was attended in further researches among which we notice results of s i ortyukov 4 d uhlig 5 s v yablonsky 6 the circuits proposed by s i ortyukov and d ulig were asymptotically optimal on complexity and functioned with a certain level of reliability methods of constructing asymptotically optimal reliable circuits of unreliable elements were first considered by m a alekhina 7 then researches were continued by v v chugunova 8 a v vasin 9 and o y barsukova 10 e mail swetazin mail ru e mail alekhina marina 19 yandex ru 2 s m grabovskaya m a alekhina a v chashkin 2 researched non branching programs with a conditional stop operator he found asymptotic estimates for the average calculation time of non branching programs on the assumption that all program operators are absolutely reliable prior to the author s work the problem of constructing reliable and asymptotically optimal on reliability non branching programs with a conditional stop operator was not considered the problem of constructing reliable non branching programs was solved in 11 for the first time this problem was researched for inverse faults at the outputs of computational operators let us formulate necessary def initions denotations and known results about reliability of circuits of fe and non branching programs 12 2 definitions and denotations let x x 1 xn be a set of independent boolean variables and let x x 1 xn be a set of independent variables n n introduce a set of variables y y 1 yl we call it the set of inner variables l n denote the output variable by z furthermore let a y z and b 1 bd x y z d 1 n denote h a boolean function from the basis b depending on at most d variables we understand a computing command as the expression p a h b 1 bd we treat the variable a as the output of the computing command and we do variables b 1 bd as inputs of this command let now a x y z we understand a stop command as the expression p stop a we treat the variable a as the input of the stop command p definition 1 a sequence pr p 1 pj pl consisting of computing commands and stop ones is called a non branching program with a conditional stop operator if with any j 1 l each input of the command pj is either an independent variable or the output of some computing command the non branching program works at discrete time moments t 0 1 2 it does not change values of independent variables but changes values of inner variables yi i 1 l and that of the output one z the result of the program pr operating on the set x is denoted by pr x the value pr x is equal the value of the output variable z at the time of program stop the program pr calculates a boolean function f x x x 1 xn if with no faults in the program for any x 0 1 n there is the equality pr x f x we assume that all computational operators of the basis b independently of each other with probability 0 1 2 are prone to one type constant faults at the outputs constant faults of type 0 1 at the outputs are characterized by the fact that in good condition a computational operator implements a function ascribed to him and in failure a function 0 1 conditional stop operators are supposed to be absolutely reliable we consider that the program with unreliable operators implements a boolean function f x if with no faults in it for each input vector a the value of the output variable z is equal f a remark 1 a circuit of fe can be considered a special case of a non branching program namely a non branching program without stop operators definition 2 unreliability n pr of the program pr is the maximum fault at the output of the program pr for all possible input vectors for circuits of fe the following result is known theorem 1 13 in an arbitrary complete finite basis for faults of type 0 1 at the fe outputs any boolean function f can be implemented by the circuit s such that n s 3 11 for all 0 1 960 to raise reliability of the original circuits programs we use the function g x 1 x 2 x 3 x 4 of the form x 11 x 2 2 x 3 3 x 4 4 5 i 0 1 i 1 2 3 4 5 theorem 2 holds lobachevskii journal of mathematics an upper bound of the program unreliability 3 theorem 2 14 let b be a complete finite basis and let there exists n such that any boolean function f can be implemented by the non branching program rf with unreliability n rf n let g x 1 x 2 x 3 x 4 be a function of the form x 1 1 x 2 2 x 3 3 x 4 4 5 i 0 1 i 1 2 3 4 5 prg a program implementing g x 1 x 2 x 3 x 4 and n prg unreliability of the program prg then in this basis any boolean function f can be implemented by such program prf that there is the inequality n prf max 1 0 4 n n prg 4 n 2 1 where 1 and 0 are fault probabilities of the program prg on the vectors 1 2 3 4 and 1 2 3 4 respectively the sets 1 2 3 4 and 1 2 3 4 are called the characteristic sets of the function g x 1 x 2 x 3 x 4 lemma 1 15 the variables identification in any non linear and non especial function of three or more variables can result in either a non linear function of two variables or an especial function in other words by means of substitution identification and or renaming of variables 16 it s possible to obtain either some non linear function of two variables x 1 x 2 x 1 x 2 1 x 1 2 x 2 0 or some especial function x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 1 x 1 2 x 2 3 x 3 0 where 0 1 2 0 1 2 3 0 1 since in any complete finite basis there is a non linear function we further assume without loss of generality that the considered complete basis b contains either a non linear function of two variables or an especial function for a non linear function of two variables up to variable renaming there are 2 cases 1 x 1 x 2 x 1 1 x 2 2 generalized disjunction 2 x 1 x 2 x 1 1 x 2 2 1 2 0 1 generalized conjunction for an especial function up to variable renaming there are 8 cases 1 1 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 1 2 2 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 1 3 3 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 4 4 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 5 5 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 1 6 6 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 7 7 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 1 8 8 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 lobachevskii journal of mathematics 4 s m grabovskaya m a alekhina 3 main results if the computational operators of a non branching program are prone to constant faults of type 0 at the outputs then theorem 3 is valid theorem 3 1 if the complete finite basis b contains one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 7 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function f for t n can be implemented by the non branching program prf such that n prf t for all 0 1 960 2 if the complete finite basis b contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 8 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function f can be implemented by the non branching program prf with unreliability no more 9 2 for all 0 1 960 if the computational operators of a non branching program are prone to constant faults of type 1 at the outputs then theorem 4 is valid theorem 4 1 if a complete finite basis b contains one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 7 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function f can be implemented by the non branching program prf with unreliability no greater 9 2 for all 0 1 960 2 if a complete finite basis b contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 8 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function f for t n can be implemented by the non branching program prf such that n prf t for all 0 1 960 we preface lemmas 2 9 to the proves of theorems 3 and 4 lemma 2 in a complete finite basis containing the function 1 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 1 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 for constant faults of type 0 and max 1 0 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 1 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 1 x 1 x 2 x 3 x 1 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 1 x 1 x 2 x 3 stop x 3 z x 4 stop x 4 z x 2 stop x 1 z x 1 obviously unreliability of the program prg is at most because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators lobachevskii journal of mathematics an upper bound of the program unreliability 5 1 1 p 1 0 0 1 0 0 0 p 0 1 1 0 1 0 thus max 1 0 0 2 1 p 1 0 0 1 0 0 p 0 1 1 0 1 0 thus max 1 0 lemma 3 in a complete finite basis containing the function 2 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 1 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 for constant faults of type 0 and max 1 0 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 2 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 1 x 1 x 2 x 3 x 1 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 2 x 1 x 2 x 3 stop x 3 z x 3 stop x 4 z x 1 stop x 1 z x 2 obviously unreliability of the program prg is at most because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 0 0 0 1 0 0 p 0 1 1 1 0 thus max 1 0 2 1 p 1 0 0 0 1 0 0 p 0 1 1 1 0 0 thus max 1 0 0 lemma 4 in a complete finite basis containing the function 3 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 for constant faults of type 0 and max 1 0 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 3 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 3 x 1 x 2 x 3 x 1 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 3 x 1 x 2 x 3 stop x 3 z 3 x 1 x 2 x 4 stop x 4 z x 4 lobachevskii journal of mathematics 6 s m grabovskaya m a alekhina it is easy to verify that unreliability of the program prg is no greater despite prg contains two unreliable computational operators indeed with this method of constructing a non branching program when independent variables enter the inputs of the stop operators the fault in the output of the program on an arbitrary input set of variables can occur due to only the fault of one of the computational operators while the work of the other computational operator does not affect the result of the program for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 1 1 0 0 0 0 p 0 0 0 1 1 thus max 1 0 2 1 p 1 1 1 0 0 0 0 p 0 0 0 1 1 0 thus max 1 0 0 lemma 5 in a complete finite basis containing the function 4 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 0 for constant faults of type 0 and max 1 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 4 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 1 x 2 x 3 x 1 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 4 x 1 x 2 x 3 stop x 3 z x 4 stop x 4 stop x 1 z x 2 obviously unreliability of the program prg is at most because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 1 0 1 0 0 0 p 0 0 1 0 1 0 thus max 1 0 0 2 1 p 1 1 0 1 0 0 p 0 0 1 0 1 0 thus max 1 0 lemma 6 in a complete finite basis containing the function 5 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 1 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 0 for constant faults of type 0 and max 1 0 for constant faults of type 1 at the outputs of computational operators lobachevskii journal of mathematics an upper bound of the program unreliability 7 proof let the complete finite basis b contains the function 5 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 1 x 1 x 2 x 1 x 3 x 2 x 3 in this basis we construct the non branching program prg imple menting the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 5 x 1 x 2 x 3 stop x 3 z x 4 stop x 4 stop x 1 z x 2 obviously unreliability of the program prg is no greater because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 1 0 1 0 0 0 p 0 0 1 0 1 0 thus max 1 0 0 2 1 p 1 1 0 1 0 0 p 0 0 1 0 1 0 thus max 1 0 lemma 7 in a complete finite basis containing the function 6 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 0 for constant faults of type 0 and max 1 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 6 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 1 x 2 x 1 x 3 x 2 x 3 in this basis we construct the non branching program prg implement ing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 6 x 1 x 2 x 3 stop x 3 z x 4 stop x 4 z x 2 stop x 1 z x 1 obviously unreliability of the program prg is no greater because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 0 0 1 0 0 0 p 0 1 1 0 1 0 thus max 1 0 0 2 1 p 1 0 0 1 0 0 p 0 1 1 0 1 0 thus max 1 0 lobachevskii journal of mathematics 8 s m grabovskaya m a alekhina lemma 8 in a complete finite basis containing the function 7 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 1 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching program prg such that n prg and besides max 1 0 0 for constant faults of type 0 and max 1 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 7 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 1 x 1 x 2 x 1 x 3 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 7 x 1 x 2 x 3 stop x 3 z x 4 stop x 4 stop x 1 stop x 2 z 7 x 1 x 2 x 3 unreliability of the program prg is at most since independent variables enter the inputs of the stop operators so on an arbitrary input set of variables the fault in the output of the program can occur due to only the fault of one of the computational operators while the work of the other computational operator does not affect the result of the program for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 1 1 1 0 0 0 p 0 0 0 0 1 0 thus max 1 0 0 2 1 p 1 1 1 1 0 0 p 0 0 0 0 1 0 thus max 1 0 lemma 9 in a complete finite basis containing the function 8 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 can be implemented by the non branching pro gram prg such that n prg and besides max 1 0 for constant faults of type 0 and max 1 0 0 for constant faults of type 1 at the outputs of computational operators proof let the complete finite basis b contains the function 8 x 1 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 x 1 x 2 x 1 x 3 x 2 x 3 in this basis we construct the non branching program prg implementing the function g x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 z 8 x 1 x 2 x 3 stop x 3 z x 3 stop x 4 z x 1 stop x 1 z x 2 lobachevskii journal of mathematics an upper bound of the program unreliability 9 obviously unreliability of the program prg is no greater because the program prg contains just one unreliable computational operator for the program prg we estimate probabilities of faults on the characteristic sets in two cases 1 for constant faults of type 0 and 2 for constant faults of type 1 at the outputs of computational operators 1 1 p 1 0 0 0 1 0 0 p 0 1 1 1 0 thus max 1 0 2 1 p 1 0 0 0 1 0 0 p 0 1 1 1 0 0 thus max 1 0 0 let us prove theorem 3 proof letb be an arbitrary complete finite basis the conditional stop operators of some non branching program are absolutely reliable and the computational operators independently of each other with probability 0 1 960 go to the failure conditions of type 0 at the outputs let f be any boolean function for the basis b by lemma 1 at least one of the following conditions holds the basis b contains a non linear function of two variables i e either 1 generalized disjunction x 11 x 2 2 1 2 0 1 or 2 generalized conjunction x 11 x 2 2 the basis b contains a special function i e either 3 one of the functions i x 1 x 2 x 3 i 1 4 5 6 7 or 4 one of the functions i x 1 x 2 x 3 i 2 3 8 let s consider each of these four cases 1 let the basis b contains some function of the form x 11 x 2 2 it is shown in 17 that in the basis b any boolean function f can be implemented by the non branching program prf with unreliability n prf 9 2 for all 0 1 960 theorem 3 is true in this part in cases 2 and 3 first of all we implement the function f by the non branching program prf such that n prf 2 for all 0 1 960 and then the function f for t n is implemented by the program with unreliability at most t for all 0 1 960 note that for t 1 and t 2 this theorem is true since 2 therefore it remains to consider the case t 3 2 let the basis b contains some function of the form x 11 x 2 2 previously 18 it was proved that in the basis b any boolean function f can be implemented by the non branching program prf such that n prf 2 for all 0 1 960 3 let the basis b contains at least one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 or 7 x 1 x 2 x 3 then the function g x 1 x 2 x 3 x 4 equal to either the function x 1 x 2 x 3 x 4 lemmas 2 and 7 either x 1 x 2 x 3 x 4 lemmas 5 and 6 or x 1 x 2 x 3 x 4 lemma 8 can be implemented by the program prg with unreliability n prg and max 1 0 0 by theorem 1 the function f can be implemented by the circuit s such that n s 3 11 for all 0 1 960 we apply theorem 2 using the program prg and taking the circuit s as the program rf see remark 1 we construct the program prf assuming n 3 11 and taking into account the conditions max 1 0 0 and n prg by theorem 2 the non branching program prf implements the function f with unreliability n prf 52 2 for all 0 1 960 lobachevskii journal of mathematics 10 s m grabovskaya m a alekhina let s perform one more iteration step we now take for rf already constructed program prf unreliability of which for all 0 1 960 satisfies the inequality n rf 52 2 0 0542 let n 0 0542 we again use theorem 2 considering max 1 0 0 and n prg then the function f can be implemented by the non branching program pr 2 f such that n pr 2 f 0 23 2 2 for all 0 1 960 thus in cases 2 and 3 an arbitrary function f can be implemented by such non branching program denote it by pr f that n pr f 2 for all 0 1 960 in each of cases 2 and 3 we again use theorem 2 taking now for rf the non branching program pr f and assuming n 2 then the function f can be implemented by such program pr 1 f that the inequality n pr 1 f 4 n n prg n 4 2 2 4 3 1 4 3 1 1 5 3 as 0 1 960 is valid now we take as n the quantity 5 3 and again use theorem 2 we ll make one more step of the iteration then the function f can be implemented by such program pr 2 f that the inequality n pr 2 f 5 5 3 5 2 2 holds it is easy to see that after m iterations the function f can be implemented by the program pr m f such that n pr m f 5 m 2 let t be any natural number t 3 we remind that for t 1 and t 2 this theorem is true we choose a natural number m for which the inequality m t 2 log 5 is valid then 5 m t 2 i e 5 m 2 t hence n pr m f t note that since m is the number of iterations it is reasonable to choose the smallest natural number m for which the inequality m t 2 log 5 holds 4 let the basis b contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 or 8 x 1 x 2 x 3 then the function g x 1 x 2 x 3 x 4 equal to either the function x 1 x 2 x 2 x 4 lemmas 3 and 9 or x 1 x 2 x 2 x 4 lemma 4 can be implemented by the program prg with unreliability n prg and max 1 0 by theorem 1 the function f can be implemented by such circuit s that n s 3 11 for all 0 1 960 we apply theorem 2 using the program prg and taking the program s as the program rf see re mark we construct the program prf assuming n 3 11 and taking into account the conditions max 1 0 and n prg by theorem 2 the non branching program prf implements the function f with unreliability n prf 52 2 for all 0 1 960 let s perform one more iteration step now we take for rf already constructed program prf unreliability of which for all 0 1 960 satisfies the inequality n rf 52 2 1 0542 let n 1 0542 use theorem 2 taking max 1 0 and n prg then the func tion f can be implemented by a non branching program prf such that n prf 9 2 for all 0 1 960 corollary 1 for faults of type 0 at the outputs of computational operators the following holds 1 if the complete finite basis contains one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 7 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function can be implemented by the non branching program of arbitrarily high preassigned reliability for all 0 1 960 as lim t t 0 2 if the complete finite basis contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 8 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function can be implemented by the non branching program with unreliability asymptotically no greater than for 0 lobachevskii journal of mathematics an upper bound of the program unreliability 11 theorem 4 is proved similarly to theorem 3 using the same lemmas 2 9 but in the case of type 1 faults at the outputs of computational operators corollary 2 for faults of type 1 at the outputs of computational operators the following holds 1 if the complete finite basis contains one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 7 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function can be implemented by the non branching program with unreliability asymptotically no greater than for 0 2 if the complete finite basis contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 8 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then any boolean function can be implemented by the non branching program of arbitrarily high preassigned reliability for all 0 1 960 as lim t t 0 4 conclusions 1 if the complete finite basis contains one of the functions 1 x 1 x 2 x 3 4 x 1 x 2 x 3 5 x 1 x 2 x 3 6 x 1 x 2 x 3 7 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then for faults of type 0 at the outputs of computational operators any boolean function can be implemented by the non branching program with a conditional stop operator of arbitrarily high preassigned reliability for all 0 1 960 for faults of type 1 at the outputs of computational operators any boolean function can be implemented by the non branching program with unreliability at most 9 2 for all 0 1 960 2 if the complete finite basis contains one of the functions 2 x 1 x 2 x 3 3 x 1 x 2 x 3 8 x 1 x 2 x 3 or the function of the form x 1 1 x 2 2 1 2 0 1 then for faults of type 0 at the outputs of computational operators any boolean function can be implemented by the non branching program with unreliability at most 9 2 for all 0 1 960 for faults of type 1 at the outputs of computational operators any boolean function can be implemented by the non branching program of arbitrarily high preassigned reliability for all 0 1 960 acknowledgments partially supported by russian foundation for basic research grant 17 01 00451 a references 1 a v chashkin on the average time for the computation of the values of boolean functions discrete anal issled oper ser 1 4 1 60 78 1997 in russian 2 a v chashkin on the mean time for computing boolean operators discrete anal issled oper ser 1 5 1 88 103 1998 in russian 3 j von neuman probabilistic logics and the synthesis of reliable organisms from unreliable compo nents automata studies am 34 ed by c shannon and mc carthy j 34 98 princeton university press 1956 4 s i ortyukov on redundancy of boolean function realization with circuits of unreliable elements in proc of discrete mathematics and its applications seminar 1987 moscow ussr 166 168 in russian 5 d uhlig reliable networks from unreliable gates with almost minimal complexity fundamentals of computation theory fct 1987 lecture notes in computer science 278 462 469 springer berlin heidelberg 1987 6 s v yablonskiy asymptotically the best method of synthesis of reliable circuits from unreliable elements banach center 7 11 19 1982 lobachevskii journal of mathematics 12 s m grabovskaya m a alekhina 7 m a alekhina synthesis reliability and complexity of circuits from unreliable functional elements d sci phys math diss penz state univ penza 2004 in russian 8 v v chugunova synthesis of asymptotically optimal reliable circuits under inverse failures at the element outputs ph d phys math diss penz state univ penza 2007 in russian 9 a v vasin asymptotically optimal circuits on reliability in complete final basis of three input gates ph d phys math diss penz state univ penza 2010 in russian 10 o y barsukova the synthesis of reliable circuits which realizes binary and ternary logics functions ph d phys math diss penz state univ penza 2014 in russian 11 s m grabovskaya asymptotically optimal reliable non branching programs ph d phys math diss penz state univ penza 2012 in russian 12 m a alekhina and s m grabovskaya reliability of nonbranching programs in an arbitrary complete finite basis russ math 56 2 10 18 2012 13 m a alekhina on reliability of circuits over an arbitrary complete finite basis under single type constant faults at outputs of elements discrete math appl 22 4 383 391 2012 14 s m grabovskaya on methods of raise the reliability of non branching programs with a conditional stop operator in proceeding int conf problems of automation and control in technical systems dedicated to the 70 th anniversary of the victory in the great patriotic war 2015 penza russia 339 342 in russian 15 n p red kin on complete checking tests for circuits of functional elements in mathematical problems of cybernetics 2 nauka moscow 1989 198 222 in russian 16 s v yablonskii introduction into discrete mathematics nauka moscow 2001 in russian 17 s m grabovskaya on reliability of non branching programs in bases containing generalized disjunction in proceeding xix int sci and meth conf university education mkuo 2015 dedicated to the 70 th anniversary of the victory in the great patriotic war 2015 penza russia 218 219 in russian 18 s m grabovskaya on reliability of non branching programs in bases containing generalized konjunction in proceeding int conf problems of automation and control in technical systems dedicated to the 70 th anniversary of the victory in the great patriotic war 2015 penza russia 342 345 in russian lobachevskii journal of mathematics