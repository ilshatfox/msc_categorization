
%%
%% ****** ljmsamp.tex 13.06.2018 ******
%%
\documentclass[
11pt,%
tightenlines,%
twoside,%
onecolumn,%
nofloats,%
nobibnotes,%
nofootinbib,%
superscriptaddress,%
noshowpacs,%
centertags]%
{revtex4}
\usepackage{ljm}
\begin{document}

\titlerunning{An upper bound of the program unreliability} % for running heads
%\authorrunning{ at al.} % for running heads
\authorrunning{S.\,M.\,Grabovskaya, M.\,A.\,Alekhina} % for running heads

\title{An upper bound of unreliability of non-branching programs \\
in an arbitrary complete finite basis
for one-type constant faults \\ at the outputs of computational operators}
% Splitting into lines is performed by the command \\
% The title is written in accordance with the rules of capitalization.

\author{\firstname{S.~M.}~\surname{Grabovskaya}}
\email[E-mail: ]{swetazin@mail.ru}
%\affiliation{Place of work and/or the address of the first and second authors}
\affiliation{Penza State University,  Krasnaya st. 40, Penza, 440026 Russia}

\author{\firstname{M.~A.}~\surname{Alekhina}}
\email[E-mail: ]{alekhina.marina19@yandex.ru}
%\affiliation{Place of work and/or the address of the first and second authors}
\affiliation{Penza State Technological  University,  Baidukova passway/ Gagarin st. 1a/11, Penza, 440039 Russia}
%\noaffiliation % If the author does not specify a place of work.

\firstcollaboration{(Submitted by F.~M.~Ablayev)} % Add if you know submitter.
%\lastcollaboration{ }

\received{July 15, 2017} % The date of receipt to the editor, i.e. December 06, 2017


\begin{abstract} % You shouldn't use formulas and citations in the abstract.
The implementation of Boolean functions by non-branching programs with a conditional stop operator is considered in an arbitrary complete finite basis. We assume that conditional stop operators of the program are absolutely reliable while  all computational operators are prone to the output one-type constant faults of either type 0 or type 1. An upper bound for unreliability of the programs was found  in different bases. It was proved that in some cases  any Boolean function can be implemented by the non-branching program of arbitrarily high preassigned reliability.
\end{abstract}

\subclass{68R99, 68M15, 94C12} % Enter 2010 Mathematics Subject Classification.

\keywords{a circuit, a non-branching program with conditional stop operators, output one-type constant faults, unreliability, a Boolean function} % Include keywords separeted by comma.

\maketitle

% Text of article starts here.

\section{Introduction}

We consider the implementation of Boolean functions by non-branching programs with a conditional stop operator \cite{1,2} in an arbitrary complete finite basis. The computational operators of the program are assumed to be prone to output constant faults of either only type 0 or only type 1, and conditional stop operators are absolutely reliable. The program with a conditional stop operator is characterized by the presence of the conditional stop command giving the possibility of early stoppage of the program work under certain conditions (namely, under receipt unit at the stop operator input).

The notion of a non-branching program is closely related to the concept of a circuit of functional elements (FE). Diagrams of FE are models of electronic circuits, and non-branching programs (both with a conditional stop and without it) model the operation of computing devices. Despite these differences the results on reliability and complexity obtained for circuits of FE are transferred to non-branching programs without stop operators and vice versa. Generally speaking, circuits of FE can be considered a special case of non-branching programs when there are no stop operators in them.


For the first time the problem of synthesis of reliable circuits of unreliable elements was considered J. von Neumann \cite{3}. He supposed that circuit elements are prone to inverse faults at the outputs. To raise reliability he used multiple duplication of original circuits which of course led to increase in complexity.

Therefore complexity was attended in further researches, among which we notice results of \linebreak S. I. Ortyukov \cite{4}, D. Uhlig \cite{5}, S. V. Yablonsky \cite{6}. The circuits proposed by S. I. Ortyukov and D. Ulig were asymptotically optimal on complexity and functioned with a certain level of reliability.

Methods of constructing asymptotically optimal reliable circuits of unreliable elements were first considered by M. A. Alekhina \cite{7}. Then researches were continued by V. V. Chugunova \cite{8}, \linebreak A. V. Vasin \cite{9} and O. Y. Barsukova \cite{10}.

A. V. Chashkin \cite{2} researched non-branching programs with a conditional stop operator.  He found asymptotic estimates for the average calculation time of non-branching programs on the assumption that all program operators are absolutely reliable.

Prior to the author's work the problem of constructing reliable (and asymptotically optimal on reliability) non-branching programs with a conditional stop operator was not considered. The problem of constructing reliable non-branching programs was solved in \cite{11}. For the first time this problem was researched for inverse faults at the outputs of computational operators. Let us formulate necessary definitions, denotations and known results about reliability of circuits of FE and non-branching programs \cite{12}.

\section{Definitions and denotations}

Let $X = \{x_1,\ldots,x_n\}$ be a set of independent Boolean variables, and let $\mathbf{x} = (x_1,\ldots,x_n)$ be \linebreak a set of
independent variables, $n \in \bf N$. Introduce a set of variables $Y = \{y_1,\ldots,y_l\}$; we call it the set of inner
variables, $l \in \bf N$. Denote the output variable by $z$.

Furthermore, let $a \in Y \cup \{z\}$ and $b_1,\ldots,b_d \in X \cup Y \cup \{z\}$ ($d \in \{1,\ldots,n\}$). Denote $h$ a Boolean
function from the basis $B$ depending on at most $d$ variables. We understand a computing command as
the expression $p: \ a = h(b_1,\ldots,b_d)$. We treat the variable $a$ as the output of the computing command
and we do variables $b_1,\ldots,b_d$ as inputs of this command.

Let now $a \in X \cup Y \cup \{z\}$. We understand a stop command as the expression $p: \ Stop(a)$. \linebreak We treat
the variable $a$ as the input of the stop command $p$.

\begin{definition}A sequence $Pr = p_1 \ldots p_j \ldots p_L$ consisting of computing commands and stop ones is called a
non-branching program with a conditional stop operator if with any $j \in \{1, \ldots ,L\}$ each input of the
command $p_j$ is either an independent variable or the output of some computing command.\end{definition}

The non-branching program works at discrete time moments $t = 0, 1, 2, \ldots $, it does not change values
of independent variables, but changes values of inner variables $y_i$ ($i \in \{1,\ldots,l\}$) and that of the output
one $z$.

The result of the program $Pr$ operating on the set $\mathbf{x}$ is denoted
by $Pr(\mathbf{x})$. The value $Pr(\mathbf{x})$ is equal the value of the output variable
$z$ at the time of program stop. The program $Pr$  calculates a Boolean function $f(\mathbf{x})$
($\mathbf{x}=(x_1,\ ...,\ x_n)$) if with no faults in the program for any $\mathbf{x} \in\{0,\ 1\}^n$ there is the equality $Pr(\mathbf{x})=f(\mathbf{x})$.

We assume that all computational operators of the basis $B$ independently of each other with probability $\varepsilon(\varepsilon\in(0,\;1/2))$ are prone to
one-type constant faults at the outputs. Constant faults of type 0 (1) at the outputs are characterized by the fact that in good condition a computational operator implements a function $\varphi$, ascribed to him, and in failure -- a function 0 (1). Conditional stop operators are supposed to be absolutely reliable.

We consider that the program with unreliable operators implements a Boolean function $f(\mathbf{x})$ \linebreak if with no faults in it for each input vector $\mathbf{a}$ the value of the output variable $z$ is equal $f(\mathbf{a})$.
%\vspace{3mm}

%\noindent
{\bf Remark 1.} A circuit of FE can be considered a special case of
a non-branching program, namely, \linebreak a non-branching program
without stop operators.

\begin{definition}Unreliability $N_\varepsilon(Pr)$ of the program $Pr$ is the maximum fault at the output of the program $Pr$ for all possible input vectors.\end{definition}

For circuits of FE the following result is known.

\begin{theorem}\label{th1}\cite{13} In an arbitrary complete
 finite basis for faults of type $0 \ (1)$ at the FE outputs any Boolean
 function $f$ can be implemented by the circuit $S$ such that
 $N_\varepsilon(S)\leq 3,11\varepsilon$ \linebreak for all $\varepsilon \in (0, 1/960]$. \end{theorem}

To raise reliability of the original circuits (programs) we use the
function $g(x_1, x_2, x_3, x_4)$ of the form
$(x_1^{\sigma_1}x_2^{\sigma_2}\vee
x_3^{\sigma_3}x_4^{\sigma_4})^{\sigma_5}$ ($\sigma_i\in \{0, 1\}$,
$i\in \{1, 2, 3, 4, 5\}$). Theorem \ref{th2} holds.

\begin{theorem}\label{th2}\cite{14} Let $B$ be a complete finite basis,
 and let there exists $N$ such that any Boolean function $f$ can be implemented
 by the non-branching program $R_f$  with unreliability $N_\varepsilon(R_f)\leq N$.
 Let $g(x_1, x_2, x_3, x_4)$ be a function of the form $(x_1^{\sigma_1}x_2^{\sigma_2}\vee x_3^{\sigma_3}x_4^{\sigma_4})^{\sigma_5}$ ($\sigma_i\in \{0, 1\}$, $i\in \{1, 2, 3, 4, 5\}$), $Pr_g$ -- a program implementing $g(x_1, x_2, x_3, x_4)$, and $N_\varepsilon(Pr_g)$ -- unreliability of the program $Pr_g$. Then in this basis any Boolean function $f$ can be implemented by such program $Pr_f$
that there is the inequality
\begin{eqnarray}
N_\varepsilon(Pr_f)\leq\max \{\nu^1,\;\nu^0\}+4N\cdot N_\varepsilon(Pr_g)+
4N^2
\label{f1},
\end{eqnarray}
where $\nu^1 $ and $\nu^0 $ are fault probabilities of the program $Pr_g$ on the
vectors $(\bar \sigma_1 ,\bar \sigma_2 ,\bar \sigma_3, \bar \sigma_4)$ and
$(\sigma_1, \sigma_2, \sigma_3, \sigma_4)$ respectively. \end{theorem}

The sets $(\bar \sigma_1 ,\bar \sigma_2 ,\bar \sigma_3, \bar \sigma_4)$ and $(\sigma_1, \sigma_2, \sigma_3, \sigma_4)$  are called the characteristic sets of the function $g(x_1, x_2, x_3, x_4)$.

\begin{lemma}\label{l1}\cite{15} The variables identification in any non-linear
and non-especial function of three or more variables can result in either a non-linear
 function of two variables or an especial function.\end{lemma}

In other words, by means of substitution (identification and/or
renaming of variables \cite{16})\linebreak   it's possible to obtain
either some non-linear function of two variables $\phi (x_1,x_2)=x_1
x_2 \oplus \alpha_1 x_1 \oplus\alpha_2 x_2 \oplus \alpha_0$ or some
especial function $\varphi(x_1,x_2,x_3)=x_1 x_2\oplus x_1 x_3 \oplus
x_2 x_3 \oplus \beta_1 x_1 \oplus \beta_2 x_2 \oplus \beta_3 x_3
\oplus \beta_0$ where
$\alpha_0,\;\alpha_1,\;\alpha_2,\;\beta_0,\;\beta_1,\;\beta_2,\;\beta_3
\in \{0, \ 1\}$.

Since in any complete finite basis there is a non-linear function,
we further assume  without loss of generality that the considered
complete basis $B$ contains either a non-linear function of two
variables or an especial function.

For a non-linear function of two variables up to variable renaming there are 2 cases:
\begin{enumerate}
\item $\phi(x_1, x_2)=x_1^{\alpha_1}\vee x_2^{\alpha_2}$ (generalized disjunction);
\item $\phi(x_1, x_2)=x_1^{\alpha_1}\& x_2^{\alpha_2}$ ($\alpha_1, \alpha_2 \in \{0, 1\}$) (generalized conjunction).
\end{enumerate}

For an especial function up to variable renaming there are 8 cases:
\begin{enumerate}
\item  $\varphi_1(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 \oplus x_3 \oplus 1$;
\item $\varphi_2(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus 1$;
\item $\varphi_3(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 \oplus x_3 $;
\item $\varphi_4(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 $;
\item $\varphi_5(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 \oplus 1$;
\item $\varphi_6(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 $;
\item $\varphi_7(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3
\oplus 1$;
\item $\varphi_8(x_1, x_2 x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 $.
\end{enumerate}

\section{Main results}

If the computational operators of a non-branching program are prone to constant faults of type 0 at the outputs, then Theorem \ref{th3} is valid.

\begin{theorem}\label{th3}
         1) If the complete finite basis $B$ contains one of the functions $\varphi_1(x_1, x_2 x_3)$, $\varphi_4(x_1, x_2 x_3)$, $\varphi_5(x_1, x_2 x_3)$, $\varphi_6(x_1, x_2 x_3)$, $\varphi_7(x_1, x_2 x_3)$, or the function of the form $x_1^{\alpha_1}\& x_2^{\alpha_2}$$(\alpha_1, \alpha_2 \in \{0, 1\})$, then any Boolean function $f$ for $\forall t \in \mathbf{N}$ can be implemented by the non-branching program $Pr_f$ such that $N_\varepsilon(Pr_f)\leq \varepsilon^t$ for all $\varepsilon\in (0, 1/960]$.

         2) If the complete finite basis $B$ contains one of the functions $\varphi_2(x_1, x_2 x_3)$, $\varphi_3(x_1, x_2 x_3)$, $\varphi_8(x_1, x_2 x_3)$, or the function of the form $x_1^{\alpha_1}\vee x_2^{\alpha_2}$$(\alpha_1, \alpha_2 \in \{0, 1\})$, then any Boolean function $f$ can be implemented by the non-branching program $Pr_f$ with unreliability no more $\varepsilon+9\varepsilon^2$ \linebreak for all $\varepsilon\in (0, 1/960]$.
\end{theorem}

If the computational operators of a non-branching program are prone to constant faults of type 1 at the outputs, then Theorem \ref{th4} is valid.

\begin{theorem}\label{th4}
                 1) If a complete finite basis $B$ contains one of the functions $\varphi_1(x_1, x_2 x_3)$, $\varphi_4(x_1, x_2 x_3)$, $\varphi_5(x_1, x_2 x_3)$, $\varphi_6(x_1, x_2 x_3)$, $\varphi_7(x_1, x_2 x_3)$, or the function of the form $x_1^{\alpha_1}\& x_2^{\alpha_2}$ $(\alpha_1, \alpha_2 \in \{0, 1\})$, then any Boolean function $f$ can be implemented by the non-branching program $Pr_f$ with unreliability no greater $\varepsilon+9\varepsilon^2$   for all $\varepsilon\in (0, 1/960]$.

                 2) If a complete finite basis $B$ contains one of the functions $\varphi_2(x_1, x_2 x_3)$, $\varphi_3(x_1, x_2 x_3)$, $\varphi_8(x_1, x_2 x_3)$, or the function of the form $x_1^{\alpha_1}\vee x_2^{\alpha_2}$ $(\alpha_1, \alpha_2 \in \{0, 1\})$, then any Boolean function $f$ for $\forall t \in \mathbf{N}$ can be implemented by the non-branching program $Pr_f$ such that $N_\varepsilon(Pr_f)\leq \varepsilon^t$  \linebreak for all $\varepsilon\in (0, 1/960]$.
\end{theorem}

We preface Lemmas \ref{l2} -- 9 to the proves of Theorems \ref{th3} and \ref{th4}.

\begin{lemma}\label{l2}
In a complete finite basis, containing the function
$\varphi_1(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 \oplus x_3 \oplus 1$, the function $g(x_1, x_2, x_3, x_4)= x_1
x_2 \vee \bar{x}_3 x_4$ can be implemented by the non-branching program $Pr_g$ such that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides $\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $0$ and $\max\{\nu^1, \nu^0\}=0$ for constant faults of type $1$ at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function $\varphi_1(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1 \oplus x_2 \oplus x_3 \oplus 1=x_1x_2x_3\vee \bar{x}_1\bar{x}_2\bar{x}_3$. In this basis we construct the non-branching program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)= x_1
x_2 \vee \bar{x}_3 x_4$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_1(x_1, x_2, x_3) \\
  stop(x_3) \\
  z=x_4  \\
  stop(x_4) \\
  z=x_2 \\
  stop(x_1) \\
  z=x_1  \\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is at most $\varepsilon$ because the program $Pr_g$ contains just one unreliable computational operator.

For the program $Pr_g$ we estimate probabilities of faults on the characteristic sets in two cases: 1) for constant faults of type 0, and 2) for constant faults of type 1 at the outputs of computational operators.
\begin{itemize}
\item[1)]  $\nu^1=P_1(0, 0, 1, 0)=0$,  $\nu^0=P_0(1, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\item[2)]  $\nu^1=P_1(0, 0, 1, 0)=\varepsilon$,  $\nu^0=P_0(1, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l3}
In a complete finite basis, containing the function
$\varphi_2(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus 1$, the function $g(x_1, x_2, x_3, x_4)= (x_1\vee x_2)  (x_3\vee \bar{x}_4)$ can be implemented by the non-branching program $Pr_g$ such that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides $\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $0$ and $\max\{\nu^1, \nu^0\}=0$ for constant faults of type $1$ at the outputs of computational operators.
\end{lemma}

\begin{proof}
 Let the complete finite basis $B$ contains the function $\varphi_2(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1 \oplus 1=(\bar{x}_1\vee x_2\vee x_3)(x_1\vee\bar{x}_2\vee\bar{x}_3)$. In this basis we construct the non-branching program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)= (x_1\vee x_2)  (x_3\vee \bar{x}_4)$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_2(x_1, x_2, x_3) \\
  stop(x_3) \\
  z=x_3 \\
  stop(x_4) \\
  z=x_1 \\
  stop(x_1) \\
  z=x_2 \\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is at most $\varepsilon$ because the program $Pr_g$ contains just one unreliable computational operator.

For the program $Pr_g$ we estimate probabilities of faults on the characteristic sets in two cases: 1) for constant faults of type 0, and 2) for constant faults of type 1 at the outputs of computational operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(0, 0, 0, 1)=0$,  $\nu^0=P_0(1, 1, 1, 0)=\varepsilon$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\item[2)] $\nu^1=P_1(0, 0, 0, 1)=0$,  $\nu^0=P_0(1, 1, 1, 0)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l4}
In a complete finite basis, containing the function
$\varphi_3(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus
x_1 \oplus x_2 \oplus x_3$, the function $g(x_1, x_2, x_3, x_4)= (\bar{x}_1\vee \bar{x}_2)  (x_3\vee x_4)$ can be implemented by the non-branching program $Pr_g$ such that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides $\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $0$ and $\max\{\nu^1, \nu^0\}=0$ for constant faults of type $1$ at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function $\varphi_3(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1 \oplus x_2 \oplus x_3=(x_1\vee x_2\vee x_3)(\bar{x}_1\vee\bar{x}_2\vee\bar{x}_3)$. In this basis we construct the non-branching program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)= (\bar{x}_1\vee \bar{x}_2)  (x_3\vee x_4)$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_3(x_1, x_2, x_3) \\
  stop(x_3) \\
  z=\varphi_3(x_1, x_2, x_4) \\
  stop(x_4) \\
  z=x_4 \\
\end{array}
\end{eqnarray*}

It is easy to verify that unreliability of the program $Pr_g$ is no greater $\varepsilon$ despite $Pr_g$ contains two unreliable computational operators. Indeed, with this method of constructing a non-branching program, when independent variables enter the inputs of the stop operators, the fault in the output of the program on an arbitrary input set of variables can occur due to only the fault of one of the computational operators while the work of the other computational operator does not affect the result of the program.

For the program $Pr_g$ we estimate probabilities of faults on  the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(1, 1, 0, 0)=0$,  $\nu^0=P_0(0, 0, 1, 1)=\varepsilon$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\item[2)] $\nu^1=P_1(1, 1, 0, 0)=0$,  $\nu^0=P_0(0, 0, 1, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l5}
In a complete finite basis, containing the function $\varphi_4(x_1,
x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1$, the
function $g(x_1, x_2, x_3, x_4)= \bar{x}_1x_2 \vee \bar{x}_3 x_4$
can  be implemented by the non-branching program $Pr_g$ such that
$N_\varepsilon(Pr_g)\leq \varepsilon$, and besides $\max\{\nu^1,
\nu^0\}=0$ for constant faults of type $0$ and $\max\{\nu^1,
\nu^0\}=\varepsilon$ for constant faults of type $1$ at the outputs
of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function $\varphi_4(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1=\bar{x}_1x_2x_3\vee x_1\bar{x}_2\bar{x}_3$. In this basis we construct the non-branching program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)= \bar{x}_1 x_2 \vee \bar{x}_3 x_4$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_4(x_1, x_2, x_3)\\
  stop(x_3)\\
  z=x_4\\
  stop(x_4)\\
  stop(x_1)\\
  z=x_2\\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is at most
$\varepsilon$ because the program $Pr_g$ contains just one
unreliable computational operator.

For the program $Pr_g$ we estimate probabilities of faults on  the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(1, 0, 1, 0)=0$,  $\nu^0=P_0(0, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\item[2)] $\nu^1=P_1(1, 0, 1, 0)=\varepsilon$,  $\nu^0=P_0(0, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l6}
In a complete finite basis, containing the function $\varphi_5(x_1,
x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1\oplus x_2
\oplus 1$, the function $g(x_1, x_2, x_3, x_4)= \bar{x}_1x_2 \vee
\bar{x}_3 x_4$ can be implemented by the non-branching program
$Pr_g$ such that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides
$\max\{\nu^1, \nu^0\}=0$ for constant faults of type $0$ and
$\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $1$
at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function $\varphi_5(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1\oplus x_2 \oplus 1=\bar{x}_1\bar{x}_2\vee \bar{x}_1x_3\vee \bar{x}_2x_3$. In this basis we construct the non-branching program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)= \bar{x}_1 x_2 \vee \bar{x}_3 x_4$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_5(x_1, x_2, x_3)  \\
  stop(x_3) \\
  z=x_4  \\
  stop(x_4) \\
  stop(x_1) \\
  z=x_2 \\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is no  greater
$\varepsilon$ because the program $Pr_g$ contains just one
unreliable computational operator.

For the program $Pr_g$ we estimate probabilities  of faults on the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(1, 0, 1, 0)=0$,  $\nu^0=P_0(0, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\item[2)] $\nu^1=P_1(1, 0, 1, 0)=\varepsilon$,  $\nu^0=P_0(0, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l7}
In a complete finite basis, containing the function $\varphi_6(x_1,
x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus x_1\oplus
x_2$, the function $g(x_1, x_2, x_3, x_4)= x_1x_2 \vee \bar{x}_3
x_4$  can be implemented by the non-branching program $Pr_g$ such
that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides
$\max\{\nu^1, \nu^0\}=0$ for constant faults of type $0$ and
$\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $1$
at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains  the function
$\varphi_6(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3
\oplus x_1\oplus x_2 =x_1x_2\vee x_1\bar{x}_3\vee x_2\bar{x}_3$. In
this basis we construct the non-branching program $Pr_g$
implementing the function $g(x_1, x_2, x_3, x_4)= x_1 x_2 \vee
\bar{x}_3 x_4$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_6(x_1, x_2, x_3) \\
  stop(x_3) \\
  z=x_4 \\
  stop(x_4) \\
  z=x_2 \\
  stop(x_1) \\
  z=x_1 \\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is no  greater
$\varepsilon$ because the program $Pr_g$ contains just one
unreliable computational operator.

For the program $Pr_g$ we estimate probabilities of faults  on the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(0, 0, 1, 0)=0$,  $\nu^0=P_0(1, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\item[2)] $\nu^1=P_1(0, 0, 1, 0)=\varepsilon$,  $\nu^0=P_0(1, 1, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l8}
In a complete finite basis, containing the function $\varphi_7(x_1,
x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3 \oplus 1$, the
function $g(x_1, x_2, x_3, x_4)= \bar{x}_1\bar{x}_2 \vee \bar{x}_3
x_4$  can be implemented by the non-branching program $Pr_g$ such
that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides
$\max\{\nu^1, \nu^0\}=0$ for constant faults of type $0$ and
$\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $1$
at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function
$\varphi_7(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3
\oplus 1 =\bar{x}_1\bar{x}_2\vee \bar{x}_1\bar{x}_3\vee
\bar{x}_2\bar{x}_3$. In this basis we construct the non-branching
program $Pr_g$ implementing the function $g(x_1, x_2, x_3, x_4)=
\bar{x}_1\bar{x}_2 \vee \bar{x}_3 x_4$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_7(x_1, x_2, x_3) \\
  stop(x_3) \\
  z=x_4 \\
  stop(x_4) \\
  stop(x_1) \\
  stop(x_2) \\
  z=\varphi_7(x_1, x_2, x_3) \\
\end{array}
\end{eqnarray*}

Unreliability of the program $Pr_g$ is at most $\varepsilon$  since
independent variables enter the inputs of the stop operators. So on
an arbitrary input set of variables, the fault in the output of the
program can occur due to only the fault of one of the computational
operators while the work of the other computational operator does
not affect the result of the program.

For the program $Pr_g$ we estimate probabilities of faults on the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(1, 1, 1, 0)=0$,  $\nu^0=P_0(0, 0, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\item[2)] $\nu^1=P_1(1, 1, 1, 0)=\varepsilon$,  $\nu^0=P_0(0, 0, 0, 1)=0$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\end{itemize}

\end{proof}

\begin{lemma}\label{l9}
In a complete finite basis, containing the function
$\varphi_8(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3$, the function $g(x_1, x_2, x_3, x_4)= (x_1\vee x_2) (x_3 \vee \bar{x}_4)$ can be implemented by the non-branching program $Pr_g$ such that $N_\varepsilon(Pr_g)\leq \varepsilon$, and besides $\max\{\nu^1, \nu^0\}=\varepsilon$ for constant faults of type $0$ and $\max\{\nu^1, \nu^0\}=0$ for constant faults of type $1$ at the outputs of computational operators.
\end{lemma}

\begin{proof}
Let the complete finite basis $B$ contains the function
$\varphi_8(x_1, x_2, x_3)=x_1 x_2\oplus x_1 x_3 \oplus x_2 x_3
=x_1x_2\vee x_1x_3\vee x_2x_3$. In this basis we construct the
non-branching program $Pr_g$ implementing the function $g(x_1, x_2,
x_3, x_4)= (x_1\vee x_2) (x_3 \vee \bar{x}_4)$:
\begin{eqnarray*}
\begin{array}{l}
  z=\varphi_8(x_1, x_2, x_3)\\
  stop(x_3)\\
  z=x_3\\
  stop(x_4)\\
  z=x_1\\
  stop(x_1)\\
  z=x_2 \\
\end{array}
\end{eqnarray*}

Obviously, unreliability of the program $Pr_g$ is no greater
$\varepsilon$ because the program $Pr_g$ contains just one
unreliable computational operator.

For the program $Pr_g$ we estimate probabilities of faults on  the
characteristic sets in two cases: 1) for constant faults of type 0,
and 2) for constant faults of type 1 at the outputs of computational
operators.
\begin{itemize}
\item[1)] $\nu^1=P_1(0, 0, 0, 1)=0$,  $\nu^0=P_0(1, 1, 1, 0)=\varepsilon$. Thus $\max\{\nu^1, \nu^0\}=\varepsilon$.
\item[2)] $\nu^1=P_1(0, 0, 0, 1)=0$,  $\nu^0=P_0(1, 1, 1, 0)=0$. Thus $\max\{\nu^1, \nu^0\}=0$.
\end{itemize}
\end{proof}

Let us prove Theorem 3.

\begin{proof}
Let $B$ be an arbitrary complete finite basis;
 the conditional stop operators of some non-branching program are absolutely
 reliable, and the computational operators independently of each other with
 probability $\varepsilon (\varepsilon\in (0,1/960])$ go to the failure conditions
 of type 0 at the outputs. Let $f$ be any Boolean function.

For the basis $B$ by Lemma \ref{l1} at least one of the following conditions holds:

\begin{itemize}
  \item the basis $B$ contains a non-linear function of two variables, i.e. either

    1) generalized disjunction $x_1^{\alpha_1}\vee x_2^{\alpha_2}$ ($\alpha_1, \alpha_2 \in \{0, 1\}$), or

    2) generalized conjunction $x_1^{\alpha_1}\& x_2^{\alpha_2}$;
 \item the basis $B$ contains a special function, i.e. either

    3) one of the functions $\varphi_i(x_1, x_2, x_3)$, $i \in \{1, 4, 5, 6, 7\}$, or

    4) one of the functions $\varphi_i(x_1, x_2, x_3)$, $i \in \{2, 3, 8\}$.
\end{itemize}

Let's consider each of these four cases.

1) Let the basis $B$ contains some function of the form $x_1^{\alpha_1}\vee x_2^{\alpha_2}$.

It is shown in \cite{17} that in the basis $B$ any  Boolean function
$f$ can be implemented by the non-branching program $Pr_f$ with
unreliability $N_\varepsilon (Pr_f) \leq\varepsilon +
9\varepsilon^2$ for all $\varepsilon\in (0,1 / 960]$. Theorem
\ref{th3} is true in this part.

In cases 2 and 3 first of all we implement the function  $f$ by the
non-branching program $Pr_f$ such that $N_\varepsilon (Pr_f)
\leq\varepsilon^2$ for all $\varepsilon\in (0,1 / 960]$, and then
the function $f$ for $\forall t\in \mathbf{N}$ is implemented by the
program with unreliability at most $\varepsilon^t$ for all
$\varepsilon\in (0,1 / 960]$. Note that for $t = 1$ and $t = 2$ this
theorem is true since $\varepsilon^2\leq\varepsilon$. Therefore, it
remains to consider the case $t\geq3$.

2) Let the basis $B$ contains some function of the  form
$x_1^{\alpha_1}\& x_2^{\alpha_2}$.

Previously \cite{18} it was proved that in the basis $B$ any
Boolean function $f$ can be implemented by the non-branching program
$Pr_f$ such that $N_\varepsilon (Pr_f) \leq\varepsilon^2$ for all
$\varepsilon\in(0, 1/960]$.

3) Let the basis $B$ contains at least one of the functions
$\varphi_1(x_1, x_2, x_3)$, $\varphi_4(x_1, x_2, x_3)$,
$\varphi_5(x_1, x_2, x_3)$, $\varphi_6(x_1, x_2, x_3)$, or
$\varphi_7(x_1, x_2, x_3)$.

Then the function $g (x_1, x_2, x_3, x_4)$, equal to  either the
function $x_1x_2\vee \bar{x}_3x_4$  (Lemmas \ref{l2} and \ref{l7}),
either $\bar{x}_1x_2\vee \bar{x}_3x_4$  (Lemmas \ref{l5} and
\ref{l6}), or $\bar{x}_1\bar{x}_2\vee \bar{x}_3x_4$  (Lemma
\ref{l8}), can be implemented by the program $Pr_g$ with
unreliability $N_\varepsilon (Pr_g) \leq \varepsilon$ and
$\max\{\nu^1, \nu^0\}=0$.

By Theorem \ref{th1} the function $f$ can be implemented  by the
circuit $S$ such that $N_\varepsilon (S) \leq3,11\varepsilon$
\linebreak for all $\varepsilon\in(0, 1/960]$.

We apply Theorem \ref{th2} using the program $Pr_g$ and taking  the
circuit $S$ as the program $R_f$ \linebreak (see Remark 1). We
construct the program $Pr_f$ assuming $N = 3,11\varepsilon$ and
taking into account the conditions $\max\{\nu^1, \nu^0\}=0$ and
$N_\varepsilon (Pr_g) \leq \varepsilon$. By Theorem \ref{th2} the
non-branching program $Pr_f$ implements the function $f$ with
unreliability $N_\varepsilon (Pr_f) \leq52\varepsilon^2$ for all
$\varepsilon\in(0, 1/960]$.

Let's perform one more iteration step. We now take for $R_f$ already
constructed program $Pr_f$ unreliability of which for all
$\varepsilon\in(0, 1/960]$ satisfies the inequality $N_\varepsilon
(R_f) \leq52\varepsilon^2\leq0,0542\varepsilon$.\linebreak Let $N =
0,0542\varepsilon$. We again use Theorem \ref{th2} considering
$\max\{\nu^1, \nu^0\}=0$ and $N_\varepsilon (Pr_g) \leq\varepsilon$.
\linebreak Then the function $f$ can be implemented by the
non-branching program $Pr_f^{(2)}$ such that \linebreak
$N_\varepsilon (Pr_f^{(2)}) \leq0,23\varepsilon^2\leq \varepsilon^2$
for all $\varepsilon\in(0, 1/960]$.

Thus, in cases 2 and 3 an arbitrary function $f$ can be implemented
by such non-branching program (denote it by $Pr_f^*$) that
$N_\varepsilon (Pr_f^*) \leq \varepsilon^2$ for all
$\varepsilon\in(0, 1/960]$.

In each of cases 2 and 3 we again use Theorem \ref{th2} taking now
for $R_f$ the non-branching program $Pr_f^*$ and assuming $N =
\varepsilon^2$. Then the function $f$ can be implemented by such
program $Pr_f^{*(1)}$ that the inequality
$N_\varepsilon(Pr_f^{*(1)})\leq 4N (N_\varepsilon(Pr_g) + N) \leq 4
\varepsilon^2 (\varepsilon + \varepsilon^2) = 4 \varepsilon^3 (1+
\varepsilon) \leq 4 \varepsilon^3\cdot 1,1 \leq 5 \varepsilon^3$
\linebreak (as $\varepsilon\in(0, 1/960]$) is valid.

Now we take as $N$ the quantity $5\varepsilon^3$ and again use
Theorem \ref{th2} (we'll make one more step of the iteration). Then
the function $f$ can be implemented by such program $Pr_f^{*(2)}$
that the inequality
$N_\varepsilon(Pr_f^{*(2)})\leq5\varepsilon\cdot5\varepsilon^3=(5\varepsilon)^2\varepsilon^2$
holds.

It is easy to see that after $m$ iterations the function $f$ can be
implemented by the program $Pr_f^{*(m)}$ such that
$N_\varepsilon(Pr_f^{*(m)})\leq(5\varepsilon)^m\varepsilon^2$.

Let $t$ be any natural number, $t\geq 3$ (we remind that for $t = 1$
and $t = 2$  this theorem is true). We choose a natural number $m$
for which the inequality $m\geq(t-2)\log_{5\varepsilon}\varepsilon$
is valid. Then $(5\varepsilon)^m \leq \varepsilon^{t-2}$, i.e.
$(5\varepsilon)^m\varepsilon^2 \leq \varepsilon^{t}$. Hence,
$N_\varepsilon(Pr_f^{*(m)})\leq\varepsilon^t$.

Note that since $m$ is the number of iterations it is reasonable to
choose the  smallest natural number $m$ for which the inequality
$m\geq(t-2)\log_{5\varepsilon}\varepsilon$ holds.

4) Let the basis $B$ contains one of the functions  $\varphi_2(x_1,
x_2, x_3)$, $\varphi_3(x_1, x_2, x_3)$, or $\varphi_8(x_1, x_2,
x_3)$.

Then the function $g (x_1, x_2, x_3, x_4)$, equal to either  the
function $(x_1\vee x_2)(x_2\vee\bar{x}_4)$ (Lemmas \ref{l3} and
\ref{l9}) or $(\bar{x}_1\vee \bar{x}_2)(x_2\vee x_4)$ (Lemma
\ref{l4}), can be implemented by the program $Pr_g$ with
unreliability $N_\varepsilon(Pr_g) \leq \varepsilon$ and
$\max\{\nu^1, \nu^0\}=\varepsilon$.

By Theorem \ref{th1} the function $f$ can be implemented by  such
circuit $S$ that $N_\varepsilon(S) \leq3,11\varepsilon$ \linebreak
for all $\varepsilon\in(0, 1/960]$.

We apply Theorem \ref{th2} using the program $Pr_g$ and taking  the
program $S$ as the program $R_f$ (see Remark \ref{r1}). We construct
the program $Pr_f$ assuming $N = 3,11\varepsilon$ and taking into
account the conditions $\max\{\nu^1, \nu^0\}=\varepsilon$ and
$N_\varepsilon (Pr_g) \leq\varepsilon$. By Theorem \ref{th2} the
non-branching program $Pr_f$ implements the function $f$ with
unreliability $N_\varepsilon (Pr_f)\leq\varepsilon +
52\varepsilon^2$ for all $\varepsilon\in(0, 1/960]$.

Let's perform one more iteration step. Now we take for $R_f$ already
constructed program $Pr_f$ unreliability of which for all
$\varepsilon\in(0, 1/960]$ satisfies the inequality $N_\varepsilon
(R_f) \leq\varepsilon +
52\varepsilon^2\leq1,0542\varepsilon$.\linebreak Let $N =
1,0542\varepsilon$. Use Theorem \ref{th2} taking $\max\{\nu^1,
\nu^0\}=\varepsilon$ and $N_\varepsilon (Pr_g) \leq\varepsilon$.
Then the function $f$ can be implemented by a non-branching program
$Pr_f$ such that $N_\varepsilon (Pr_f) \leq\varepsilon +
9\varepsilon^2$ \linebreak for all $\varepsilon\in(0, 1/960]$.
\end{proof}

\begin{corollary}\label{c1} For faults of type 0 at the outputs of computational operators the following holds:

1) if the complete finite basis  contains one of the functions
$\varphi_1(x_1, x_2, x_3)$, $\varphi_4(x_1, x_2, x_3)$,
$\varphi_5(x_1, x_2, x_3)$, $\varphi_6(x_1, x_2, x_3)$,
$\varphi_7(x_1, x_2, x_3)$, or the function of the form
$x_1^{\alpha_1}\& x_2^{\alpha_2}$$(\alpha_1, \alpha_2\in\{0, 1\})$,
then any Boolean function can be implemented by the non-branching
program of arbitrarily high preassigned reliability for all
$\varepsilon\in(0, 1/960]$ $($as
$\lim\limits_{t\to\infty}\varepsilon^t=0)$;

2) if the complete finite basis contains one  of the functions
$\varphi_2(x_1, x_2, x_3)$, $\varphi_3(x_1, x_2, x_3)$,
$\varphi_8(x_1, x_2, x_3)$, or the function of the form
$x_1^{\alpha_1}\vee x_2^{\alpha_2}$$(\alpha_1, \alpha_2\in\{0,
1\})$, then any Boolean function can be implemented by the
non-branching program with unreliability asymptotically no greater
than $\varepsilon$ for $\varepsilon\to 0$.
\end{corollary}

Theorem \ref{th4} is proved similarly to Theorem \ref{th3} using
the same Lemmas \ref{l2}-\ref{l9} but in the case of type 1 faults
at the outputs of computational operators.

\begin{corollary}\label{c2} For faults of type 1 at the outputs of computational operators the following holds:

1) if the complete finite basis contains one  of the functions
$\varphi_1(x_1, x_2, x_3)$, $\varphi_4(x_1, x_2, x_3)$,
$\varphi_5(x_1, x_2, x_3)$, $\varphi_6(x_1, x_2, x_3)$,
$\varphi_7(x_1, x_2, x_3)$, or the function of the form
$x_1^{\alpha_1}\& x_2^{\alpha_2}$  $(\alpha_1, \alpha_2\in\{0,
1\})$, then any Boolean function can be implemented by the
non-branching program with  unreliability asymptotically no greater
than $\varepsilon$ for $\varepsilon\to 0$;

2) if the complete finite basis contains one  of the functions
$\varphi_2(x_1, x_2, x_3)$, $\varphi_3(x_1, x_2, x_3)$,
$\varphi_8(x_1, x_2, x_3)$, or the function of the form
$x_1^{\alpha_1}\vee x_2^{\alpha_2}$$(\alpha_1, \alpha_2\in\{0,
1\})$, then any Boolean function can be implemented by the
non-branching program of arbitrarily high preassigned reliability
\linebreak  for all $\varepsilon\in(0, 1/960]$ $($as
$\lim\limits_{t\to\infty}\varepsilon^t=0)$.
\end{corollary}

\section{Conclusions}

\begin{enumerate}
\item If the complete finite basis contains one of
the functions $\varphi_1(x_1, x_2, x_3)$, $\varphi_4(x_1, x_2, x_3)$, $\varphi_5(x_1, x_2, x_3)$, $\varphi_6(x_1, x_2, x_3)$, $\varphi_7(x_1, x_2, x_3)$, or the function of the form $x_1^{\alpha_1}\& x_2^{\alpha_2}$ \linebreak $(\alpha_1, \alpha_2\in\{0, 1\})$, then
\begin{itemize}
  \item for faults of type 0 at the outputs of computational operators any Boolean function can be implemented by the non-branching program with a conditional stop operator of arbitrarily high preassigned reliability for all $\varepsilon\in(0, 1/960]$;
  \item for faults of type 1 at the outputs of computational operators any Boolean function can be implemented by the non-branching program with unreliability at most $\varepsilon+9\varepsilon^2$ \linebreak for all $\varepsilon\in(0, 1/960]$.
\end{itemize}

\item If the complete finite basis contains one of the functions $\varphi_2(x_1, x_2, x_3)$, $\varphi_3(x_1, x_2, x_3)$, $\varphi_8(x_1, x_2, x_3)$, or the function of the form $x_1^{\alpha_1}\vee x_2^{\alpha_2}$ $(\alpha_1, \alpha_2\in\{0, 1\})$, then
\begin{itemize}
  \item for faults of type 0 at the outputs of computational operators any Boolean function can be implemented by the non-branching program with unreliability at most $\varepsilon+9\varepsilon^2$ \linebreak for all $\varepsilon\in(0, 1/960]$;
  \item for faults of type 1 at the outputs of computational operators any Boolean function can be implemented by the non-branching program of arbitrarily high preassigned reliability for all $\varepsilon\in(0, 1/960]$.
\end{itemize}
\end{enumerate}

\begin{acknowledgments}
Partially supported by Russian Foundation for Basic Research, Grant
17-01-00451-a.
\end{acknowledgments}


%
% The Bibliography
%

\begin{thebibliography}{99}

\bibitem{1}
\refitem{article} A.~V.~Chashkin, \textquotedblleft On the average
time for the computation  of the values of Boolean
functions,\textquotedblright Discrete Anal. Issled. Oper. Ser. 1
\textbf{4} (1), 60--78 (1997) [in Russian].

\bibitem{2}
\refitem{article} A.~ V.~Chashkin, \textquotedblleft On the mean
time for computing  Boolean operators,\textquotedblright Discrete
Anal. Issled. Oper. Ser. 1 \textbf{5} (1), 88--103 (1998) [in
Russian].

\bibitem{3}
\refitem{article} J.~von Neuman, \textquotedblleft  Probabilistic
logics  and the synthesis of reliable organisms from unreliable
components,\textquotedblright Automata studies (AM-34), Ed. by C.
Shannon and Mc. Carthy J., 34--98 (Princeton University Press,
1956).

\bibitem{4}
\refitem{article} S.~I.~Ortyukov, \textquotedblleft On redundancy of
Boolean function realization with circuits of unreliable
elements,\textquotedblright in \emph{Proc. of Discrete Mathematics
and its Applications Seminar}, 1987, Moscow, USSR, 166--168 [in
Russian].

\bibitem{5}
\refitem{article} D.~Uhlig, \textquotedblleft  Reliable networks
from unreliable  gates with almost minimal
complexity,\textquotedblright Fundamentals of Computation Theory,
FCT 1987, Lecture Notes in Computer Science \textbf{278}, 462--469
(Springer, Berlin, Heidelberg, 1987).

\bibitem{6}
\refitem{article} S.~V.~Yablonskiy, \textquotedblleft
Asymptotically the  best method of synthesis of reliable circuits
from unreliable elements, \textquotedblright Banach Center
\textbf{7}, 11--19 (1982).

\bibitem{7}
\refitem{phdthesis} M.~A.~Alekhina, Synthesis, reliability and
complexity of  circuits from unreliable functional elements, D.sci.
(Phys. Math.) diss., Penz. State Univ., Penza (2004) [in Russian].

\bibitem{8}
\refitem{phdthesis} V.~V.~Chugunova, Synthesis of asymptotically
optimal reliable  circuits under inverse failures at the element
outputs,  Ph.d. (Phys. Math.) diss., Penz. State Univ., Penza (2007)
[in Russian].

\bibitem{9}
\refitem{phdthesis} A.~V.~Vasin, Asymptotically optimal circuits on
reliability  in complete final basis of  three-input gates, Ph.d.
(Phys. Math.) diss., Penz. State Univ., Penza (2010) [in Russian].

\bibitem{10}
\refitem{phdthesis} O.~Y.~Barsukova, The synthesis of reliable
circuits  which realizes binary and ternary logics functions, Ph.d.
(Phys. Math.) diss., Penz. State Univ., Penza  (2014) [in Russian].

\bibitem{11}
\refitem{phdthesis} S.~M.~Grabovskaya, Asymptotically optimal
reliable  non-branching programs, Ph.D. (Phys. Math.) diss., Penz.
State Univ., Penza  (2012) [in Russian].

\bibitem{12}
\refitem{article} M.~A.~Alekhina and S.~M.~Grabovskaya,
\textquotedblleft  Reliability of nonbranching programs in an
arbitrary complete finite basis,\textquotedblright  Russ. Math.
\textbf{56}  (2), 10--18 (2012).

\bibitem{13}
\refitem{article} M.~A.~Alekhina, \textquotedblleft On reliability
of circuits  over an arbitrary complete finite basis under
single-type constant faults at outputs of elements,
\textquotedblright Discrete Math. Appl. \textbf{22} (4), 383--391
(2012).

\bibitem{14}
\refitem{article} S.~M.~Grabovskaya, \textquotedblleft On methods of
raise  the reliability of non-branching programs with a conditional
stop operator, \textquotedblright in \emph{Proceeding Int. Conf.
Problems of automation and control in technical systems, dedicated
to the 70th anniversary of the Victory in the Great Patriotic War},
2015, Penza, Russia, 339--342 [in Russian].

\bibitem{15}
\refitem{article} N.~P.~Red'kin, \textquotedblleft On complete
checking  tests for circuits of functional elements,
\textquotedblright in \emph{Mathematical Problems of Cybernetics}
\textbf{2} (Nauka, Moscow, 1989), 198--222 [in Russian].

\bibitem{16}
\refitem{book} S.~V.~Yablonskii, \emph{Introduction into Discrete
Mathematics}  (Nauka, Moscow, 2001) [in Russian].

\bibitem{17}
\refitem{article} S.~M.~Grabovskaya, \textquotedblleft On
reliability  of non-branching programs in bases containing
generalized disjunction,  \textquotedblright in \emph{Proceeding XIX
Int/ Sci. and Meth. Conf University Education (MKUO-2015), dedicated
to the 70th anniversary of the Victory in the Great Patriotic War},
2015, Penza, Russia, 218--219 [in Russian].

\bibitem{18}
\refitem{article} S.~M.~Grabovskaya, \textquotedblleft On
reliability  of non-branching programs in bases containing
generalized konjunction, \textquotedblright in \emph{Proceeding Int.
Conf. Problems of automation and control in technical systems,
dedicated to the 70th anniversary of the Victory in the Great
Patriotic War}, 2015, Penza, Russia, 342--345 [in Russian].

\end{thebibliography}
\end{document}
