microsoft word readscl 2019 docx readsclean a new approach to error correction of sequencing reads based on alignments clustering oleg fokin 1 anastasia bakulina 1 2 igor seledtsov 1 and victor solovyev 1 1 softberry inc mount kisco ny usa 2 novosibirsk state university novosibirsk russia motivation next generation methods of dna sequencing produce relatively high rate of reading errors which interfere with de novo genome assembly of newly sequenced organisms and particularly affect the quality of snp detection important for diagnostics of many hereditary diseases there exists a number of programs developed for correcting errors in ngs reads such programs utilize various approaches and are optimized for different specific tasks but all of them are far from being able to correct all errors especially in sequencing reads that crossing by repeats and dna from di polyploid eukaryotic genomes results this paper describes a novel method of error correction based on clustering of alignments of similar reads this method is implemented in readsclean program which is designed for cleaning illumina hiseq sequencing reads we compared readsclean to other reads cleaning programs recognized to be the best by several publications our sequence assembly tests using actual and simulated sequencing reads show superior results achieved by readsclean availability and implementation readsclean is implemented as a standalone c code it is incorporated in an error correction pipeline and is freely available to academic users at softberry web server www softberry com supplementary information included introduction next generation sequencing methods have revolutionized the field of genomic research dramatically shortening time and decreasing cost of sequencing compared to previous generation methods resequencing of genomes including human genome and de novo sequencing of bacterial genomes have become routine tasks still de novo assembly of eukaryotic genomes much larger and more complex than bacterial ones remains a difficult task and requires a lot of bioinformatics work it is especially difficult to correctly assemble sequences of regions containing repeats that differ by a few nucleotides per copy such differences are routinely subjected to erroneous correction as repeats comprise up to 40 of eukaryotic genomes it is very important to improve performance of genome assembling algorithms on such sequences one of the ways to facilitate this process is to correct errors in sequencing reads before their assembly into contigs it was previously shown that employing the programs of error correction visibly improves quality of contig assembly specifically value of n 50 meaning that 50 of genome is covered by contigs of at least that length increases substantially salzberg et al 2012 different sequencing platforms generate different types of errors and this has to be taken into account when choosing an error correction program this paper covers illumina hiseq platform for a number of years illumina remains a leading manufacturer of sequencing machines and its hiseq series is currently the most common sequencing platform in the world it is designed for sequencing entire large genomes for instance one run of hiseq 4000 yields up to five billion reads illumina hiseq reads are usually 100 150 bp long are paired and have quality of 75 bp q 30 i e for at least 75 of bases have an error rate of no more than 0 1 illumina 2015 overwhelming majority of that platform s errors are single nucleotide substitutions despite relatively frequent occurrence of errors in reads redundant coverage of a genome by reads usually provides enough information to correct most of them the majority of algorithms of error correction can be divided into the following three groups 1 k spectrum based these methods are based on building a spectrum of k mers sequences of k nucleotides in a read rarely found k mers are assumed to contain an error examples of such programs are musket liu et al 2013 bless heo et al 2014 and blue greenfield et al 2014 2 suffix tree array based a suffix tree is built and its analysis finds rare and therefore putatively erroneous variants examples are racer ilie and molnar 2013 shrec schr der et al 2009 and hitec ilie et al 2011 3 multiple sequence alignment based these methods utilize various methods of aligning the reads and then correct mismatches in these alignments examples are coral salmela and schr der 2011 and karect allam et al 2015 recently developed karect program allam et al 2015 treats each read as a reference performs multiple alignment for a set of reads similar to a reference read stores accumulated results in a partial order graph computes weights for the graph edges and construct corrected reads karect consistently outperforms other existing techniques in terms of both individual bases error correction up to 10 accuracy gain and post de novo assembly quality up to 10 increase of nga 50 to reduce computational cost during an alignment phase the algorithm selects a subset 30 of possible candidate reads and uses them to generate reference read corrections such procedure often selects a set of reads from different clusters of repeated sequences which comprise a very significant fraction of eukaryotic genomes as a consequence of such selection a reference read can be corrected by reads from a wrong family of repeats to overcome this problem we developed a new error correction algorithm that initially clusterizes overlapping reads and then corrects a reference read using the closest cluster the algorithm is implemented in readsclean program which can be classified as multiple sequence alignment based when used on test sets of ngs reads readscean outperforms existing techniques in terms of both individual base error correction and de novo assembly of corrected reads into contigs methods description of algorithm readsclean is able to simultaneously process several sets of reads in a configuration file user specifies type of each set mate pair paired end single maximum length and a distance between paired reads it is possible to use a set of reads to clean another set which is useful when coverage of a genome by a set to be cleaned is relatively low so such set cannot effectively be used to clean itself another potential example is a set that contains unusually large number of errors then it may make sense to use reads of a cleaner set cleaning database for alignment with reads that we intend to correct using a specific set for cleaning also allows splitting a set into several subsets and processing them in parallel on different computes nodes while using an entire initial set as a cleaning database all these situations are routinely encountered while working with sequencing reads of large eukaryotic genomes the error correction cleaning algorithm consists of the following principal steps fig 1 1 creating a multiple alignment of a read being cleaned 2 frequency based correction of obvious errors 3 clustering reads in a multiple alignment 4 correcting random errors in clusters and possible second clustering 5 choosing a cluster for a read to use in correction 6 recording the results figure 1 diagram of work flow to correct errors in reads cleaning reads by readsclean program building multiple alignment for a read being cleaned reads from a reference set are aligned with a read to be cleaned query read we consider only alignments without internal gaps to expedite selection of reads for alignment the reads are hashed in advance if each pairwise alignment satisfies preset criteria of similarity such alignment is added to a multiple alignment regions of aligned sequences not overlapping with a query read are discarded fig 2 a figure 2 a an example of multiple alignment upper line is a query read read being cleaned mismatches with that read are shown in grey circles small letters positions columns in the alignment where mismatches are found are shown in boxes b the same alignment after clustering and error correction there are three clusters shown mismatches that are excluded a b from the subsequent clustering are highlighted in clear circles a cluster on top exhibiting the highest similarity to a query read is used for correcting errors in the read black rhombus shows a corrected error read tails that do not align to the query read are ignored frequency based correction of obvious errors at this stage each column of a multiple alignment is analyzed if in a given position the most frequent nucleotide is found at least n times and each of remaining nucleotides no more than m times all less frequent nucleotides are replaced by the most frequent by default n 7 and m 1 such positions are marked to be excluded from subsequent clustering clustering of reads in multiple alignment reads in an alignment are clustered using descending hierarchical clustering method a single position is chosen where distribution of frequencies of nucleotides is closest to random reads in the alignment are sorted into clusters corresponding to a common nucleotide found in that position and the position is excluded from the subsequent clustering in each cluster positions that are dominated by a single nucleotide determined by the same way as in frequency based error correction are also excluded from the subsequent clustering then each cluster is split into subclusters based on the same rules and so forth the process continues until all positions in the alignment are marked to be excluded from further clustering correction of reads in clusters and second clustering a consensus sequence is determined for each cluster and query reads are corrected in order to correspond to the selected consensus positions where the consensus nucleotide is found only a few times by default less than five times are marked as unreliable then the corrected reads are subjected to a second round of clustering in many cases clusters remain unchanged but second clustering somewhat improves accuracy in our tests while not requiring too much time to complete data not shown choosing cluster for read correction the alignment clusters are sorted by similarity of their consensus sequences to a query read and also by their lengths from longest to shortest clusters covering different regions of a query read can be merged if they overlap by at least 30 and if their consensus sequences do not contradict each other for such merged clusters a new consensus sequence is determined for correcting a read a cluster with highest similarity of its consensus sequence which does not contain unreliable positions is chosen if there are several clusters of same similarity one that contains higher number of reads is chosen fig 2 b recording the results if for a given query read no similar clusters are found covering its entire length and without unreliable positions or if there are several clusters with roughly the same similarity such read is still corrected but it is marked as unreliable the program has an option of recording unreliable reads into a separate file if one of paired reads is marked unreliable its reliable pair is recorded in a file with single reads if an alignment can t be built for a query read or if no acceptably similar clusters were found such read is not corrected and also recorded in a file of unreliable reads theoretically non reliable reads can be re cleaned by using newly cleaned reliable reads as a reference our tests however show that this doesn t improve the results for de novo genome assembly it is sometimes desirable to use all reads including unreliable ones especially if they constitute more than 1 of all reads because discarding unreliable reads would reduce sequencing coverage but for snp finding it is better to avoid unreliable reads in order to reduce the number of false positives if the number of unreliable reads is less than 1 we recommend discarding them for genome assembly computing if the number is between 1 and 5 both variants of assembly with and without unreliable reads can be attempted heterozygosity of eukaryotic genomes doesn t pose a big problem for our approach as each allele is usually sorted into a separate cluster in a cleaning set and the algorithm corrects each read individually and independently from other reads results testing procedure the following programs were used to compare error correction accuracy racer ilie and molnar 2013 sga simpson and durbin 2012 musket liu et al 2013 coral salmela and schr der 2011 karect allam et al 2015 these programs were acknowledged to be the best in previously published reviews and publications allam et al 2015 alic et al 2016 the parameters settings that used to run these programs are listed in the supplement to compare error correction programs we used both simulated and real sequencing data simulated data were obtained with simseq program https github com jstjohn simseq that program introduces errors specific to illumina platform with the average number of errors around 0 9 we generated simulated reads for e coli 1 855 870 pe reads 100 bp read length 300 bp distance between paired reads 0 936 errors and human chr 14 35 315 412 pe reads 100 bp length 300 bp distance between paired reads 0 962 errors these sets represented about 40 x genome coverage using our own software we also introduced additional errors into chr 14 simulated reads to obtain a set with error frequencies up to 3 the results of reads cleaning provide information on the number of corrected errors missed errors errors replaced by other errors and introduced errors as the real sequenced reads we used data from gage project salzberg et al 2012 for the following genomes staphylococcus aureus rhodobacter sphaeroides and human chromosome 14 in all cases only files from library 1 were used they contain paired reads in fastq format with the following parameters s aureus average read length 101 bp insert length 180 bp number of reads 1 294 104 r sphaeroides average read length 101 bp insert length 180 bp number of reads 2 050 868 h sapiens chr 14 average read length 101 bp insert length 155 bp number of reads 36 504 800 to evaluate performance of read correction software de novo sequence assembly was performed as its results give some indication of usefulness of error correction methods the programs used for assembly were sga simpson and durbin 2012 velvet zerbino and birney 2008 soapdenovo luo et al 2012 and spades bankevich et al 2012 parameters settings of these programs are listed in the supplement quality of assembly was estimated using quast program gurevich et al 2013 correction quality evaluation on simulated reads the results of tests on simulated data are shown in tables 1 3 since coral program not only corrects errors but also discards reads deemed low quality its results are not presented the table shows the corrected errors errors left after correction missed errors errors replaced by other errors and introduced errors table 1 simulated e coli reads initially containing 1 737 154 0 936 errors absolute number and percentages of initial number of errors are shown program corrected errors errors left after correction missed errors errors replaced by errors introduced errors readsclean 1 736 962 99 9889 265 0 0153 147 0 0085 45 0 0026 73 0 0042 racer 1 734 832 99 87 22 644 1 30 2 175 0 13 147 0 01 20 322 1 17 sga 1 733 562 99 79 4 550 0 26 3 552 0 20 40 0 002 958 0 06 musket 1 731 964 99 70 5 620 0 32 5 013 0 29 177 0 01 430 0 02 karect 1 736 858 99 98 784 0 05 217 0 01 79 0 005 488 0 03 table 2 simulated human chromosome 14 reads initially containing 33 977 454 0 962 errors absolute numbers and percentages of initial number of errors are shown program corrected errors errors left after correction missed errors errors replaced by errors introduced errors readsclean 33 909 951 99 8013 119 617 0 3520 62 434 0 1838 5 069 0 0149 52 114 0 1534 racer 31 242 161 91 95 22 157 432 65 21 2 588 218 7 62 147 075 0 43 19 422 139 57 16 sga 31 511 057 92 74 3 294 087 9 69 2 436 166 7 17 30 231 0 09 827 690 2 44 musket 30 533 489 89 86 4 151 370 12 22 3 354 877 9 87 89 088 0 26 707 405 2 08 karect 32 573 973 95 87 1 676 124 9 87 1 359 854 4 00 43 627 0 13 272 643 0 80 table 3 simulated human chromosome 14 reads initially containing 106 213 917 about 3 errros absolute numbers and percentages of initial number of errors are shown program corrected errors errors left after correction missed errors errors replaced by errors introduced errors readsclean 105 758 530 99 5713 2 287 921 2 1541 332 354 0 3129 123 033 0 1158 2 254 036 2 1222 1 832 534 1 7253 racer 97 200 336 91 51 51 332 436 48 33 6 982 319 6 57 2 031 262 1 91 42 318 855 39 84 sga 93 661 600 88 18 14 632 878 13 78 10 709 063 10 08 1 843 254 1 74 2 080 561 1 96 musket 90 551 567 85 25 18 532 282 14 47 15 365 822 14 47 296 528 0 28 2 869 932 2 70 karect 101 477 152 95 54 5 534 059 5 21 4 490 772 4 23 245 993 0 23 797 294 0 75 the results in tables 1 3 demonstrate that all programs correct the majority of errors it can be seen however that the readsclean corrects more errors on human chr 14 reads than other programs while also leaving fewer miscorrected and introduced errors readsclean also performs better then the other programs on human chr 14 reads with 3 of errors on e coli data readsclean and karect miss comparable percentage of errors but karect introduces more new errors while other programs perform markedly worse than these two in short readsclean shows superior performance on all three sets of simulated reads applying error correction to improve sequence assembling we compared contig assemblies from uncorrected reads and those cleaned by different error correction programs many de novo assembly programs have their own built in algorithms of cleaning and filtering reads for instance masurca zimin et al 2013 we used the programs that lack such option or where it can be switched off for sga and velvet programs we used the same settings as gage project for soapdenovo its parameters settings were adopted from the program manual as we used newer version than gage project for spades bankevich et al 2012 we used default settings and turned off the error correction step as criteria of assembly quality we used the following measures nga 50 similar to n 50 but takes into account sizes of alignments of contigs to genome rather than simply sizes of contigs thus excluding from consideration misassembled contigs genome coverage a fraction of genome covered by contigs human chr 14 contigs were aligned to the chr 14 sequence which contains many unknown positions n in a sequence therefore actual genome coverage cannot exceed 82 24 we excluded these n regions from consideration in these tests that allowing coverage to go beyond that limit table 4 results of assembling simulated reads of e coli criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 97 887 97 883 97 783 97 834 97 844 97 860 97 864 97 863 97 938 97 833 97 876 97 837 97 786 97 845 97 938 97 979 97 960 97 957 97 964 97 808 97 901 98 310 98 307 98 306 98 306 98 307 98 054 98 323 nga 50 no cleaning readsclean racer sga musket coral karect 29 152 54 946 31 662 42 717 53 643 52 578 54 943 107 662 107 638 107 638 107 637 107 638 105 532 107 638 46 442 82 580 82 580 82 580 82 580 65 530 82 580 133 026 133 026 133 026 133 026 133 026 123 773 133 026 for e coli bacterial reads table 4 it can be seen that cleaning reads before assembly doesn t yield obvious benefits for all assembling programs for velvet and spades programs the results are unchanged while for sga and soapdenovo nga 50 increases about the same no matter which cleaning program was used table 5 results of assembling simulated reads of human chr 14 with 0 962 of errors criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 90 328 89 322 83 783 86 800 88 814 87 796 88 912 84 643 88 058 84 449 85 085 84 585 85 909 86 101 95 813 96 086 95 323 95 798 95 640 92 369 95 460 96 726 96 833 96 605 96 733 96 750 93 824 96 747 nga 50 no cleaning readsclean racer sga musket coral karect 4 068 4 057 2 698 3 284 3 931 3 823 3 987 4 808 10 553 4 364 5 449 4 731 7 549 6 671 10 438 13 069 10 027 11 821 11 004 6 587 10 061 19 415 20 418 17 299 18 577 19 654 9 174 18 385 table 6 results of assembling simulated reads of human chr 14 with 3 of errors criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 0 758 89 323 78 899 85 953 86 939 87 702 88 763 5 331 87 686 82 068 82 574 81 980 85 547 84 160 9 015 95 846 93 959 94 434 93 843 92 706 94 902 93 909 96 745 94 850 95 164 95 025 94 244 95 832 nga 50 no cleaning readsclean racer sga musket coral karect 4 058 2 050 3 104 3 898 3 770 3 940 10 203 3 022 3 168 3 075 7 235 3 922 11 693 6 502 7 162 6 559 6 736 8 690 7 418 18 812 8 987 9 468 9 504 10 148 11 911 on human data table 5 readsclean performs the best with all assembly programs except sga which has by far the lowest value of nga 50 of all four assembling programs these data clearly show assembly improvement due to error correction as the number of errors increase table 6 all assembly programs except spades perform very poorly on uncleaned reads and all programs show significant improvement on cleaned reads in this test readsclean outperformed the other cleaning programs with all assemblers in both sequence coverage and nga 50 tests on a set of real data generated by sequencing machine for real data the actual percentage of errors is not known for that reason the quality of error correction programs was compared only by the results of de novo assembly we used the same assembly programs and same criteria as for simulated data the results of tests using actual reads from gage project are shown in tables 7 9 table 7 results of de novo assembly of reads of staphylococcus aureus genome criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 81 540 97 190 93 537 94 402 96 308 96 099 97 314 96 311 97 001 95 940 96 672 96 567 96 696 96 989 84 741 97 767 93 820 95 571 97 283 96 322 97 760 98 489 98 443 98 034 98 335 98 381 98 029 98 455 nga 50 no cleaning readsclean racer sga musket coral karect 1 263 13 022 3 553 4 005 7 481 7 125 20 250 14 984 36 667 16 835 23 156 23 155 29 840 40 816 1 369 8 977 2 901 3 976 7 050 5 931 13 223 46 907 55 044 40 860 53 695 55 906 46 527 69 745 table 8 results of de novo assembly of reads of rhodobacter sphaeroides genome criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 47 196 86 077 84 379 87 914 87 896 83 870 94 183 93 556 93 745 87 299 93 165 93 887 92 958 95 777 65 762 88 451 86 298 90 304 88 431 84 647 94 333 98 514 98 528 97 922 98 625 98 167 98 075 98 555 nga 50 no cleaning readsclean racer sga musket coral karect 1 977 1 676 2 202 1 996 1 679 3 855 5 994 7 424 2 010 6 834 3 462 6 728 10 558 724 1 700 1 625 2 040 1 831 1 430 3 037 15 344 15 284 9 054 17 542 12 756 15 099 21 044 table 9 results of de novo assembly of reads of human chromosome 14 criterion cleaning program sga velvet soapdenovo spades percent of genome coverage no cleaning readsclean racer sga musket coral karect 70 328 71418 65 873 69 679 70 061 69 739 70 992 65 937 67 956 65 372 66 637 65 365 66 723 67 527 75 443 76 318 74 768 76 079 75 741 73 467 75 598 78 512 79 154 77 758 78 889 78 727 76 224 79 020 nga 50 no cleaning readsclean racer sga musket coral karect 2 028 2 283 1 434 1 971 2 064 2 082 2 271 1 844 2 247 1 633 1 911 1 616 1 984 2 114 2 604 3 204 2 490 3 118 2 892 2 545 2 980 5 401 10 384 5 211 9 067 8 393 5 293 10 048 tables 7 9 show that readsclean outperforms the other tools on data from human chromosome 14 while for smaller bacterial genomes karect and redsclean lead in assembly quality conclusion the modern sequencing technologies always generate sequencing reads with some percentage of errors so subsequent error correction is becoming a routine stage of handling ngs data our tests demonstrate that reads cleaning is less important for assembling short bacterial genomes with good coverage however for eukaryotic sequencing data especially with high level of errors it significantly improves the results of genome assembling readsclean outperforms its peers on such datasets and can be recommended for projects involving de novo assembling eukaryotic genomes and it can be used for error correction in polyploid genomes where its is very essential to differentiate snps from sequencing errors also our clustering approach is very useful for error correction in genomes containing multiple groups of repeated sequences when the correction must be done within the corresponding repeat cluster readsclean algorithm is easy to run in parallel mode as each read is corrected independently from others and a version exists that is optimized for very fast performance on an amazon web services aws cluster in the future it is possible to adopt the program for cleaning reads generated by platforms other than illumina which will require additional tests and adjustments of settings the program is freely available to download for academic users at the softberry web server http www softberry com berry phtml topic fdp htm no menu on references alic a s et al 2016 objective review of de novo stand alone error correction methods for ngs data wires comput mol sci 6 111 146 allam a et al 2015 karect accurate correction of substitution insertion and deletion errors for next generation sequencing data bioinformatics 31 3421 8 bankevich a et al 2012 spades a new genome assembly algorithm and its applications to single cell sequencing journal of computational biology 19 455 477 greenfield p et al 2014 blue correcting sequencing errors using consensus and context bioinformatics 30 2723 32 gurevich a et al 2013 quast quality assessment tool for genome assemblies bioinformatics 29 1072 1075 heo y et al 2014 bless bloom filter based error correction solution for high throughput sequencing reads bioinformatics 30 1354 62 ilie l and molnar m 2013 racer rapid and accurate correction of errors in reads bioinformatics 29 2490 3 ilie l et al 2011 hitec accurate error correction in high throughput sequencing data bioinformatics 27 295 302 illumina 2015 hiseq 2500 sequencing system available at http www illumina com documents products datasheets datasheet hiseq 2500 pdf liu y et al 2013 musket a multistage k mer spectrum based error corrector for illumina sequence data bioinformatics 29 308 15 luo r et al 2012 soapdenovo 2 an empirically improved memory efficient short read de novo assembler gigascience 1 18 salmela l and schr der j 2011 correcting errors in short reads by multiple alignments bioinformatics 27 1455 61 salzberg s l et al 2012 gage a critical evaluation of genome assemblies and assembly algorithms genome res 22 557 67 schr der j et al 2009 shrec a short read error correction method bioinformatics 25 2157 63 simpson j t and durbin r 2012 efficient de novo assembly of large genomes using compressed data structures genome res 22 549 56 zerbino d r and birney e 2008 velvet algorithms for de novo short read assembly using de bruijn graphs genome res 18 821 9 zimin a v et al 2013 the masurca genome assembler bioinformatics 29 2669 2677 supplementary information parameters for running error correction programs to test their accuracy for human chr 14 reads from gage project pe reads located in two files frag 1 fastq frag 2 fastq distance between paired reads 155 bp approximate size of chromosome 100000000 bp readsclean sb pl cfg config cfg dir mydir clean j 4 config cfg pe pe 1 cleaning src file frag 1 fastq frag 2 fastq cleaning addition clean single out dst format fasta dst count 1 racer racer frag 1 fastq output 1 fastq 100000000 racer frag 2 fastq output 2 fastq 100000000 sga sga preprocess p 1 frag 1 fa frag 2 fa frag pp fa sga index t 20 frag pp fa sga correct k 31 t 20 frag pp fa o output fa musket musket frag 1 fastq o output 1 fastq inorder musket frag 2 fastq o output 2 fastq inorder coral coral fq frag 1 fastq o output 1 fastq illumina coral fq frag 2 fastq o output 2 fastq illumina karect karect correct inputfile frag 1 fastq inputfile frag 2 fastq matchtype hamming celltype diploid parameters for running sequence assembling programs pe reads located in two files output 1 fastq output 2 fastq distance between paired reads 155 bp sga sf gen 7 gen 5 snp cleaner sga bin sga preprocess p 1 output 1 fastq outout 2 fastq frag pp fa sf gen 7 gen 5 snp cleaner sga bin sga index t 31 frag pp fa sf gen 7 gen 5 snp cleaner sga bin sga filter frag pp fa sf gen 7 gen 5 snp cleaner sga bin sga overlap t 20 m 45 frag pp filter pass fa sf gen 7 gen 5 snp cleaner sga bin sga assemble frag pp filter pass asqg gz velvet velveth 31 fastq shortpaired separate output 1 fastq output 2 fastq velvetg exp cov auto ins length 155 ins length sd 15 soapdenovo soapdenovo 63 mer all s soap config k 63 r o soap p 30 soap config maximal read length max rd len 101 lib average insert size avg ins 155 if sequence needs to be reversed reverse seq 0 in which part s the reads are used asm flags 1 use only first 50 bps of each read rd len cutoff 101 in which order the reads are used while scaffolding rank 1 cutoff of pair number for a reliable connection default 3 pair num cutoff 3 minimum aligned length to contigs for a reliable read location default 32 map len 32 fastq file for read 1 q 1 output 1 fastq fastq file for read 2 always follows fastq file for read 1 q 2 output 2 fastq spades spades py 1 output 1 fastq 2 output 2 fastq only assembler o spades