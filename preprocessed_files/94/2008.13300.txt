ar x iv 2 00 8 13 30 0 v 2 cs n i 5 s ep 2 02 0 sopi design and analysis for ldn michael luby icsi and bitripple inc abstract liquid data networking ldn introduced in 1 is an icn architecture that is designed to enable the benefits of erasure code enabled object delivery a primary contribution of 1 is the introduction of sopis which enables clients to concurrently download encoded data for the same object from multiple edge nodes optimizes caching efficiency and enables seamless mobility this paper provides an enhanced design and analysis of sopis i introduction the paper 1 inspired by fountain codes 2 3 4 5 introduces liquid data networking ldn an icn ar chitecture that is designed to enable the benefits of erasure code enabled object delivery a primary contribution of 1 is the introduction of stream object permutation identifiers sopis which provides a simple and efficient download coordination mechanism clients can concurrently download encoded data for the same object from multiple edge nodes caching efficiency is optimized and seamless mobility is enabled this paper provides an enhanced design and analysis of sopis and inherits the terminology and notation of 1 ii sopi and stream object sopis and stream objects are fundamental to the design of ldn they enable a diversity of encoded data to be available for download within the network for each object while at the same time ensuring that different clients request the same encoded data for an object from the same neighboring encoding node the sopi design allows the client decision of which encoded data to request for an object to be simple robust and efficient an object is partitioned into k source symbols where k is the object size divided by the symbol size and the symbol size is typically chosen to fit into a packet payload stream objects can be described in terms of an erasure code with optimal recovery properties and with the property that n encoded data symbols can be generated from any object where n is a large prime number and in particular n kmax where kmax is the maximium number of source symbols in any object a stream object for an object consists of all of the possible encoded data that can be generated for the object in a specified order the essential idea is that different stream objects specify completely different orderings of the available encoded data for an object and thus a client can simply request prefixes of different stream objects for an object to receive non overlapping encoded data a stream object permutation identifier sopi specifies the ordering of encoded data symbols for a stream object a sopi the research described in this paper is supported by nsf eager 1936572 p identifies a permutation p of the n available symbol ids thus a stream object identifier d p is the combination of the identifier d of the object from which it is generated and a sopi p we consider sopis of the form p a b where a 0 1 2 n 1 b 1 2 3 n 1 then p a b defines the permutation of symbol ids p a a b a 2 b a n 1 b where each term is taken mod n i e p i a i b mod n for any position i 0 n 1 a raptorq sopi implementation for the implementation of the raptorq code 3 described at 5 there are 231 possible symbols of encoded data for an object since 231 1 is a prime number a mersenne prime n 231 1 can be used for the implementation 5 of the raptorq code since n is one less than a power of two it is straightforward to compute c a i b mod n e g compute d i b let d 0 be the 31 least significant bits of d let d 1 be the next 31 bits of d let c a d 0 d 1 if c n then c c n if c n then c c n iii random sopi sets we analyze the properties of collections of sopis where each sopi in the collection is randomly and independently chosen proposition 3 1 for any pair of positions i 0 0 1 n 1 i 1 0 1 n 1 i 0 and for any pair of symbol ids j 0 0 1 n 1 j 1 0 1 n 1 j 0 there is a unique p a b such that p i 0 j 0 and p i 1 j 1 proposition 3 1 implies that the pair of symbol ids in any pair of positions within the permutation are random with respect to a random sopi p a b suppose an object d is composed of a single source block with k source symbols a client will download encoded data http arxiv org abs 2008 13300 v 2 from prefixes of multiple stream objects of an object d in order to recover the object we would like to show that a client doesn t receive many duplicate symbols when downloading from multiple stream objects with randomly chosen sopis suppose the client downloads from some number s of different stream objects with corresponding randomly chosen sopis p 0 p 1 ps 1 suppose the client receives m 0 symbols from the stream object p 0 d m 1 symbols from the stream object p 1 d etc where s 1 i 0 mi m the expected number of distinct symbol ids among m is at least m m 1 2 2 n and thus if k 2 2 n then m k 1 k 2 n k 1 symbols on average are enough to receive k symbols with at least k distinct symbol ids theorem 3 2 below provides bounds on the probability that m received symbols have at least k distinct symbol ids theorem 3 2 consider an object d composed of a single source block with k source symbols suppose at least m k 1 symbols have been received in total from s 1 stream objects p 0 d p 1 d ps 1 d where 0 and m 2 2 n then pr d not recoverable from the m symbols 1 2 n 1 with respect to the random variables p 0 a 0 b 0 p 1 a 1 b 1 ps 1 as 1 bs 1 proof let y be the random variable that is the number of unique symbol ids among m received symbols for an object d with respect to the random variables p 0 a 0 b 0 p 1 a 1 b 1 ps 1 as 1 bs 1 the left hand side of inequality 1 is equivalent to pr y k pr y 1 m 2 and thus we need to prove that pr y 1 m 1 2 n 3 each of the m received symbols has a symbol position within the stream object from which it is received and a symbol id determined by the stream object sopi and the symbol position within the stream object we associate a unique index within 0 1 m 1 with each of the m stream object symbol position pairs of received symbols for i 0 1 m 1 j 0 1 m 1 i we let xi j 1 if the symbol position within the stream object indexed by i is mapped to the same symbol id as the symbol position within the stream object indexed by j and xi j 0 if the symbol position within the stream object indexed by i is mapped to a different symbol id than the symbol position within the stream object indexed by j thus xi j 1 if and only if the symbol ids mapped to by i and j are duplicates then pr y 1 m pr m y m pr i j i xi j m 4 pr i j i xi j 2 2 m 2 e i j i xi j 2 2 m 2 5 where inequality 4 follows since m y is the number of duplicate symbol ids and if the symbol ids mapped to by i and j are the same then xi j 1 and inequality 5 follows from markov s inequality expanding out terms e i j i xi j 2 e i j i x 2 i j 6 e i j i i j i i j 6 i j xi j xi j 7 if i and j index different symbol positions within the same stream object then e x 2 i j 0 since the sopi for the stream object defines a permutation of the symbol ids and thus cannot map i and j to the same symbol id if i and j index symbol positions within two different stream objects then e x 2 i j 1 n since the sopis for the two different stream objects are chosen independently thus e i j i x 2 i j m 2 n m 2 2 n 8 similarly if i and j index different symbol positions within the same stream object or i and j index different symbol posi tions within the same stream object then e xi j xi j 0 if i and i index different symbol positions within one stream object and j and j index different symbols positions within a second stream object then e xi j xi j 1 n 1 n by proposition 3 1 if i and i index different symbol positions within one stream object and j and j index the same symbol position within a second stream object then e xi j xi j 0 since i and i cannot map to the same symbol id if i and i index different symbol positions within one stream object and j indexes a symbol position in a second stream object and j indexes a position within a third stream object then e xi j xi j 1 n 2 since if j and j map to the same symbol id then i and i cannot both map to that symbol id and if j and j map to different symbol ids with probability n 1 n then i and j map to the same symbol id and i and j map to the same symbol id with probability 1 n 1 n from proposition 3 1 if i j i and j index symbol positions in four different stream objects then e xi j xi j 1 n 2 since each of the four sopis are chosen randomly and independently of one another all other cases are variants of these cases thus e i j i i j i i j 6 i j xi j xi j m 2 2 n 1 n m 4 4 n 2 9 from inequalities 8 and 9 it follows that e i j i xi j 2 m 2 2 n 1 m 2 2 n 10 m 2 n 11 where inequality 11 follows since m 2 2 n combining inequality 11 with inequality 5 proves inequality 3 a random sopi set examples for the raptorq code specified in 3 the maximum supported number of source symbols per source block is kmax 56 403 and n 2 31 1 is a good choice as described in section ii a with m 65 535 the condition m 2 2 n is satisfied and kmax 0 86 m 1 m for 0 14 thus theorem 3 2 holds for raptorq for all supported source block sizes and for any 0 14 on average at most a 0 00002 fraction of the symbol ids of received encoded data symbols from prefixes of stream objects will be duplicates when the total number of received symbols is up to m however stronger bounds on the probability of the number of duplicates being above a certain bound are of importance for example setting 0 01 theorem 3 2 shows that an object d composed of a single source block of k source symbols can be recovered with probability at least 1 1 2 n 0 999995 from m k 0 99 1 01 k received symbols in total from different stream objects as another example setting 0 1 theorem 3 2 shows that an object d composed of a single source block of k source symbols can be recovered with probability at least 1 1 2 n 0 99999995 from m k 0 9 1 11 k received symbols in total from different stream objects the analysis of theorem 3 2 is not tight and thus these bounds are conservative iv designed sopi sets although the analysis in section iii shows there is little chance of there being a significant fraction of duplicates among received symbols from multiple stream objects there is still a chance that there is a significant fraction of duplicates as an extreme example if p 0 and p 1 are identical then the overlap between prefixes of length k 2 is k 2 i e all k 2 symbols are duplicates as a somewhat less extreme example if p 0 0 1 and p 1 a 1 where a is randomly chosen then for prefixes of length k 2 there is a 1 k n chance there is no overlap between the prefixes but with the remaining probability k n there are on average k 4 duplicates in this section we provide a deterministic design of a large set p of sopis for which we can provide guaranteed upper bounds on the number of symbol id duplicates there are in prefixes of permutations defined by sopis from p the design has two parts design a set b 1 n 1 for each b b design a set ab 0 n 1 then the designed set of sopis is the set p p a b b b a ab a interactions between b values the design of set b is based on interactions between different b values the following is at the heart of this analysis definition 4 1 let b 0 b 1 1 n such that b 0 6 b 1 for any pair of integers d 0 d 1 we say d 0 d 1 matches with respect to b 0 b 1 if d 0 b 0 mod n d 1 b 1 mod n the importance of definition 4 1 is that for any a 0 a 1 0 n if the symbol id at position p 0 in the permutation defined by p 0 a 0 b 0 is equal to the symbol id at position p 1 in the permutation defined by p 1 a 1 b 1 and d 0 d 1 matches with respect to b 0 b 1 then the symbol id at position p 0 d 0 mod n with respect to p 0 is equal to the symbol id at position p 1 d 1 mod n with respect to p 1 it is easy to verify that if d 0 d 1 matches with respect to b 0 b 1 and d 0 d 1 matches with respect to b 0 b 1 then d 0 d 1 d 0 d 1 d 0 d 0 d 1 d 1 matches with respect to b 0 b 1 for example if d 0 d 1 matches with respect to b 0 b 1 then for any integer i i d 0 d 1 i d 0 i d 1 matches with respect to b 0 b 1 let m be an upper bound on the aggregate number of symbols downloaded by a client from prefixes of stream objects for an object we impose the condition that m 2 n 2 12 definition 4 2 the set d is defined as d m 1 1 1 m 1 lemma 4 3 for any b 0 1 n and b 1 1 n one of the following two possibilities holds 1 for all d 0 d d 1 d d 0 d 1 does not match with respect to b 0 b 1 the distance between b 0 and b 1 is defined to be 2 m 2 there is a d 0 d d 1 d such that d 0 d 1 matches with respect to b 0 b 1 and for any d 0 d and d 1 d such that d 0 d 1 matches with respect to b 0 b 1 d 0 d 1 is an integer multiple of d 0 d 1 the distance between b 0 and b 1 is defined to be d 0 d 1 proof if 1 holds the proof is complete we need to show that if 1 doesn t hold then 2 holds if 1 doesn t hold there is d 0 d and d 1 d such that d 0 d 1 matches with respect to b 0 b 1 and d 0 d 1 is a minimal pair i e there is no d 0 d and d 1 d such that d 0 d 1 matches with respect to b 0 b 1 and d 0 d 1 c d 0 d 1 where 0 c 1 consider any d 0 d 1 with d 0 d d 1 d such that d 0 d 1 matches with respect to b 0 b 1 we want to show that d 0 d 1 is an integer multiple of d 0 d 1 note that d 0 d 0 d 0 d 1 matches with respect to b 0 b 1 and also d 0 d 0 d 1 d 0 matches with respect to b 0 b 1 for any a 0 a 1 0 n consider a pair of positions p 0 p 1 where the symbol id at position p 0 of the permutation defined by p 0 a 0 b 0 is the same as the symbol id at position p 1 of the permutation defined by p 1 a 1 b 1 then the symbol id at position p 0 d 0 d 0 mod n of p 0 is the same as the symbol id at position p 1 d 0 d 1 mod n of p 1 and also the same as the symbol id at position p 1 d 1 d 0 mod n of p 1 which implies that p 1 d 0 d 1 p 1 d 1 d 0 mod n 13 since n 2 m 2 d 0 d 1 m 2 n 2 and n 2 m 2 d 1 d 0 m 2 n 2 it follows that equation 13 holds if and only if d 0 d 1 d 1 d 0 thus for some c 6 0 d 0 d 1 c d 0 d 1 since d 0 d 1 is a minimal pair c 1 then d 0 d 1 d 0 d 1 c d 0 d 1 c c d 0 d 1 matches with respect to b 0 b 1 and d 0 d and d 1 d since 0 c c 1 and d 0 d 1 is a minimal pair it follows that c c 0 and thus 2 holds because c is an integer lemma 4 4 suppose for b 0 b 1 1 n the distance between b 0 and b 1 is d then for any a 0 a 1 0 n the number of distinct symbol ids in the prefixes of the permutations defined by sopis p 0 a 0 b 0 p 1 a 1 b 1 is at least m m 2 d 1 where m m is the total length of the pair of prefixes proof if m 1 or more generally one of the prefixes is of length zero then the number of distinct symbol ids is m otherwise neither prefix is of length zero if there are no symbol ids in common between the two prefixes then the number of distinct symbol ids is m suppose there are symbol ids in common between the two prefixes then there is a symbol id at some position p 0 with respect to p 0 that is the same as a symbol id at some position p 1 with respect to p 1 if 1 of lemma 4 3 holds i e there is no d 0 d d 1 d such that d 0 d 1 matches with respect to b 0 b 1 then the distance between b 0 and b 1 is d 2 m and p 0 p 1 is the only pair of positions where the symbol ids are the same among the two prefixes and thus there are m 1 m m 2 2 m 1 distinct symbol ids if 2 of lemma 4 3 holds i e there is a d 0 d d 1 d such that d 0 d 1 matches with respect to b 0 b 1 and all other pairs d 0 d 1 that match with respect to b 0 b 1 where d 0 d d 1 d are integer multiples of d 0 d 1 without loss of generality d 0 0 and d 1 0 the case where d 0 0 and d 1 0 is similar then the distance between b 0 and b 1 is d d 0 d 1 the following maximizes the number of symbol ids that are duplicates between p 0 and p 1 the symbol id in position 0 of p 0 is the same as the symbol id in position 0 of p 1 let i m 2 d then set m 0 and m 1 such that m 0 i d 0 1 and m 1 i d 1 1 the remaining r m i d 2 length can be assigned to m 0 and m 1 arbitrarily to satisfy m 0 m 1 m it can be verified that the number of pairs of symbol ids that are the same between the two prefixes is maximized and that this number of pairs is i 1 m 2 d 1 corollary 4 5 suppose for b 0 b 1 bs 1 1 n the distance between bi and bj is at least d for all i j 0 s 1 where i 6 j then for any a 0 a 1 as 1 0 n the number of distinct symbol ids in the prefixes of the permutations defined by sopis p 0 a 0 b 0 p 1 a 1 b 1 ps 1 as 1 bs 1 is at least m s 1 m s d s 2 where m m is the total length of the s prefixes proof let m 0 m 1 ms 1 be the respective lengths of the s prefixes where m s 1 i 0 mi from lemma 4 4 for each i 0 s 1 j 0 i 1 the number of symbol ids that are the same between the permutation defined by the prefix of pi and pj is at most mi 1 mj 1 d 1 thus the number of symbol ids that are the same between all pairs of the prefixes is at most s 1 i 0 s 1 mi 1 d s 1 s 2 14 s 1 m s d s 2 15 lemma 4 4 and corollary 4 5 provide worst case lower bounds on the total number of distinct symbol ids in prefixes the actual number of distinct symbol ids in practice are much closer to the total size m of the prefixes than to the worst case lower bounds b constructing a sopi set the following algorithm constructs a set b such that for b 0 b b 1 b b 0 the distance between b 0 and b 1 is at least d initialize b b 1 n 1 repeat until b choose any b b delete b from b and add b to b for all i d j d such that i j d delete b i b j 1 mod n from b each time an element is added to b after accounting for some symmetries such as i b j 1 mod n i b j 1 mod n the number of elements deleted from b for each element added to b is at most d 2 d 3 1 d 2 thus b n 1 d 2 when the algorithm completes the following algorithm constructs a set ab for b b such that for a 0 ab a 1 ab a 0 the symbol ids of prefixes of length up to m of the permutations defined by sopi p 0 a 0 b and p 1 a 1 b are all distinct as follows initialize ab choose a randomly and add a to ab for i 1 n m 1 do a a m b mod n add a to ab thus ab n m 1 when the algorithm completes overall the set of sopis p p a b b b a ab is constructed a sopi can be assigned to an encoding node by choosing any p a b p that hasn t been assigned so far overall p n 2 d 2 m sopis can be assigned c designed sopi set examples as an example distance of at least 101 between pairs of b values might be sufficient lemma 4 4 guarantees that there are at least k distinct symbol ids among the prefixes of any pair of sopis with m 1 01 k 1 symbol ids in total the value of m 30 000 might be sufficient for practical use cases where m 2 n 2 when n 231 1 in this case the number of possible sopis available is over 15 billion as another example distance of at least 1 000 between pairs of b values might be desirable corollary 4 5 guarantees that downloading from prefixes of up to 10 stream objects with different sopis where the total number of downloaded symbols is at least 10 000 and at most 30 000 will have less than 1 5 duplication in symbol ids in this case the number of possible sopis available is over 150 million v sopi distribution design it is not necessary that each encoding node is assigned a unique sopi to enjoy the sopi design properties it is sufficient that a client avoids downloading encoded data for an object from two encoding nodes with the same assigned sopi which the client can easily avoid no matter how the sopis are assigned to encoding nodes for example if a client is supplied with the same sopi for two edge encoding nodes reachable over different interfaces the client can simply send requests for encoded data to only one of the two interfaces and thus avoid receiving duplicate encoded data of course the benefits of the sopi design are reduced in this case since the client cannot effectively download encoded data from both edge encoding nodes for the same object thus one would like to distribute sopis to encoding nodes in such a way that it is unlikely that a client will receive the same sopi from two different edge encoding nodes one can conceptually create a graph of all encoding nodes in the internet where there is an edge connecting two encoding nodes if it is possible that a client may download prefixes of stream objects from both encoding nodes for the same object then one can think of each sopi p p as being a different color assigning colors to the graph in such a way that no edge has the same color at both endpoints provides a valid assignment of sopis to encoding nodes it seems likely that such a graph can be colored using a small number of colors e g less than 100 and perhaps much less than 100 if some edges in the graph as allowed to have the same color thus the number of sopis needed overall is likely to be rather small this can ameliorate one of the possible concerns with the sopi design which is that some information about which clients are requesting which objects might be revealed by the requests for encoded data containing sopis percolating through the network the amount of information revealed is minimized if the number of sopis distributed is small vi large objects if an object is not too large then it can be treated as a single source block i e fountain encoding and fountain decoding can be applied to the entire object however it becomes inefficient to apply fountain encoding and fountain decoding to objects that are larger since typically the object needs to fit into working memory the required working memory is typically linear in the source block size i e the working memory to recover a block with k source symbols is typically proportional to the symbol size times k thus for longer objects it is useful to have an algorithm that automatically partitions the object into multiple source blocks such an algorithm is specified in 3 in section 4 3 for ldn the following is a suitable simplification of that algorithm let the desired symbol size be t and let ws be the maximum source block size for which fountain encoding and fountain decoding is efficient where ws t 56 403 an object d of size f can be automatically partitioned into source blocks as follows kt f t no of source symbols in d kmax ws t max no symbols per source block z kt kmax no of source blocks to split d into kl ks zl zs partition kt z the output of partition kt z is kl ks zl zs where kl kt z ks kt z zl kt ks z and zs z zl the function partition kt z partitions a block of kt source symbols into z approximately equal number of source symbols blocks more specifically it partitions kt into zl blocks each with kl source symbols and zs blocks each with ks source symbols given the symbol size t the maximum source block size ws and the object size f an encoding node or client can determine the parameters kl ks zl zs as described above where z zl zs is the total number of source blocks if z 1 then the object is considered as a single source block with kl k f t source symbols if z 1 then object d is partitioned into z source blocks as follows the initial portion of object d of size zl kl t is partitioned into zl source blocks each consisting of kl source symbols of size t the remaining portion of object d of size f zl kl t is partitioned into zs source blocks each consisting of ks source symbols of size t a large object extension of sopi we extend the definitions of sopi and stream object to be applicable to large objects i e objects that are partitioned into z 1 source blocks the source block structure for a large object d of size f is determined as described in section vi based on f symbol size t and a maximum source block size ws a sopi for the large object d is of the form p a b c d where a 0 1 n 1 b 1 2 n 1 c 0 1 n 1 and d 1 2 n 1 a and b are used similarly to subsection ii to identify a symbol generated from a source block and c and d are used to identify one of the z source blocks for conve nience the ranges of c and d are chosen to match the ranges of a and b and thus large objects with up to n 1 source blocks can be supported for any i 0 1 z n 1 let r i z j a r b mod n j i c r d mod z then the symbol at position i of the stream object identified by sopi p for object d is the symbol identified by j from the source block identified by j each sopi p defines a stream object p d which is a permutation defined by p of the z n possible symbols that can be generated for the z source blocks of the object d the permutation p has the property that each set of z consecutive symbols of the stream object starting at a position that is a multiple of z all have the same symbol id but are from different source blocks i e the z consecutive symbols are from a cyclic shift of the z source blocks the values of c and d should be chosen randomly chosen this ensures that the source block sequence within each set of z consecutive symbols of the stream object is a random cyclic shift and that different pairs of cyclic shifts are random this ensures that packet losses on average with respect to randomly chosen c and d affect each source block of a large object equally this is true even if packet loss patterns depend on the position of the symbol within the stream object carried in a packet as long as the packet loss does not depend on the values of c and d b raptorq large object for the raptorq code specified in 3 the maximum number of supported source symbols is 56 403 and thus the maximum supported source block size ws should satisfy ws t 56 403 where t is the symbol size with t 1400 bytes i e around the typical ipv 4 packet payload size the maximum object size supported without partitioning the object into more than one source block is around 80 mbytes for raptorq 3 n 231 1 is a good choice and thus up to 231 1 source blocks can be supported with the design described in section vi a with t set to the maximum supported symbol size of 216 65 536 bytes the maximum size object supported is around 8 1018 bytes or around 8 exabytes references 1 j byers m luby liquid data networking 7 th acm conference on information centric networking icn 20 vir tual event canada acm new york ny usa 7 pages https doi org 10 1145 3405656 3418710 2 j byers m luby m mitzenmacher a rege a digital fountain approach to reliable distribution of bulk data proc of acm sigcomm comput commun rev vol 23 no 4 pp 56 67 1998 3 m luby a shokrollahi m watson t stockhammer l minder ietf rfc 6330 raptorq forward error correction scheme for object delivery internet engineering task force august 2011 4 a shokrollahi m luby raptor codes foundations and trends in communications and information theory now publishers vol 6 no 3 4 pp 213 322 2011 5 l minder m luby p aggarwal codornices project website describing optimized implementation of raptorq https www codornices info 2020 i introduction ii sopi and stream object ii a raptorq sopi implementation iii random sopi sets iii a random sopi set examples iv designed sopi sets iv a interactions between b values iv b constructing a sopi set iv c designed sopi set examples v sopi distribution design vi large objects vi a large object extension of sopi vi b raptorq large object references