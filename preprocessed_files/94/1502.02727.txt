ar x iv 1 50 2 02 72 7 v 3 cs i t 1 9 n ov 2 01 5 1 new multiple insertion deletion correcting codes for non binary alphabets tuan a le and hieu d nguyen abstract we generalize helberg s number theoretic construction of multiple insertion deletion correcting binary codes to non binary alphabets and describe a linear decoding algorithm for correcting multiple deletions i introduction helberg codes 4 are binary codes capable of correcting multiple insertion deletion errors these number theoretic codes generalize levenshtein codes first constructed by varshamov and tenengo lts 13 to correct a single asymmetrical error and later proved by levenshtein 7 to be capable of also correcting a single insertion or deletion error levenshtein s proof included an elegant linear decoding algorithm to correct a single deletion levenshtein codes are asymptotically optimal however helberg codes correcting more than one insertion or deletion have a low rate 10 other special binary codes capable of correcting insertions and deletions include run length limited codes by palunc ic abdel ghaffar ferreira and w a clarke 10 repetition codes by landjev and haralambiev 8 and repetition error correcting codes by dolecek and anantharam 3 there are of course codes that can correct insertion deletion errors with high probability over binary symmetric channels such as concatenated codes by schulman and zuckerman 11 and watermark codes by davey and mackay 2 these codes differ from helberg and other aforementioned codes which guarantee correction up to a fixed maximum of insertions and or deletions or indels for short we refer the reader to 1 and 10 for an overview of insertion deletion correcting codes and their applications a non binary generalization of the levenshtein code is the tenengol ts code 12 which uses a modular relation to determine the value of the inserted or deleted non binary symbol and an associated levenshtein code to determine the position of that symbol tenengolts also gave a systematic form of his code that appends the three bit string 011 to each codeword to serve as check bits for detecting either an insertion or deletion and as a separator between codewords a generalization of the tenengol ts code to one capable of correcting multiple indels was constructed by paluncic t g swart j h weber h c ferreira and w a clarke 9 as with the tenengol ts code their code uses a set of modular relations to determine the values of the deleted symbols and an associated binary multiple insertion deletion correcting code to determine the positions of the deleted symbols however this information does not uniquely specify which values should be inserted at these positions thus their construction involves a purging process that requires removing unwanted codewords that yield the same deleted codeword an upper bound was derived for the number of such codewords that can exist but no efficient algorithm was given to purge these unwanted codewords a lower bound for the cardinality of these codes was established proving that they are asymptotically optimal but assumes a conjecture regarding the cardinality of the associated binary code in this paper we extend helberg s construction of his codes 4 5 to non binary alphabets moreover we present a linear decoding algorithm to correct codewords that suffer only deletions our proof that these q ary codes are capable of correcting multiple insertion deletion errors follows the one given by abdel ghaffar palunc ic ferreira and clarke 1 for helberg codes which we adapt for non binary alphabets the proof relies on an argument by contradiction suppose two codewords with the same residue produce the same deleted codeword then the difference in their moments must be strictly between 0 and the modulus which gives a contradiction since the two codewords are congruent t le and h nguyen are with the department of mathematics rowan university glassboro nj 08012 usa let 5 students rowan edu nguyen rowan edu http arxiv org abs 1502 02727 v 3 to precisely describe our results let a 0 1 q 1 be a q ary alphabet and x x 1 xn a n be a codeword of length n we shall refer to xi as the i th symbol of x fix d to be a positive integer and set p q 1 generalizing 5 we define the sequence of weights w q d w 1 q d w 2 q d as follows first initialize wi q d 0 if i 0 then for i 1 define wi q d recursively by wi q d 1 p d j 1 wi j q d when it is clear we shall write wi for short instead of wi q d next we define the truncated codeword x k x 1 xk to be one consisting of the first k symbols of x and its moment by mk x m x k we shall also write m xi wixi to refer to the moment of the symbol xi our new q ary codes capable of correcting multiple insertion deletion errors are defined as follows definition 1 let m and r be fixed integers satisfying m wn 1 and 0 r m we define the code cn q d m r to be the set of codewords of length n whose moments have residue r modulo m i e cn cn q d m r x a n m x r mod m to simplify the notation we shall sometimes write cn instead of cn q d m r in the case of a binary alphabet where q 2 the codes cn 2 d m r are referred to helberg codes 5 given two codewords x and y of length n we shall say that x and y are congruent and write x y to denote m x m y mod m in that case x y cn q d m r for some residue r where r m x m y mod m moreover if we define x y m x m y then x y is equivalent to x y 0 mod m define s n 1 n let d be a non empty subset of s n with d d set n n d and define s s n d i 1 in with i 1 i 2 in moreover define x d xi 1 xin to be the codeword obtained by deleting the elements of x indexed by d we shall refer to x d as a deleted codeword of x we also define the index of x d to be difference in moments between the original codeword and its deleted codeword i i x d m x m x d we prove in section ii that the code cn q d m r is capable of correcting up to d deletion errors in particular let x y cn q d m r be two distinct codewords and suppose there exists subsets d and e of s n such that d e d and x d y e we show that 0 x y m which is a contradiction since x y thus no such subsets exist hence cn q d m r is a d deletion correcting code by a result of levenshtein 7 cn q d m r is also capable of correcting a total of d indels in section iii we present a linear search algorithm to decode codewords in cn that suffer only deletions suppose a codeword x is transmitted but is corrupted so that the received codeword denoted by x consists of deletion errors the goal of our algorithm to find the correct positions to re insert into x the symbols that were deleted so that the index i reduces to zero in particular we start with the assumption that our deleted symbols should be inserted at the right end of x if these symbols are not in their correct positions then we shift them to the left as far as possible and update the index i by subtracting the change in the weight of each moving symbol from the current value of i the algorithm terminates when i 0 for the correction of one deletion error the algorithm essentially performs an exhaustive trial by error search however for two or more deletion errors the algorithm is recursive in the following sense assuming that d deletion errors have occurred the algorithm corrects the rightmost deleted bit after which the decoding reduces to the algorithm for correcting d 1 deletion errors moreover for d 2 the algorithm is efficient because its complexity is linear namely o n where n is the length of the transmitted codeword lastly in the appendix b we present values for the size of the largest code cn q d m r for certain values of q d and n these values were found through exhaustive computer search 2 ii generalized helberg codes our proof that cn q d m r is a d deletion error correcting code follows the proof given in 1 where we adapt their arguments for q ary alphabets we shall need the following lemma which allows us to replace the rightmost non zero bit with the value 0 in any two codewords that are congruent and have the same deleted codeword this assumes that the rightmost nonzero bit is the same for both codewords lemma 2 let x and y be two codewords of length n with the following two properties 1 x y 2 x d y e for some subsets d and e of 1 n with d e d suppose there exists a positive integer l such that xl yl 0 and xi yi 0 for all i l then there exist codewords x and y where x i xi y i yi for all i 6 l and x l y l 0 such that x and y have the same two properties as x and y namely i x y ii x d y e for some sets d and e having the same size as d and e proof define x and y according to the lemma since xi yi x i y i for all i 1 n it follows that m x m y m x m y but x y hence x y this proves i to prove ii we consider four cases case i assume l d e in this case the nonzero bits xl and ylare deleted from x and y respectively to obtain x d and y e define d d and e e since x d y e it follows that x d y e since the zero bits x l and y l are deleted from x and y respectively as well case ii assume l 6 d e since x d y e it follows that xl and yl appear in x d and y e as the rightmost nonzero bit respectively but then replacing xl and yl by x l and y l respectively yields x d y e thus it suffices to again define d d and e e case iii assume l d e in this case the bit xl is deleted from x to obtain x d but the bit yl is not deleted from y and therefore appears in y e let z denote the number of bits to the right of yl in y e which must all be 0 since yi 0 for all i l then the number of bits to the right of yl that are deleted from y to obtain y e equals z n l z let k denote the position of the rightmost nonzero bit xk of x d since x d y e it follows that xk yl xl and that the number of zeros to the right of xk in x d also equals z therefore the number of bits to the right of xk that are deleted from x to obtain x d equals n k z we now define d k k 1 l 1 l 1 l z where we exclude l it follows that x d x d with d d since l 6 d e this reduces to case ii where d is replaced by d case iv assume l e d the argument in this case is the same as case iii with the roles of d and e reversed theorem 3 let x and y be two codewords of length n that satisfy properties 1 and 2 in lemma 2 then 0 x y m proof we shall first prove that x y m to begin we rewrite x y as follows x y m x m y i d wixi j e wjyj n k 1 wik wjk xik where n n d this yields the bound x y i d wixi n k 1 wik wjk xik 3 next we partition s n 1 2 n into those elements k where ik jk and those where ik jk to obtain x y i d wixi k s n ik jk wik wjk xik k s n ik jk wik wjk xik i d wixi k s n ik jk wik wjk xik i d pwi k s n ik jk p wik wjk i d pwi k s n ik jk pwik k s n ik jk pwjk we now add and subtract as follows x y i d pwi k s n ik jk pwik k s n ik jk pwik k s n ik jk pwik k s n ik jk pwjk n i 1 pwi n k 1 pwmin wik wjk n i 1 pwi n k 1 pwk n i n 1 pwi n n j 1 pwn 1 j p d j 1 wn 1 j wn 1 1 m on the other hand by reversing the roles of x and y we obtain y x m which implies x y y x m hence x y m as desired next we prove that x y 6 0 by considering four different cases by lemma 1 we can assume without loss of generality that there exists an integer l 1 n such that xl yl and xi yi 0 for all i l case i assume l d e then ik 6 l for all k 1 n decompose x y i d wixi j e wjyj n k 1 wik wjk xik 4 the first two summations on the right hand side is bounded below by i d wixi j e wjyj wlxl i d i l 1 wixi wlyl j e j l 1 wjyj wl j e j l 1 wjyj the third summation is bounded below by n k 1 wik wjk xik k s n ik jk wik wjk xik k s n ik jk wik wjk xik k s n ik jk ik l 1 wik wjk xik where we have used the fact that ik 6 l and xik 0 for ik l it follows that x y wl j e j l 1 wjyj k s n ik jk ik l 1 p wik wjk since xik p next we use the decomposition l 1 j 1 pwj j e j l 1 pwj k s n ik jk ik l 1 pwjk 1 k s n ik jk ik l 1 pwjk to obtain x y wl l 1 j 1 pwj k s n ik jk ik l 1 pwik k s n ik jk ik l 1 pwjk this equivalent to x y wl l 1 j 1 pwj k s n ik l 1 pwmin ik jk 5 since k min ik jk we have x y wl l 1 j 1 pwj min n l 1 k 1 pwk wl l 1 i min n l 1 pwi wl l 1 i l d pwi 1 where we have used the fact that l d min n l 1 also recall that l n n d and d 1 case ii assume l d e recall that xl yl and xi yi 0 for i l since l e it follows that x y i d wixi j e wjyj n k 1 wik wjk xik wlxl i d i l 1 wixi j e j l 1 wjyj n k 1 wik wjk xik analogously we partition s n into those elements k where ik jk and those where ik jk to obtain x y wlxl j e j l 1 wjyj k s n ik jk wik wjk xik k s n ik jk wik wjk xik wlxl j e j l 1 wjyj k s n ik jk wik wjk xik wl j e j l 1 wjyj k s n ik jk ik l 1 wik wjk xik the rest of the argument now follows the same as that in case i to establish that x y 1 case iii assume l e d the argument in this case is the same as case ii by switching the roles of d and e case iv assume l 6 d e then ik l for some ik s we claim that jk ik 1 since x d y e it follows that xik yjk on the other hand we have yik xik and yi 0 for all i l ik thus jk ik 1 6 we now proceed similarly as in previous cases x y i d i l 1 wixi j e j l 1 wjyj n k 1 wik wjk xik j e j l 1 wjyj k s n ik jk wik wjk xik k s n ik jk wik wjk xik j e j l 1 wjyj k s n ik jk ik l 1 wik wjk xik wik wjk xik next since xi p for all i n we have x y wl pwjk j e j l 1 pwj k s n ik jk ik l 1 pwik k s n ik jk ik l 1 pwjk again using 1 we obtain the lower bound x y wl l 1 j 1 pwj k s n ik jk ik l 1 pwik k s n ik jk ik l 1 pwjk the rest of the proof is the same as that in case i therefore x y 1 hence 0 x y m as desired theorem 4 the code cn q d m r is a d insertion deletion correcting code proof suppose on the contrary that cn q d m r is not capable of correcting up to d deletions then there exist two codewords x y cn q d m r and subsets d and e with d e d such that x d y e by theorem 3 we have 0 x y m it follows that x 6 y a contradiction thus cn q d m r is capable of correcting up to d deletions and therefore can correct up to d insertion deletion errors as well due to a result of levenshtein 7 iii decoding of generalized helberg codes in this section we describe a linear decoding algorithm to correct deletion errors in a generalized helberg codeword x cn 2 d m r where c deletions have occurred with c d we first present an algorithm to correct one deletion and then provide a recursive algorithm to correct two or more deletions 7 a decoding one deletion in the decoding of one deletion our algorithm is the same as exhaustive trial by error search let x cn q d m r and x be the deleted codeword obtain from x by deleting one symbol we assume d 2 otherwise if d 1 levenshtein decoding should be used then x has length n 1 we define x x 1 x n to be the initial decoding of x where we append a variable symbol to x at initial position p n i e the right most position x x 1 x 2 x n 1 let i m x m x denote the index lemma 10 in appendix a shows that it possible to determine m x from m x we then attempt to decode x in order to obtain the original codeword x so that m x m x by either inserting a value for or shifting this deleted symbol to the left of x p 1 the decision is based on the following condition which compares the current index i and the moment of at position p algorithm d 1 decode one deletion let p n if i wp for some value 0 1 p then is in its correct position as the symbol that was deleted from x to decode set otherwise shift x p 1 to the right of equivalent to shifting to the left one position update i i x p 1 wp wp 1 and update p p 1 this is repeated until the the correct position and value for is found it is clear that algorithm d 1 will correctly decode x since it essentially performs an exhaustive search assuming that x exists we illustrate this algorithm in the following example algorithm d 1 decode one deletion 1 x x 1 x 2 x 3 x n 1 initialize x by appending variable symbol to x at position n where is to be determined 2 for p n to 1 do p denotes position of 3 for q 1 to 0 do denotes test value for 4 if i wp then 5 6 stop 7 end if 8 end for 9 x x 1 x 2 x 3 x p 2 x p 1 x p 1 x n 1 shift x p 1 to the right of and update x 10 i i x p 1 wp wp 1 update the index 11 end for example 5 suppose the ternary codeword x 1 2 2 0 2 2 1 2 c 8 3 2 w 9 23 was transmitted and x 1 2 2 0 2 1 2 was received so that one deletion occurred we wish to decode x to recover x the weights wi corresponding to this codebook are defined by the recursion wi 1 2 wi 1 wi 2 the first 10 weights are given in table i in particular w 9 3861 table i weights wi for d 2 q 3 i wi i wi 1 1 6 189 2 3 7 517 3 9 8 1413 4 25 9 3861 5 69 10 10549 since m w 9 3861 r 23 and m x 1386 and m x r it follows from lemma 10 in appendix a that m x 3884 thus the index i m x m x 2498 as defined earlier let x be our initial decoding 8 for x where we initially insert a variable symbol at the right most position of x namely at position p 8 x 1 2 2 0 2 1 2 according to algorithm d 1 since i 6 w 8 for all 0 1 2 we shift x 7 2 to the right of update p p 1 7 and update the index i i x 7 w 8 w 7 706 so that x now appears as x 1 2 2 0 2 1 2 again since i 6 w 7 for all 0 1 2 we shift x 6 1 to the right of update p p 1 6 and update i i x 6 w 7 w 6 378 then x 1 2 2 0 2 1 2 we now find that i w 6 378 for 2 in that case we set 2 and set i 0 this gives the original codeword x 1 2 2 0 2 2 1 2 x and completes the decoding b decoding two deletions for binary helberg codes capable of correcting two deletions we shall describe a recursive algorithm to decode a codeword where two symbols have been deleted by reducing the problem to that of correcting one deletion a problem that was solved in the previous sub section suppose x is obtained from x cn 2 2 m r after deleting two symbols from x then to decode x whose length is n 2 we again define x to be an initial decoding of x where we insert two variable symbols 1 and 2 at the right end of x namely at positions p 1 and p where we initially set p n x x 1 x 2 x n 2 1 2 we calculate i m x m x use lemma 10 in appendix a to determine m x our algorithm essentially determines whether to set 2 equal to an alphabet symbol 0 or 1 in which case the decoding reduces to the one deletion algorithm d 1 or shift x p 2 initially x n 1 to the right of 2 the following conditions describe when each action is executed algorithm d 2 binary decode two deletions let p n if i 1 wp 1 2 wp 2 for some 1 2 0 1 then 1 and 2 are in their correct positions as symbols that were deleted from x to decode set 1 1 and 2 2 otherwise we assume that either 1 or 2 or both are not in their correct positions in what follows then 1 for wp i a if x p 2 0 then shift x p 2 to the right of 2 i e to the right of 2 b if x p 2 1 and i i wp wp 2 then set 2 0 and update the index i i wp 1 wp 2 ii i wp wp 2 then shift x p 2 to the right of 2 and update the index i i wp wp 2 2 for wp i a if x p 2 0 then set 2 1 and update i i wp b if x p 2 1 then shift x n 2 to the right of 2 and update i i wp wp 2 update p p 1 and repeat algorithm until the correct position and value for 2 is found if 2 is found but 1 remains unknown then apply the one deletion algorithm d 1 to determine 1 proof of algorithm d 2 binary to prove conditions 1 and 2 are valid we argue as follows 1 suppose wp i we consider two cases a x p 2 0 we consider two situations and show that x p 2 should be shifted to the right of 2 in both 9 situations i 2 is in its correct position as the right most deleted symbol in that case since wp i there is only one choice of symbol for 2 namely 2 0 otherwise if 2 1 then the moment for x will exceed that of x up to position p regardless of the position of 1 in the final decoding for x mp x mp x m 2 mp x wp 2 mp x i mp x but observe that setting 2 0 is equivalent to shifting x p 2 0 to the right of 2 thus we choose to shift instead ii 2 is not in its correct position as the right most deleted symbol in that case we are forced to shift x p 2 to the right of 2 b x p 2 1 we consider two sub cases i i wp wp 2 we claim that 2 is in its correct position as the right most deleted symbol otherwise we are forced to shift x p 2 to the right of 2 but then the moment of x will exceed that of x up to position p mp x mp x wp wp 2 mp x i wp wp 2 mp x thus 2 is in its correct position and moreover 2 0 since wp i ii i wp wp 2 we claim that 2 is not in its correct position otherwise 2 0 since wp i and so x x 1 x 2 x p 2 1 2 0 x p 1 x n but then the moment of x which is maximized if 1 1 will always be strictly less than the moment of x up to position p mp x mp x wp 1 mp x wp wp 2 mp x i mp x thus 2 is not in its correct position therefore x p 2 should be shifted to the right of 2 2 suppose wp i we again consider two cases a x p 2 0 we claim that 2 is in its correct position as the right most deleted symbol otherwise if 2 is not in its correct position then we are forced to shift x p 2 to the right of 2 in which case x x 1 x 2 x p 3 1 2 x p 2 0 x n but then the moment of x which is maximized if 1 2 1 will always be less than the moment of x up to position p mp x mp x wp 2 wp 1 mp x wp mp x i mp x thus 2 is in its correct position next we claim that 2 1 otherwise if 2 0 then the moment of x which is maximized if 1 1 will always be less than the moment of x up to position p mp x mp x wp 1 mp x wp mp x i mp x b x p 2 1 we consider two situations and show that x p 2 should be shifted to the right of 2 in both situations i 2 is in its correct position we claim that 2 1 otherwise if 2 0 then the moment of x which is 10 maximized if 1 1 will always be less than the moment of x up to position p mp x mp x wp 2 wp 1 mp x wp mp x i mp x thus 2 1 but observe that setting 2 1 is equivalent to shifting x p 2 1 to the right of 2 thus we choose to shift instead ii 2 is not in its correct position in that case we are forced to shift x p 2 to the right of 2 this completes the proof we now demonstrate algorithm d 2 binary in the following example to show how the problem of decoding two deletions can be reduced to that of decoding one deletion algorithm d 2 binary decode two deletions 1 x x 1 x 2 x n 2 1 2 initialize x by appending variable symbols 1 and 2 to x at positions n 1 and n respectively where 1 and 2 are to be determined 2 for p n to 1 do p denotes position of 2 3 for 1 2 q 1 to 1 do double nested for loop 4 if i 1 wp 1 2 wp then 5 1 1 2 2 6 stop 7 end if 8 end for 9 if wp i then 10 if x p 2 0 or x p 2 1 and i wp wp 2 then 11 x x 1 x 2 x p 3 1 2 x p 2 x p 1 x n 2 shift x p 2 to the right of 2 and update x 12 i i x p 2 wp wp 2 update the index 13 else 14 x x 1 x 2 x p 2 10 x p 1 x n 2 insert 0 for 2 and update x 15 call algorithm d 1 to decode 1 16 stop 17 end if 18 else wp i 19 if x p 2 0 then 20 x x 1 x 2 x p 2 11 x p 1 x n 2 insert 1 for 2 and update x 21 i i wp update the index 22 else x p 2 1 23 x x 1 x 2 x p 3 1 2 x p 2 x p 1 x n 2 shift x p 2 to the right of 2 and update x 24 i i x p 2 wp wp 2 update the index 25 call algorithm d 1 to decode 1 26 stop 27 end if 28 end if 29 end for example 6 suppose x c 10 2 2 w 11 62 was transmitted and x 1 1 0 1 0 1 0 1 was received so that two deletions occurred the weights wi are defined by wi 1 wi 1 wi 2 see table ii therefore m w 11 232 and m x 84 since m x r 62 it follows that m x r m 294 thus i m x m x 210 we initialize x 1 1 0 1 0 1 0 1 1 2 and apply algorithm d 2 since 2 fails we compare w 10 143 with i as w 10 i and x 8 1 we shift x 8 to 11 table ii weights wi for d 2 q 2 i wi i wi 1 1 7 33 2 2 8 54 3 4 9 88 4 7 10 143 5 12 11 232 6 20 12 376 the right of 2 and update the index i i w 10 w 8 121 then x takes the form x 1 1 0 1 0 1 0 1 2 1 again since 2 fails we compare w 9 88 with i as w 9 i and x 7 0 we set 2 1 and update i i w 9 33 so that x 1 1 0 1 0 1 0 1 1 1 from here we apply algorithm d 1 to determine which yields 1 1 at position 7 thus x 1 1 0 1 0 1 1 0 1 1 x c decoding multiple deletions suppose x is obtained from x cn q d m r after deleting c symbols from x where 2 c d then to decode x whose length is n c we again define x to be an initial decoding of x where we insert c variable symbols 1 c at the right end of x namely at positions p c 1 p where we initially set p n x x 1 x 2 x n c 1 c we calculate i m x m x use lemma 10 in appendix a to determine m x as before our algorithm essentially determines whether to set the right most symbol c equal to an alphabet symbol 0 q 1 in which case the decoding reduces to algorithm dm for c 1 deletions or shift x p c initially x n 1 to the right of c the following conditions describe when each action is executed algorithm dm decode multiple deletions let p n if i 1 wp c 1 2 wp c 2 cwp 3 for a set of values 1 c 0 1 p then 1 c are in their correct positions as symbols that were deleted from x to decode set i i for i 1 c otherwise we assume that at least one of the symbols 1 c are not in their correct positions in what follows define max max wp wp c i 0 1 p then 1 for wp i a if x p c 0 then shift x p c to the right of c update the position p p 1 and repeat algorithm b if x p c 1 and i i wp wp c then set c 0 and apply algorithm dm on the truncated codeword x p 1 x 1 x p c 1 c 1 with index i to correct c 1 deletions ii i wp wp c then shift x p c to the right of c update the index i i x p c wp wp c update the position p p 1 and repeat algorithm 2 for wp i 12 a if x p c max then set c max update the index i i maxwp and apply algorithm dm on the truncated codeword x p 1 x 1 x p c 1 c 1 with index i to correct c 1 deletions b if x p c max and i maxwp i then set c max update the index i i maxwp and apply algorithm dm on the truncated codeword x p 1 x 1 x p c 1 c 1 with index i to correct c 1 deletions ii maxwp i then shift x p c to the right of c update the position p p 1 and repeat algorithm c if x p c max then shift x p c to the right of c update the index i i max wp wp c update the position p p 1 and repeat algorithm proof we prove that the conditions 1 and 2 in algorithm dm give a correct decoding of x 1 suppose wp i we consider two cases a x p c 0 we consider two situations and show that x p c should be shifted to the right of c in both situations i c is in its correct position as the right most deleted symbol in that case since wp i there is only one choice of symbol for c namely c 0 otherwise if c 1 then the moment for x will exceed that of x up to position p regardless of the position and values of the other symbols 1 c 1 in the final decoding for x mp x mp x m c mp x wp c mp x i mp x but observe that setting c 0 is equivalent to shifting x p c 0 to the right of c and later setting 1 c 1 equal to appropriate values determined by our algorithm thus we choose to shift instead ii c is not in its correct position as the right most deleted symbol in that case we are forced to shift x p c to the right of c b x p c 1 we consider two sub cases i i wp wp c we claim that c is in its correct position as the right most deleted symbol otherwise we are forced to shift x p c to the right of c but then the moment of x will exceed that of x up to position p regardless of the position and values of the other symbols 1 c 1 mp x mp x x p c wp wp c mp x i wp wp c mp x thus c is in its correct position and moreover c 0 since wp i ii i wp wp c we claim that c is not in its correct position otherwise c 0 since wp i and so x x 1 x 2 x p c 1 c 1 0 x p 1 x n but then the moment of x which is maximized if 1 c 1 p recall p q 1 will always be strictly less than the moment of x up to position p mp x mp x p wp c 1 wp 1 mp x wp p wp c wp d mp x wp wp c mp x i mp x thus c is not in its correct position therefore x p c should be shifted to the right of c 2 suppose wp i we first prove that if c is in its correct position then c max we rule out all other possible values as follows i suppose c max but then the moment of x up to position p which is maximized if 1 c 1 p will always be less than the moment of x because of the following calculation recall the recurrence satisfied by 13 wp and the fact that max wp wp c i mp x mp x p wp c 1 wp 1 wp mp x 1 wp p wp c wp d mp x max wp wp c mp x i mp x ii suppose c max but then the moment of x up to position p which is minimized if 1 c 1 0 will always be greater than the moment of x because of a similar calculation mp x mp x wp mp x wp wp c mp x i mp x thus c max if it is in its correct position next we consider three cases a x p c max we claim that c is in its correct position otherwise we are forced to shift x p c to the right of c but then the moment of x which is minimized if 1 c 1 0 will always be greater than the moment of x up to position p mp x mp x x p c wp wp c mp x i mp x thus c is in its correct position and as we argued previously c max b x p c max we consider two sub cases i maxwp i we claim that c is in its correct position otherwise we are forced to shift x p c to the right of c but then the moment of x which is maximized if 1 c 1 p will always be less than the moment of x up to position p this is because mp x mp x p wp c wp 1 x p c wp wp c mp x wp p wp c 1 wp d x p c wp wp c mp x 1 x p c wp next we use the fact that x p c max to obtain mp x mp x maxwp mp x i mp x thus we set c max ii maxwp i we claim that c is not in its correct position otherwise if c is in its correct position then we must have c max and so the moment of x up to position p which is minimized if 1 c 1 0 will always be greater than the moment of x mp x mp x maxwp mp x i mp x 14 thus we shift x p c to the right of c c x p c max in this case observe that if c is in its correct position then c max but this same result can be achieved by shifting x p c to the right of c and later setting 1 c 1 equal to appropriate values determined by our algorithm thus we choose to shift instead this completes the proof we demonstrate algorithm dm with the following example example 7 suppose a ternary codeword x c 8 3 2 w 9 23 of length 8 was transmitted and the deleted codeword received x 1 2 2 0 1 2 was received where two symbols were deleted we have m w 9 3861 see table i for a list of the weights wi since m x 504 r it follows from lemma 10 that m x m r 3884 thus the index i m x m x 3380 we now apply algorithm dm by defining our initial decoding as x 1 2 0 2 1 2 1 2 since 3 fails we compare w 8 1413 with i as w 8 i we compute max 2 since x 6 2 max we shift x 6 to the right of 2 and update i i x 6 w 8 w 6 932 so that x 1 2 0 2 1 1 2 2 again since 3 fails we compare w 7 517 with i as w 7 i we calculate max 2 since x 5 1 max and maxw 7 1034 i we shift x 5 to the right of 2 and update i i x 5 w 7 w 5 484 so that x 1 2 0 2 1 2 1 2 since 3 fails again we compare w 6 189 with i as w 6 i we calculate max 2 since x 4 2 max we shift x 6 to the right of 2 and update i i x 4 w 6 w 4 156 so that x 1 2 0 1 2 2 1 2 again since 3 fails we compare w 5 69 with i as w 5 i we calculate max 2 since x 3 0 max and maxw 5 138 i we set 2 max 2 and update the index i i maxw 5 18 this yields x 1 2 0 1 2 2 1 2 it remains to apply algorithm d 1 on the truncated codeword x 4 1 2 0 1 with i 18 to decode 1 following example 5 we find that 1 2 should be inserted at position 3 hence our final decoding is x 1 2 2 0 2 2 1 2 x iv appendix a useful lemmas in this appendix we aim to show that the moment of a codeword is strictly less than twice the modulus defining its codebook this allows us to precisely determine its moment based on the moment of the deleted codeword lemma 8 for d 2 n i 1 wi p d 1 i 0 d i wn i n pd 1 4 proof we argue by induction on n it is straightforward to verify that 4 holds for n 1 next assume that 4 holds for arbitrary n then for n 1 since n 1 i 1 wi n i 1 wi wn 1 15 it follows from the inductive hypothesis and the recurrence for wn 1 that n 1 i 1 wi p d 1 i 0 d i wn i n pd 1 pd wn 1 wn 1 pd 1 p d 2 i 0 d i 1 wn i pd wn 1 n 1 pd 1 then re index the summation on the right hand side and simplifying yields n 1 i 1 wi p d 1 i 0 d i wn 1 i n 1 pd 1 hence 4 holds for n 1 lemma 9 for d 2 n i 1 wi d pd 1 wn 1 5 proof it follows from lemma 8 that n i 1 wi p d 1 i 0 d i wn i n pd 1 pd d 1 i 0 wn i n pd 1 d wn 1 1 n pd 1 d pd 1 wn 1 this proves 5 lemma 10 let x cn q d m r suppose x is obtained by deleting c symbols from x where c d if m x r then m x r m otherwise if m x r then m x r proof recall from our definition of x that m x r mod m we claim that m x 2 m 6 this follows from lemma 9 m x p n i 1 wi ps ps 1 wn 1 2 wn 1 2 m where we have used the fact that ps ps 1 2 since d 2 and p 1 if m x r then m x r since m x m x it follows from 6 that m x r m on the other hand if m x r then we claim that m x r to prove this assume on the contrary that m x r m 16 table iii binary 2 deletion codes values of nn 2 2 and rn 2 2 n nn 2 2 rn 2 2 1 1 0 1 2 1 0 1 2 3 3 2 0 4 2 0 1 2 7 5 2 0 1 2 3 4 5 6 7 12 13 14 19 6 3 0 1 6 7 12 13 7 4 12 13 8 5 12 33 9 6 12 33 39 45 66 10 8 66 11 9 65 66 99 100 120 121 154 155 12 11 65 66 99 154 155 175 176 181 182 187 188 208 209 264 297 298 13 15 297 298 14 18 297 441 475 496 530 674 15 22 297 441 674 763 784 790 796 817 906 1139 1283 16 30 1283 then m x m x p wn c 1 wn wn 1 p wn d 1 wn c m it follows that m x m x m r which is a contradiction b sizes of generalized helberg codes we present values for the size of the largest code in terms of the codeword length given positive integers q d n r and m wn 1 we denote the size of the largest code cn q d wn 1 r by nn q d max r 0 1 wn 1 1 cn q d wn 1 r also let rn q d denote the set of values r for which cn q d wn 1 r nn q d through exhaustive computer search we computed the values of nn q d and rn q d for certain values of q d and n table iii gives values for nn 2 2 and rn 2 2 for binary 2 deletion codes q 2 d 2 with n ranging from 1 to 15 tables iv and v give values for ternary 2 deletion codes q 3 d 2 and quaternary 2 deletion codes q 4 d 2 respectively but over a shorter range for n references 1 k a s abdel ghaffar f palunc ic h c ferreira and w a clarke on helberg s generalization of the levenshtein code for multiple deletion insertion error correction ieee trans inf theory 58 2012 no 3 1804 1808 17 table iv ternary 2 deletion codes values of nn 3 2 and rn 3 2 n nn 3 2 rn 3 2 1 1 0 1 2 2 1 0 1 2 3 4 5 6 7 8 3 2 0 1 4 2 0 1 2 3 4 5 6 7 25 26 50 51 5 3 0 25 6 4 25 50 7 4 24 25 50 69 70 71 72 73 74 75 94 119 138 139 140 141 142 143 144 163 188 189 542 567 1059 1084 8 5 24 25 49 50 69 70 71 72 73 74 188 189 213 214 377 378 402 403 517 518 519 520 521 522 541 542 566 567 9 7 541 542 566 567 1058 1059 1083 1084 10 8 517 518 519 520 521 541 542 566 567 1437 1482 1483 1484 1485 1486 1487 1551 1552 1553 1554 1555 1556 1601 2850 2895 2896 2897 2898 2899 2900 2964 2965 2966 2967 2968 2969 3014 3884 3885 3909 3910 3930 3931 3932 3933 3934 2 m c davey and d j c mackay reliable communication over channels with insertions deletions and substitutions ieee trans inf theory 47 2001 no 2 687 698 3 l dolecek and v anatharam repetition error correcting sets explicit constructions and prefixing methods siam j discrete math 23 2010 no 4 2120 2146 4 a s j helberg coding for the correction of synchronization errors ph d dissertation rand afrikaans univ johannesburg south africa 1993 5 a s j helberg and h c ferreira on multiple insertion deletion correcting codes ieee trans inf theory vol 48 no 1 305 308 jan 2002 6 d kracht and s schober insertion and deletion correcting dna barcodes based on watermarks bmc bioinformatics 16 50 2015 7 v i levenshtein binary codes capable of correcting deletions insertions and reversals sov phys dokl 10 1966 no 8 707 710 8 i landjev and k haralambiev on multiple deletion codes serdica j comput 1 no 1 2007 13 26 9 f paluncic t g swart j h weber h c ferreira and w a clarke a note on non binary multiple insertion deletion correcting codes information theory workshop itw 2011 ieee 683 687 10 f palunc ic k a s abdel ghaffar h c ferreira and w a clarke a multiple insertion deletion correcting code for run length limited sequences ieee trans inf theory 58 2012 no 3 1809 1824 11 l j schulman and d zuckerman asymptotically good codes correcting insertions deletions and transpositions ieee trans inf theory vol 45 no 7 nov 1999 12 tenengol ts nonbinary codes correcting single deletion or insertion ieee trans inf theory vol 30 no 5 766 769 sep 1984 13 r r varshamov and g m tenengol ts codes which correct single asymmetric errors autom remote control vol 26 no 2 286 290 1965 18 table v quaternary 2 deletion codes values of nn 4 2 and rn 4 2 n nn 4 2 rn 4 2 1 1 0 1 2 3 2 1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 3 2 0 1 2 4 2 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 61 62 63 122 123 124 183 184 185 5 3 0 1 61 62 6 4 61 62 122 123 183 184 7 5 61 880 8 6 61 122 183 880 941 1760 1821 2640 2701 3398 3459 3520 19 i introduction ii generalized helberg codes iii decoding of generalized helberg codes iii a decoding one deletion iii b decoding two deletions iii c decoding multiple deletions iv appendix iv a useful lemmas iv b sizes of generalized helberg codes references