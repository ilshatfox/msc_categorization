ar x iv 1 10 1 30 01 v 1 m at h n t 1 5 ja n 20 11 how to use the fast fourier transform in large finite fields petur birgir petersen rungsted kyst 2009 abstract the article contents suggestions on how to perform the fast fourier transform over large finite fields the technique is to use the fact that the multiplicative groups of specific prime fields are surprisingly composite 1 1 introduction in 2003 gao published the article a new algorithm for decoding reed solomon codes 1 gaos algorithm can be executed through out with the use of the discrete fourier transform dft in a finite field the algorithm will of course be much faster using the fast fourier transformation fft the coding and decoding of reed solomon codes is often performed over finite fields fq of order q 2 m where m n in 2006 and 2007 truong chen wang chang reed published the article 2 3 fast prime factor discrete fourier algorithms over gf 2 m for 8 m 10 which is is a sort of follow up on another article 4 that treats the cases n 4 5 6 8 these results are very important but 210 1024 and for instance digital 1 msc 11 42 68 and 94 keywords finite fields discrete fourier transform dft fast fourier transform fft coding and decoding of reed solomon codes 1 http arxiv org abs 1101 3001 v 1 tv signals use much bigger files say in the order of 220 106 for large files like this my suggestion is to augment the file with an extra bit and let the fft be performed over a prime field fp for certain primes this can be performed efficient by an algorithm based on the cooley tukey algorithm 5 from 1965 in the next section the algorithm will be explained and the last section contents a variety of suggestions on well suited primes p where the fft over fp will be specially efficient 2 fast fourier transformation over finite fields definition 1 let be an element in fpm of order n where n p m 1 the discrete fourier transform dft of the n tuple v v 0 v 1 vn 1 f n pm is the n tuple v with components given by vj n 1 i 0 ij vi j 0 1 n 1 1 the inverse discrete fourier transform idft of the n tuple v fnpm is the n tuple vi n 1 mod p n 1 i 0 ijvj i 0 1 n 1 for a proof see e g 6 notice that the idft apart from the factor n 1 mod p also is a dft now assume that n pm 1 is composite n r 1 r 2 the indices in definition 1 can be rewritten like this j j 1 r 1 j 0 j 0 0 1 r 1 1 j 1 0 1 r 2 1 i i 1 r 2 i 0 i 0 0 1 r 2 1 i 1 0 1 r 1 1 replacing vi by x 0 i equation 1 now can be rewritten as 2 v j 1 j 0 r 2 1 i 0 0 r 1 1 i 1 x 0 i 1 i 0 i 1 r 2 j i 0 j since n r 1 r 2 1 then i 1 r 2 j i 1 r 2 j 0 set x 1 j 0 i 0 r 1 1 i 1 0 x 0 i 1 i 0 j 0 i 1 r 2 then v j 1 j 0 r 2 1 i 0 0 x 1 j 0 i 0 i 1 r 2 j j 1 r 1 j 0 i 0 it will require nr 1 multiplications and n r 1 1 additions to calculate x 1 for all j 0 i 0 and nr 2 multiplications and n r 2 1 additions to calculate v from x 1 this will give a total of n r 1 r 2 multiplications and n r 1 r 2 2 additions in fpm for n 4 this is faster than the dft which requires n 2 multiplications and n n 1 additions in fpm more generally if n r 1 r 2 rs where r 1 r 2 rs n then the indices j and i can be expressed like this j js 1 r 1 r 2 rs 1 js 2 r 1 r 2 rs 2 j 1 r 1 j 0 where jk 1 0 1 rk 1 1 k s and i is 1 r 2 r 3 rs is 2 r 3 r 4 rs i 1 rs i 0 where ik 1 0 1 rs k 1 1 1 k s now equation 1 can be rewritten 7 by setting vi x 0 is 1 is 2 i 1 i 0 and vj v js 1 js 2 j 1 j 0 as 3 v js 1 js 2 j 1 j 0 rs 1 i 0 0 rs 1 1 i 1 0 r 1 1 is 1 0 x 0 is 1 is 2 i 1 i 0 ij using the fact that r 1 r 2 rs n 1 this expression can be calculated by s recursive equations x 1 j 0 is 2 is 3 i 1 i 0 r 1 1 is 1 0 x 0 is 1 is 2 i 1 i 0 j 0 is 1 r 2 rs 2 xk j 0 j 1 jk 1 is k 1 i 1 i 0 rk 1 is k 0 xk 1 j 0 j 1 jk 2 is k i 1 i 0 jk 1 r 1 r 2 rk 1 jk 2 r 1 r 2 rk 2 j 0 is krk 1 rk 2 rs for k 2 3 s 1 xs j 0 j 1 js 1 rs 1 i 0 0 xs 1 j 0 j 1 js 2 i 0 js 1 r 1 r 2 rs 1 js 2 r 1 r 2 rs 2 j 0 i 0 now the final output xs j 0 j 1 js 1 v js 1 js 2 j 1 j 0 vj this algorithm will require a total of n r 1 r 2 rs multiplications and n r 1 r 2 rs s additions in fpm here we did include the multipli cations by 0 1 for n r the algorithm requires a total of n r r log 2 r n log 2 n multip likations the factor r log 2 r achieves its minimum for r 3 but r 2 and r 4 is still better because of the possibility of reducing the numbers of multiplications using lemma 2 let fpm be of order n if n is even and t z then n 2 t t proof the order of is n pm 1 hence n 1 so 0 n 1 n 2 1 n 2 1 since ord n then n 2 6 1 and hence n 2 1 0 for n 2 use of the lemma will reduce the number of multiplications in f 2 m by 50 this is for s 3 caused by the possibility of rearranging the recursive equations 2 in a slightly different way in principle due to 8 4 y 1 j 0 is 2 is 3 i 1 i 0 r 1 1 is 1 0 x 0 is 1 is 2 i 1 i 0 j 0 is 1 n r 1 j 0 is 2 r 3 rs 3 yk j 0 j 1 jk 1 is k 1 i 1 i 0 rk 1 is k 0 yk 1 j 0 j 1 jk 2 is k i 1 i 0 jk 1 is k n rk jk 1 r 1 r 2 rk 1 j 1 r 1 j 0 is k 1 rk 2 rs for k 2 3 s 1 when s 4 else go to the next equation ys 1 j 0 j 1 js 2 i 0 rs 1 1 i 1 0 ys 2 j 0 j 1 js 3 i 1 i 0 js 2 i 1 n rs 1 js 2 r 1 r 2 rs 2 j 1 r 1 j 0 i 0 ys j 0 j 1 js 1 rs 1 i 0 0 ys 1 j 0 j 1 js 2 i 0 js 1 i 0 n rs here the final output ys j 0 j 1 js 1 v js 1 js 2 j 1 j 0 vj for 1 2 s a r point fourier transform is included in step num ber of the algorithm among these each two point fourier transform does not require any multiplication because 0 1 and n 2 within the original cooley tukey algorithm which is executed over the field of complex numbers it is possible to do additional tricks by looking at the real and imaginary part of a number these tricks can not be transferred to a finite field the overall conclusion must be that the algorithm sketched above will be relatively most efficient if the total number of points n r 11 r 2 2 r u u is factored in factors as small as possible 5 3 concrete suggestions versions of the cooley tukey algorithm are not very efficient over bi nary fields f 2 m where m n in most of these cases the order 2 m 1 of the multiplicative group is not highly composite for instance the order of the fields examined in the recent article 2 3 are 28 29 and 210 where 28 1 3 5 17 29 1 7 73 and 210 1 3 11 31 it could also be mentioned that 27 1 is a prime the algorithm presented in 2 3 is a prime factor algorithm which as such takes advantage of the fact that all the prime factors in 2 m 1 are coprimes for 8 n 10 this will also be the case for a great deal of the numbers 2 m 1 for big ger m but some of the prime factors tend to be bigger too for example 215 1 7 31 151 216 1 3 5 17 257 217 1 is prime 218 1 33 7 19 73 and 219 1 is prime it is obvious as mentioned that versions of the cooley tukey algorithm will not be very efficient in finite fields like these it will in these cases be much more efficient to avoid using all m bits in its full content and use al gorithm 2 or 3 over a prime field instead here are two examples instead of using 17 bits to create the field f 217 with a multiplicative af order 131071 which is a prime then use 18 bits to create the prime field f 147457 which multiplicative group is of the order 2 14 32 or instead of using 19 bits to create the field f 219 with a multiplicative group of the order 524287 which is also a prime then use an extra bit to create the field f 786433 which multiplicative group is of the order 2 18 3 the orders of the multiplicative groups of the prime fields given in the two examples are highly composite and the algorithm 3 which is based on the cooley tukey algorithm will be very efficient here in the case f 147457 dft uses 214 32 2 2 1010 multiplications and the fft 3 suggested here will require 214 32 14 1 2 3 3 106 multiplications which is 214 32 14 1 2 3 7 103 times faster than the dft here we have used lemma 2 to reduce the number of multiplications the multiplication in it self is also 6 easy just multiplication modulo the prime which in the example is 147457 the estimate is roughly the same as regards the additions the dft over f 147457 requires 147457 147457 1 2 10 10 additions and our fft 3 requires 147457 14 2 2 3 14 2 3 106 additions which is 147457 1 14 2 2 3 14 2 8 103 times better in the second example f 786433 our fft 3 will perform the multiplications 218 3 18 1 3 4 104 times faster than the dft and the additions will similarly be performed 786433 1 18 2 3 18 1 4 104 faster than the dft a fft calculated in for instance 1 second would then take roughly 10 hours as a dft 4 the elements of order n in our fft 3 over fp an element of order n p 1 appears usually we will choose n p 1 and then will be a generator of fp such a generator will normally be easy to find according to lagrange s theorem in a finite group the order of any element will be a divisor in the order of the group therefore an element a is a generator of the multiplicative subgroup of fp with n elements iff a n r 6 1 mod p for every prime factor r of n a probabilistic algorithm to determine the smallest possible generator of the multiplicative subgroup of fp with n elements goes like this algorithm 3 input n p 1 1 prime factorize n 2 choose the smallest integer a from the set 2 3 n 3 for every primefactor r of n calculate an r 7 4 if this quantity is different from 1 for all primefactors r of n then stop else repeat step 2 and 3 for the lowest values of a 2 3 n until this happens then stop output the last value of a comments on the algorithm for practical puposes n 230 and then the prime factorization of n will not be computationally difficult the algorithm will allways find a generator as we know that it exists if the prime factorization of n is n p 11 p 2 2 p u u then the numbers of generators of the multiplicative subgroup of fp will be n n 1 1 p 1 1 1 p 2 1 1 pu see e g 9 hence the possibility of a random a 2 3 n being a generator equals 1 1 p 1 1 1 p 2 1 1 pu in both the earlier mentioned examples f 147457 and f 786433 this probability is 1 1 2 1 1 3 1 3 5 a list of suitable choices of primes p at the end of this article i will print a list of primes 216 p 221 where the only primefactors in p 1 are 2 and 3 for these primes the fft algorithms 2 and 3 treated here will be especially efficient for n p 1 2 13 2 the number of multiplications in algorithm 2 will be p 1 2 1 3 2 which can be reduced to p 1 1 3 2 using algorithm 3 the number of additions will for both fft algorithms be p 1 2 1 3 2 1 2 p 1 1 2 2 as we see the table starts with the biggest fermat number 22 n 1 known to be a prime for nearly half of the shown numbers p 1 a generator of fp is 5 2 2 1 a nice number to multiply with in base 2 the factoring was implemented with the math program maple on my mo bile pc 8 prime p factorization of p 1 generator 65537 216 3 139969 26 37 13 147457 214 32 10 209953 25 38 10 331777 212 34 5 472393 23 310 5 629857 25 39 5 746497 210 36 5 786433 218 3 10 839809 27 38 7 995329 212 35 7 1179649 217 32 19 1492993 211 36 7 1769473 216 33 5 1990657 213 35 5 perspective the number of simple factorizations like those above seems not to stop when the primes grow even bigger here are two examples for the prime p 113246209 the factorization of p 1 is 222 33 for the prime p 725594113 the factorization of p 1 is 212 311 9 references 1 shuhong gao a new algorithm for decoding reed solomon codes in communications information and network security v bhargava h v poor v tarokh and s yoon eds pp 55 68 kluwer academic publishers 2003 isbn 978 1 4020 7251 2 2 t k truong p d chen l j wang y chang i s reed fast prime factor discrete fourier algorithms over gf 2 m for 8 m 10 inform sci 176 pp 1 26 2006 3 t k truong p d chen l j wang y chang i s reed erratum to fast prime factor discrete fourier algorithms over gf 2 m for 8 m 10 inform sci 177 pp 967 968 2007 4 i s reed t k truong r l miller and b benjauthrit further results on fast transforms for decoding reed solomon codes over gf 2 n for n 4 5 6 7 dsn progress report 42 50 pp 132 154 january and february 1979 5 james w cooley and john w tukey an algorithm for machine calculation of complex fourier series math comp vol 19 pp 297 301 april 1965 6 richard e blahut algebraic codes for data transmission pp 132 133 cambridge university press cambridge 2003 isbn 0 521 55374 1 7 g d bergland the fast fourier transform recursive equations for arbitrary length records math comp vol 21 pp 236 238 april 1967 10 8 w m gentleman and g sande fast fourier transform for fun and profit afips proc 1966 fall joint computer conf volume 29 pp 563 678 spartan washington dc 1966 9 neal koblitz a course of number theory and cryptography second edition pp 34 35 springer verlag new york 1994 isbn 0 387 94293 9 11 1 introduction 2 fast fourier transformation over finite fields 3 concrete suggestions 4 the elements of order n 5 a list of suitable choices of primes p