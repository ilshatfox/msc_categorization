efficient algorithms to test digital convexity lo c crombez universite clermont auvergne and limos clermont ferrand france lcrombez isima fr guilherme d da fonseca universite clermont auvergne and limos clermont ferrand france fonseca isima fr yan ge rard universite clermont auvergne and limos clermont ferrand france yan gerard uca fr abstract a set s zd is digital convex if conv s zd s where conv s denotes the convex hull of s in this paper we consider the algorithmic problem of testing whether a given set s of n lattice points is digital convex although convex hull computation requires n logn time even for dimension d 2 we provide an algorithm for testing the digital convexity of s z 2 in o n h log r time where h is the number of edges of the convex hull and r is the diameter of s this main result is obtained by proving that if s is digital convex then the well known quickhull algorithm computes the convex hull of s in linear time in fixed dimension d we present the first polynomial algorithm to test digital convexity as well as a simpler and more practical algorithm whose running time may not be polynomial in n for certain inputs 1 introduction digital geometry is the field of mathematics that studies the geometry of points with integer coor dinates also known as lattice points 1 convexity is a fundamental concept in digital geometry as well as in continuous geometry 2 from a historical perspective the study of digital convexity dates back to the works of minkowski 3 and it is the main subject of the mathematical field of geometry of numbers while convexity has a unique well stated definition in any linear space different definitions have been investigated in z 2 and z 3 4 5 6 7 8 in two dimensions we encounter at least five different approaches called respectively digital line triangle line 4 hv for horizontal and vertical 9 and q for quadrant 10 convexities these definitions were created in order to guarantee that a digital convex set is connected in terms of the induced grid subgraph which simplifies several algorithmic problems the original definition of digital convexity in the geometry of number does not guarantee connec tivity of the grid subgraph but provides several other important mathematical properties such as being preserved under certain affine transformations fig 1 the definition is the following a set of lattice points s zd is digital convex if conv s zd s where conv s denotes the convex hull of s herein we consider the fundamental problem of verifying whether a given set of lattice points is digital convex problem testconvexity s input set s zd of n lattice points given by their coordinates output determine whether s is digital convex or not the input of testconvexity s is an unstructured finite lattice set without repeating elements related work considered more structured data in dimension 2 in which s is assumed to be connected 1 ar x iv 1 90 1 04 73 8 v 1 cs c g 1 5 ja n 20 19 figure 1 shearing a digital convex set example of a set whose connectivity is lost after a linear shear the contour of a connected set s of lattice points is the ordered list of the points of s having a grid neighbor outside s when s is connected it is possible to represent s by its contour either directly as in 11 or encoded as binary word 12 the algorithms presented in 11 12 test digital convexity in linear time on the respective input representations our work however does not make any assumption on s being connected or any particular ordering of the input in this setting a naive approach to test the digital convexity is 1 compute the convex hull conv s of the n lattice points of s 2 compute the number n of lattice points inside the convex hull of s 3 if n n then s is convex otherwise it is not step 1 consists of computing the convex hull of n points the field of computational geometry provides a plethora of algorithms to compute the convex hull of a finite set s rd of n points 13 the fastest algorithms for dimensions 2 and 3 take o n log n time 14 which matches the lower bound in the algebraic decision tree model of computation 15 in dimension d 3 if we also take into consideration the output size h i e the number of vertices of the convex hull the fastest algorithms take o n log h time 16 17 some polytopes with n vertices e g the cyclic polytope have nb d 1 2 c facets therefore any algorithm that outputs this facet description of the convex hull requires nb d 1 2 c time optimal algorithms to compute the convex hull in dimension d 4 match this lower bound 18 step 2 consists of computing the number of lattice points inside a polytope represented by its vertices which is a well studied problem in dimension 2 it can be solved using pick s formula 19 the question has been widely investigated in the framework of the geometry of numbers from ehrhart theory 20 to barvinok s algorithm 21 currently best known algorithms have a complexity of o no d for fixed dimension d 22 as conclusion the time complexity of this naive approach is at least the one of the computation of the convex hull 1 1 results in section 2 we consider the 2 dimensional version of the problem and show that the convex hull of digital convex sets can be computed in linear time our main result is an algorithm for dimension d 2 to solve testconvexity s in o n h log r time where h is the number of edges of the convex hull and r is the diameter of s in section 3 we consider the problem in fixed dimension d we present the first polynomial time algorithm to test digital convexity as well as a simpler and more practical algorithm whose running time may not be polynomial in n for certain inputs 2 digital convexity in 2 dimensions the purpose of this section is to provide an algorithm to test the convexity of a finite lattice s z 2 in linear time in n to this endeavour we show that the convex hull of a digital convex set s can be computed in linear time in fact we show that this linear running time is achieved by the well known quickhull algorithm 23 quickhull is one the many early algorithms to compute the convex hull in dimension 2 its worst case time is o n 2 which makes it generally less attractive than the o n log n algorithm however for certain inputs and variations of the algorithm the average time complexity is reduced to o n log n or o n 13 24 2 figure 2 quickhull initialization points inside the partial hull light brown are discarded the remaining points are potentially part of the hull the quickhull algorithm starts by initializing a convex polygon in the following manner first it computes the top most and bottom most points of the set then it computes the two extreme points in the normal direction of the line supported by the top most and bottom most points those four points describe a convex polygon that we call a partial hull which is contained inside the convex hull of s the points contained in the interior of the partial hull are discarded furthermore horizontal lines and lines parallel to the top most to bottom most line passing through these points describe an outlying bounding box in which the convex hull lies fig 2 the algorithm adds vertices to the partial hull until it obtains the actual convex hull this is done by inserting new vertices in the partial hull one by one given an edge of the partial hull let v denote its outwards normal vector the algorithm searches for the extreme point in direction v if this point is already an edge point then the edge is part of the convex hull otherwise we insert the farthest point found between the two edge vertices discarding the points that are inside the new partial hull throughout this paper we call a step of the quickhull algorithm the computation of the farthest point of every edge for a given partial hull when adding new vertices to the partial hull the region inside the partial hull expands points inside that expansion are discarded by quickhull and herein we name this region discarded region the points that still lie outside the partial hull are preserved and we call the region within which points might still lies preserved region fig 3 we show that quickhull steps takes linear time and that at each step half of the remaining input points of the convex hull is discarded therefore as in standard decimation algorithms the total running time remains linear in section 2 2 we explain how to use this algorithm to test the digital convexity of any lattice set in linear time in n theorem 1 if the input is a digital convex set of n points then quickhull has o n time and space complexities 2 1 proof of theorem 1 we prove theorem 1 with the help of the following lemma lemma 2 the area of the discarded region is larger than the area of the preserved region proof consider one step of the algorithm let ab be the edge associated to the step when a was added to the hull it was as the farthest point in a given direction hence there is no point behind the line orthogonal to this direction going through a fig 3 b the same can be said for b let c be the intersection point of those two lines every point that lies within 4 abc will be fed to the following steps at this step we are looking for the point that is the farthest from the supporting line of ab and outside the partial hull let that point be d fig 4 let e and f be the intersections between the line parallel to ab going through d and respectively ac and bc there are no points from s inside the triangle 4 cef adding d to the partial hull creates two other edges to further be treated one with ad as an edge that will be fed the points inside 4 ade and one with bd as the edge that will be fed the points inside 4 bdf the triangle 4 abd lies within the partial hull therefore 4 abd is the region in which points are discarded fig 4 we established that the preserved lattice points are the lattice points within 4 ade and 4 bdf also 3 a c d b f e a b figure 3 quickhull regions the preserved region region in which we look for the next vertex to be added to the partial hull is a triangle this stays true when adding new vertices to the hull as shown here in the bottom right corner the partial hull whose interior is shown in light brown grows at each vertex insertions to the partial hull the new region added to the partial hull is called discarded region c f e d c 1 c 2 a e 1 f 2 b figure 4 symmetrical regions the next step of the algorithm will only be fed the points inside the dark brown regions search regions each lattice points inside the light brown region discarded region is inside the partial hull and is therefore discarded each search region in dark brown has a symmetrical region either through c 1 or c 2 that lies inside the discarded region furthermore this symmetrical transformation also preserve lattice points the discarded lattice points are those within 4 abd let c 1 be the middle of ad and c 2 be the middle of bd as shown in fig 4 the symmetrical of 4 ade and 4 bdf through respectively c 1 and c 2 both lie inside 4 abd and do not intersect each other hence 4 abd is larger in terms of area than 4 aed 4 bdf remark 1 pick s formula does not apply here since all vertices of the triangle namely c in fig 4 are not necessarily lattice points remark 2 as there is no direct relation between the area of a triangle and the number of lattice points inside it this result is not sufficient to conclude that a constant proportion of points are discarded at each step corollary 3 the reflection of lattice points inside 4 aed and 4 bdf across respectively c 1 and c 2 are lattice points proof the points a b d are lattice points so c 1 and c 2 middle of respectively ad and bd have their coordinates in multiple of half integers hence the reflection of a lattice point across c 1 or c 2 is a lattice point therefore every lattice point within 4 aed has a lattice point reflection across c 1 within 4 ae 1 d and every lattice point within 4 bfd has a lattice point reflection across c 2 within 4 bf 2 d 4 a b de f a b e fd a b e fd d figure 5 lonely points the lattice points without discarded symmetrical counterparts are shown in red on the left if every points inside the triangle is preserved and in the center if the points on the edges of the partial hull are discarded finally on the right a visualization of what happens if we discard all the farthest points and update the partial hull accordingly remark 3 this previous result would prove that half the points are discarded at each step if it were not for the lattice points on the diagonals ad and bd we will now show that quickhull discards at least half of the remaining points at each step hence proving theorem 1 proof we established in corollary 3 that lattice points inside the search regions 4 aed and 4 bfd have symmetrical counterparts inside the discarded region more precisely inside 4 ae 1 d and 4 bf 2 d fig 4 by preserving each points inside 4 aed and 4 bfd at each step we do not have a discarded symmetrical counterpart for the lattice points lying on ad and bd but we do not need to preserve those points since ad and bd are at this step edges of the partial hull removing lattice points from ad and bd implies that in the following step there will be no lattice points on ab leaving lattice points on ef without a discarded symmetrical counterparts fig 5 let actually discard every points on ef since they all are equally farthest from ab in the outer direction they all belong to the hull hence we can add the first and last lattice point on ef to the partial hull fig 5 note that this only takes linear time and does not change the time complexity of each individual step hence at each step of quickhull for every preserved points there is at least a discarded point consequently the number of operations is proportional to n i 0 1 2 i 2 n and quickhull takes linear time for digital convex sets 2 2 determining the digital convexity of a set we showed in theorem 1 that the quickhull algorithm computes the convex hull of digital convex sets in linear time thanks to the fact that at each step quickhull discards at least half of the remaining points by running quickhull on any given set s and stopping the computation if any step of the algorithm discards less than half of the remaining points we ensure both that the running time is linear and that if s is digital convex quickhull finishes and we get the convex hull of s if the computation finishes for s we still need to test its digital convexity to do so we use the previously computed convex hull and compute conv s z 2 using pick s formula 19 the set s is digital convex if conv s z 2 s hence the resulting algorithm 1 theorem 4 algorithm 1 tests digital convexity of any 2 dimensional set s and runs in o n h log r time where h is the number of edges of conv s and r is the diameter of s proof as algorithm 1 runs quickhull but stops as soon as less than half the remaining points have been removed the running time of the quickhull part is bounded by the series n i 0 1 2 i 2 n and is hence linear thanks to theorem 1 we know that the computation of quickhull will not stop for any digital convex sets computing conv s z 2 using pick s formula requires the computation of 5 algorithm 1 isdigitalconvex s input s a set of points output true if s is digital convex false if not 1 while s is not empty do 2 run one step of the quickhull algorithm on s 3 if quickhull discarded less than half the remaning points of s then 4 return false 5 compute conv s z 2 6 if conv s z 2 s then 7 return false 8 return true the area of conv s and of the number of lattice points lying on its boundary which requires the computation of a greatest common divisor hence this takes o h log r time where h is the number of edge of conv s and r is the diameter of s as s is digital convex if and only if s conv s z 2 algorithm 1 effectively tests the digital convexity of a 2 dimensional set in o n h log r time 3 test digital convexity in dimension d we provide two algorithms for verifying the digital convexity in any fixed dimension 3 1 naive algorithm the naive algorithm mentioned in the introduction is based on the following equivalence the set s zd is digital convex if and only if its cardinality is equal to the cardinality of conv s zd in step 1 we compute the convex hull of s in o n log n nb d 2 c time 18 in step 2 we need to count the number of integer points inside conv s the classical algorithm to achieve this goal is known as barvinok algorithm 21 this approach determines only the number of missing points if we want to enumerate the points it is possible to do so through a formal computation of the generating functions used in barvinok algorithm theorem 5 the naive algorithm tests digital convexity in any fixed dimension d and runs in poly nomial time proof computing the convex hull of any set can be done in o n log n nb d 2 c time 18 count ing lattice points inside a convex lattice polytope can be done in polynomial time 22 a direct consequence of the digital convexity definition is that a set s zd is digital convex if and only if s conv s zd hence the naive algorithm tests digital convexity in any fixed dimension d and runs in polynomial time 3 2 alternative algorithm this new algorithm computes all integer points in the convex hull of s with a more direct approach its principle is to enumerate the points x of a finite lattice set s zd surrounding conv s zd conv s zd s in a first variant we count the number of points of s belonging to conv s at the end the set s is convex if and only if conv s zd is equal to the cardinality of s in a second variant for each point of s we test whether it belongs to s and in the negative case we test whether it belongs to the convex hull of s if a point of s s conv s is found then s is not convex we define the set s as the set of points x zd such that the cube x 1 2 1 2 d has a nonempty intersection with the convex hull of s where denotes the minkowski sum it can be easily proved that s is 2 d connected the 2 d neighbors of a lattice point x zd are the 2 d integer points at euclidean distance 1 and by construction it contains s the graph structure induced by the 2 d connectivity on s allows to visit all the points of s efficiently for each point x s we consider 6 figure 6 practical algorithm a lattice set s its convex hull and its dilation by a centered cube of side 1 the intersection of conv s 1 2 1 2 d with the lattice is the set s it is 2 d connected and contains the convex hull of s the principle of the algorithm is either to count the points of s in conv s variant 1 or to search for a point of s s blue points in the convex hull of s variant 2 its 2 d neighbors and test whether they belong to s if they do we add them to the stack of the remaining points of s the goal is to test whether a point of s s is in the convex hull of s then the algorithm has two main routines inconvexhulls tests whether a given point x rd belongs to the convex hull of s it is equivalent with testing whether there exists a hyperplane separating x from the points of s it can be done by linear programming with a worst case time complexity of o n for fixed dimension d 13 inconvexhulls 1 2 1 2 d tests whether a given point x belongs to the convex hull of s 1 2 1 2 d it follows the same principle as inconvexhulls with 2 dn points the time complexity remains linear in fixed dimension this routine is used to test whether an integer point belongs to s the algorithm is the following first we create a stack t of the points of s to visit and initialize it with the set s for each point x in t we remove it from the stack t and label it as already visited then we consider its 2 d neighbors x if x belongs to s and has not been visited previously we add it in the stack t we test whether x belongs to conv s and increment the cardinality of conv s zd accordingly variant 1 or test whether x is in s and conv s and return s not convex if x conv s s variant 2 the running time is strongly dependent on the cardinality of s it is o n s if the size of s is of the same magnitude as the initial set the algorithm runs in o n 2 time it is unfortunately not possible to bound s as a function of n the ratio s s can go to infinity it is easy to build such an example with a set s consisting of only two lattice points for instance for any k z the set s 0 0 1 2 k induces s s k a direction of improvement could be to consider a linear transformation of the lattice zd in order to obtain a more compact lattice set and then a lower ratio s s lll algorithm 25 could be useful to achieve this goal in future work as in the naive algorithm a variant of this approach can be easily developed in order to enumerate the missing points 4 perspectives in this paper we presented an algorithm to test digital convexity in time linear in n for dimension d 2 in higher dimensions our running time depends on the complexity of general convex hull algorithms the questions of whether digital convexity can be tested in linear time in 3 dimensions 7 or faster than convex hull computation in arbitrary dimensions remain open a tentative approach consists of changing the lattice base in order to obtain certain connectivity properties we showed that the convex hull of a digital convex set in dimension 2 can be computed in linear time can the convex hull of digital convex sets be computed in linear time in dimension 3 or more generally what is the complexity of convex hull computation of a digital convex set in any fixed dimension we note that the number of faces of any digital convex set in d dimensions is o v d 1 d 1 where v is the volume of the polytope 26 27 therefore the lower bound of nb d 1 2 c for the complexity of the convex hull of arbitrary polytopes does not hold for digital convex sets 4 0 1 acknowledgement this work has been sponsored by the french government research program investissements d avenir through the idex isite initiative 16 idex 0001 cap 20 25 references 1 reinhard klette and azriel rosenfeld digital geometry geometric methods for digital picture analysis elsevier 2004 2 christian ronse a bibliography on digital and computational convexity 1961 1988 ieee transactions on pattern analysis and machine intelligence 11 2 181 190 february 1989 3 h minkowski geometrie der zahlen number vol 2 in geometrie der zahlen b g teubner 1910 4 chul e kim and azriel rosenfeld digital straight lines and convexity of digital regions ieee transactions on pattern analysis and machine intelligence 4 2 149 153 1982 5 chul e kim and azriel rosenfeld convex digital solids ieee trans pattern anal mach intell 4 6 612 618 1982 6 jean marc chassery discrete convexity definition parametrization and compatibility with continuous convexity computer vision graphics and image processing 21 3 326 344 1983 7 kazuo kishimoto characterizing digital convexity and straightness in terms of length and total absolute curvature computer vision and image understanding 63 2 326 333 1996 8 bidyut baran chaudhuri and azriel rosenfeld on the computation of the digital convex hull and circular hull of a digital region pattern recognition 31 12 2007 2016 1998 9 elena barcucci alberto del lungo maurice nivat and renzo pinzani reconstructing convex polyominoes from horizontal and vertical projections theoretical computer science 155 2 321 347 1996 10 alain daurat salient points of q convex sets international journal of pattern recognition and artificial intelligence 15 7 1023 1030 2001 11 isabelle debled rennesson jean luc re my and jocelyne rouyer degli detection of the dis crete convexity of polyominoes discrete applied mathematics 125 1 115 133 2003 9 th international conference on discrete geometry for computer im agery dgci 2000 12 xavier provenc al christophe reutenauer srecko brlek jacques olivier lachaud lyndon christoffel digitally convex pattern recognition 42 10 2239 2246 2009 selected papers from the 14 th iapr international conference on discrete geometry for computer imagery 2008 13 mark de berg otfried cheong marc van kreveld and mark overmars computational ge ometry algorithms and applications springer verlag telos santa clara ca usa 3 rd ed edition 2008 8 14 andrew chi chih yao a lower bound to finding convex hulls j acm 28 4 780 787 october 1981 15 f p preparata and s j hong convex hulls of finite sets of points in two and three dimensions communications of the acm 20 2 87 93 february 1977 16 d kirkpatrick and r seidel the ultimate planar convex hull algorithm siam journal on computing 15 1 287 299 1986 17 t m chan optimal output sensitive convex hull algorithms in two and three dimensions discrete computational geometry 16 4 361 368 apr 1996 18 bernard chazelle an optimal convex hull algorithm in any fixed dimension discrete com putational geometry 10 4 377 409 dec 1993 19 georg pick geometrisches zur zahlenlehre sitzungsberichte des deutschen naturwissenschaftlich medicinischen vereines fu r bo hmen lotos in prag v 47 48 1899 1900 1899 20 euge ne ehrhart sur les polye dres rationnels homothe tiques a n dimensions technical report acade mie des sciences paris 1962 21 alexander i barvinok a polynomial time algorithm for counting integral points in polyhedra when the dimension is fixed mathematics of operations research 19 4 769 779 1994 22 a i barvinok computing the ehrhart polynomial of a convex lattice polytope discrete computational geometry 12 1 35 48 jul 1994 23 c bradford barber david p dobkin and hannu huhdanpaa the quickhull algorithm for convex hulls acm transactions on mathematical software 22 469 483 1996 24 jonathan scott greenfield a proof for a quickhull algorithm technical report syracuse uni versity 1990 25 arjen k lenstra h w lenstra and l lovasz factoring polynomials with rational coefficients mathematische annalen 261 4 515 534 1982 26 g e andrews a lower bound for the volumes of strictly convex bodies with many boundary points transactions of the american mathematical society 106 270 279 1963 27 i ba ra ny extremal problems for convex lattice polytopes a survey contemporary mathemat ics 453 87 103 2008 9 1 introduction 1 1 results 2 digital convexity in 2 dimensions 2 1 proof of theorem 2 2 determining the digital convexity of a set 3 test digital convexity in dimension d 3 1 naive algorithm 3 2 alternative algorithm 4 perspectives 4 0 1 acknowledgement