ar x iv 1 80 5 11 64 1 v 1 m at h c o 2 9 m ay 2 01 8 classifying rotationally closed languages having greedy universal cycles joseph dimuro may 29 2018 abstract let t n k be the set of strings of length n over the alphabet 1 2 k a universal cycle for t n k can be constructed using a greedy algorithm start with the string kn and continually append the least symbol possible without repeating a substring of length n this construction also creates universal cycles for some subsets s t n k we will classify all such subsets that are closed under rotations let t n k be the set of strings of length n over the alphabet 1 2 k given a subset s t n k we will be interested in finding a universal cycle for s that is a string of length s where each element of s occurs exactly once in that string when it is viewed as a cycle for example we could consider the subset s 1 t 3 5 consisting of ascending strings and their rotations that is s 1 123 124 125 134 135 145 231 234 235 241 245 251 312 341 342 345 351 352 412 413 423 451 452 453 512 513 514 523 524 534 below is a universal cycle for s 1 to make it easier to locate certain strings in the cycle the string 534 is repeated at both the start and the end of the cycle the 534 is put in parentheses at the start as a reminder that the 534 is repeated 534 123124134234512513514523524534 1 http arxiv org abs 1805 11641 v 1 this universal cycle was constructed using a greedy algorithm after choosing 534 as the starting string each subsequent digit was chosen by looking for the smallest digit that could be chosen without duplicating any length 3 substrings except for 534 itself to conclude the cycle as another example consider the subset s 2 t 2 9 consisting of all two digit strings where both the string and its reverse yield composite num bers in base 10 for example 43 6 s 2 because 43 is prime 34 6 s 2 because 34 is the reverse of a prime number s 2 12 15 18 21 22 24 25 26 27 28 33 36 39 42 44 45 46 48 49 51 52 54 55 56 57 58 62 63 64 65 66 68 69 72 75 77 78 81 82 84 85 86 87 88 93 94 96 99 if we try to construct a universal cycle for s 2 using a greedy algorithm starting from 99 here s what we get 99 33621224251526394454648182728496556685758699 unfortunately this cycle isn t quite universal 77 78 87 and 88 are missing this raises the question can we find necessary and sufficient conditions on s t n k so that a universal cycle for s can be generated from a greedy algorithm in this paper we will find such conditions under the assumption that s is closed under rotations 1 results some notational conventions when we are working with a particular set t n k we will use and possibly with subscripts to represent strings in t n k other greek letters like will represent strings in t m k for some m n this includes the possibility of being an empty string latin letters a b etc will represent individual elements of 1 k we will sometimes use exponential notation to write strings with repetitions in a shorter form a couple of examples 253 represents the string 222223 and 4 21 3 represents the string 4212121 given a set s t n k where s 6 let s define the string greedy s as follows let 0 and having defined 0 through j a let j 1 aj 1 where aj 1 is the least element of 1 k such that 2 aj 1 s and aj 1 6 i for all 1 i j the process halts when we reach an m where either m or it is impossible to define m 1 the latter occurs when given m a we have b i m i 1 for all b 1 k such that b s let m be the largest positive integer for which m exists we then define greedy s to be greedy s a 1 a 2 am in the case where the process ends because m the string greedy s may be viewed as a cycle each of the strings from 1 to m appears exactly once in that cycle let g n k be the collection of subsets s t n k such that for some s greedy s is a universal cycle for s that is the length n suffix of greedy s is and for all s is a substring of greedy s treated as a cycle the goal is to find a characterization of the sets in g n k that are closed under rotations given s t n k and given s we will say that is increasable in s to if we can transform into by continually increasing individual symbols and if the resulting string after each such increase is in s by convention we will say that s is increasable in s to for example for our no primes set s 2 t 2 9 57 is increasable in s 2 to 99 57 58 68 69 99 given this definition our ultimate result is the following theorem 1 let s t n k be closed under rotations and let s then is a substring of greedy s treated as a cycle if and only if is increasable in s to a rotation of thus if s t n k is closed under rotations then s g n k if and only if there exists an s such that every s is increasable in s to this theorem explains the absence of 77 78 87 and 88 in the string greedy 99 s 2 none of those four strings are increasable in s 2 to 99 since none of 79 89 97 or 98 is in s note that this theorem is a generalization of theorem 3 from 2 the proof of this result will rely on an analysis of a combinatorial game which we ll call the warden s game the rules for this game will be given in section 2 and the proof of theorem 1 will follow in section 3 in section 4 we will look at several interesting families of sets s t n k where a universal 3 cycle can be generated with the greedy algorithm lastly a possible avenue for future work will be detailed in section 5 2 the warden s game consider the following fanciful scenario there s a certain prison warden who loves playing games he sometimes makes an offer to let his prisoners out of prison if they can beat him at a particular game the game works as follows the warden shows the prisoner a row of n k sided dice on a table on each die the faces are numbered from 1 to k it s possible to have k 2 here the dice would then be coins with a 1 on one side and a 2 on the other a certain string t n k is chosen the prisoner will earn his freedom if after any move the dice on the table are showing the string if the dice are showing at the start of the game the prisoner does not immediately win the prisoner only wins when the dice show after a move this game will be played at a rate of one move per day so the prisoner wants to reach as quickly as possible the warden wants to delay this as long as possible indefinitely if he can each day the rightmost die in the row will be moved to the far left and possibly rotated to show a different number the warden always has priority he may transfer the rightmost die to the far left and lower the number on that die if he doesn t want to do that or he can t because he can t lower the number any further then the warden passes then the prisoner must transfer the rightmost die to the far left and optionally increase the number on that die as an example let n 3 and k 6 so that the game is being played with three 6 sided dice let s say the current position is 513 the leftmost die shows 5 the middle die shows 1 and the rightmost die shows 3 the warden may transfer the rightmost die to the far left lowering its value to 1 or 2 thus producing the position 151 or 251 or the warden may pass in which case the prisoner must transfer the rightmost die and optionally increase its value producing one of the positions 351 451 551 or 651 let s say the warden chooses to move to the position 251 then on the next move the warden can t lower the value showing on the rightmost die so the warden must pass and the prisoner can move to 125 225 325 425 525 or 625 and so on 4 note in the case where k 2 the rules can be stated even more simply if the rightmost coin is showing a 2 the warden transfers that coin and optionally flips it to 1 if the rightmost coin is showing a 1 the prisoner transfers that coin and optionally flips it to 2 we can generalize this game still further by limiting the legal positions in the game we can choose any subset s t n k closed under rotations to be the set of legal positions we ll assume that the goal state is in s then each move of the game whether made by the prisoner or the warden must be to a position in s we require that s be closed under rotations so that there is a legal move from every legal position if the warden ever passes the prisoner always has the option to transfer the rightmost die without changing its value in 3 weiss analyzed the warden s game though not under that name in the case where k 2 s t n 2 and is the string 2 n weiss proved that the game tree for the game is summarized by the lexicographically min imal de bruijn sequence for t n 2 if both players play optimally the game will proceed backwards through the de bruijn sequence one move at a time for example if n 4 the lexicographically minimal de bruijn sequence is the following 2222 1111211221212222 for this game consider the position 2212 if we move one step backwards in the de bruijn sequence from 2212 we get 1221 thus the optimal move from 2212 must be for the warden to flip the rightmost coin before moving it producing the position 1221 similarly the next optimal move is for the prisoner to move from 1221 to 1122 and so on until the goal position 2222 is finally reached as we will prove in section 3 the same holds true for any values of n and k any subset s t n k of legal positions closed under rotations and any goal state s the greedy algorithm always generates the full game tree for the warden s game as an example let s once again consider the subset s 2 t 2 9 consisting of those strings where both the string itself and its reverse are 2 digit composite numbers here once again is the not quite universal cycle generated by the greedy algorithm starting from 99 99 33621224251526394454648182728496556685758699 for example consider the position 82 the preceding substring of length 5 2 is 18 thus the optimal move must be for the warden to move the rightmost die and reduce its value from 2 to 1 the next optimal move must be to 81 both the prisoner and the warden refuse to change the value on the rightmost die the next optimal move is to 48 which means the warden passes and the prisoner increases the value on the rightmost die from 1 to 4 and so on remember four positions from s 2 do not appear in this cycle 77 78 87 and 88 why don t they appear because they are losing positions for the prisoner from any of those positions the warden has a simple way to keep the game going indefinitely he refuses to ever decrease the value on a die and passes every time the prisoner will never be able to increase a die to a 9 because 79 89 97 and 98 are all illegal positions so the prisoner will never be able to reach the goal state 99 our goal for the next section is to prove that this sort of thing happens regardless of the choices of s and we will show that the prisoner can win from a given position s if and only if he can win from with the warden always passing this happens when is increasable in s to a rotation of we will also show that the greedy algorithm generates the game tree for this game thus the greedy algorithm generates a universal cycle if and only if every s is increasable in s to a rotation of 3 proof of theorem 1 assume we are given values of n and k a set s t n k of legal positions closed under rotations and a goal state s define the remoteness function r on s as follows given s the remoteness of r is the number of moves the game will last starting from if both players play optimally if the warden can keep the game going forever then r this definition of remoteness is similar to the concept of remoteness used in 1 note we can consider to either be an end position of remoteness 0 or a start position of nonzero remoteness we will always use the notation r for the number of moves the game will last starting from thus r 0 lemma 1 let 1 2 s be such that 1 a and 2 a for a a thus if the current position is 1 and the warden passes then the prisoner may move to 2 then starting from 1 the prisoner has a strategy which can force the position to eventually reach 2 6 proof this can be proven by induction on the sum of the symbols in 1 starting from 1 b 1 b 2 bn 1 a if the warden passes then the prisoner may move immediately to 2 otherwise the warden must move to 3 a b 1 b 2 bn 1 for some a a but the sum of the symbols of 3 is less than the sum of the symbols of 1 so by the inductive hypothesis the prisoner has a strategy to eventually force the position to bn 1 a b 1 bn 2 then to bn 2 bn 1 a b 1 bn 3 and so on to b 1 b 2 bn 1 a we still have a smaller sum than the sum of the symbols in 1 so the prisoner can eventually force the position to 2 a b 1 b 2 bn 1 since a a lemma 2 given s the prisoner can win from if and only if is increasable in s to a rotation of proof if is not increasable in s to a rotation of then the warden can keep the game going indefinitely simply by passing on every turn since the prisoner can only increase values if the warden always passes the prisoner will only be able to reach positions where is increasable in s to a rotation of since is not such a position the prisoner can never win now assume that is increasable in s to a rotation of then if the warden chooses to pass on every move then there is a sequence of moves 0 1 2 m that the prisoner may make to win by lemma 1 if the game starts from 0 then prisoner can eventually force the position to be 1 then 2 and so on until finally reaching and winning note while this shows that the prisoner can win eventually from any position that is increasable in s to the recursive strategy described above will probably not be the prisoner s optimal strategy lemma 3 given any positive integer m if there are no positions of remote ness m then there are no positions of remoteness m 1 thus by induction there are no positions of remoteness m for any integer m m proof if there were a position of remoteness m 1 then with optimal play the first move from such a position would be to a position of remoteness m and no such position exists so there are no positions of remoteness m 1 lemma 4 given positions a 1 a 2 s if a 1 a 2 then r a 1 r a 2 7 the point here is that the greater the rightmost symbol in the string the better off the warden is from a 1 the warden may move to any a s such that a a 1 or the warden may give the prisoner the choice to move to any a s where a a 1 from a 2 the warden still may move to any a s such that a a 1 or the warden can ensure that the next move is to a s for some a a 1 but in the latter case the warden may choose a specific a s such that a 1 a a 2 if he so desires this extra option can only help the warden never hurt him so we must have r a 1 r a 2 note we will later see that if r a 1 and r a 2 are both finite then r a 1 r a 2 lemma 5 for any nonnegative integer m there is at most one position of remoteness m this is a significant result combined with lemma 3 the conclusion is that the game tree is really a chain not a tree there is one position of remoteness 0 namely one position of remoteness 1 one position of remoteness 2 and so on until all the winning positions for the prisoner have been exhausted and given any position that is winning for the prisoner if a game starting from is played optimally the game will pass through all positions of remoteness less than r until finally reaching proof we will prove this by contradiction let m be the smallest integer where there are multiple positions of remoteness m there is only one po sition of remoteness 0 namely so m 1 let a be the one position of remoteness m 1 this position must be reachable in one move from all positions of remoteness m so all such positions must have the form b let b 1 b 2 bl be the elements of 1 2 k such that bi s for each i by lemma 4 r b 1 r b 2 r bl if j is the smallest natural number such that r bj m then because there is just one position of each remoteness less than m we must have r b 1 r b 2 r bj 1 r bj r bj 1 for each i j let ai be the next position reached from bi if both sides play optimally the ai s for 1 i j are all distinct we can now show that it is impossible to have r bj r bj 1 m consider the two sets ai j i 1 and bi j i 1 if these two sets are identical then consider what happens if the warden passes from the position bj 1 8 the prisoner is then forced to move to a for some a bj 1 this a will not be an element of ai j i 1 and hence a will not have remoteness at most m 1 so by passing the warden can force the next move to be to a position of remoteness at least m bj 1 can t have remoteness m on the other hand assume ai j i 1 and bi j i 1 are not identical that means there is some bi bj 1 that is not in ai j i 1 if the warden moves from bj 1 to bi then the warden has not moved to a position of remoteness at most m 1 so again the warden was able to force the next move to be to a position of remoteness at least m bj 1 can t have remoteness m this completes the contradiction it is impossible to have two positions of the same finite remoteness lemma 6 if s is the goal state then the position in s of highest finite remoteness is the reason since is trivially increasable in s to a rotation of r is finite say r m 0 we are treating as a start position not an end position if there were any position such that r m 1 then with optimal play the next move from would be to a position of remoteness m namely but that means with optimal play is just one move from the goal state so r 1 not m 1 thus has the maximal finite remoteness of any string in s this also means that the positions in s that are winning for the prisoner form a cycle the only question remaining is why this is the same cycle that we would get from the greedy algorithm theorem 2 the greedy algorithm generates the game tree for the warden s game proof let m s be the sequence of strings generated by the greedy algorithm starting from we have 0 and for each m 0 if m a then m 1 b where b is the least element of 1 k such that b s and b does not appear in the set i m i 1 if b i m i 1 for all b 1 k then there is no m 1 m is the last string in the sequence obviously 0 is the one position of remoteness 0 we must show that r m m for all m 0 we will prove this by induction assume we have r i i whenever 0 i m let m a assume there is a position of remoteness m 1 it must be of the form b s so that there is a move available to a where b is not in i m i 1 since all 9 strings in that set have remoteness m or less let b 1 b 2 bj be the elements of 1 k such that bi s but bi is not in i m i 1 thus m 1 b 1 by lemma 4 r b 1 r b 2 r bj by lemma 5 all of those inequalities are strict except for where we have multiple positions of infinite remoteness we have r b 1 m so the only i where we can have r bi m 1 is i 1 thus we must have r m 1 r b 1 m 1 now assume that m is the largest finite remoteness of any position in s that is r m the above inductive argument shows that m and the way we defined greedy s the process halts if we ever have m so we do have r m m for all m 0 the length n substrings of greedy s are exactly the winning positions for the prisoner in order of remoteness we thus have proven theorem 1 the length n substrings of greedy s are exactly the winning positions for the prisoner which are exactly the strings in s which are increasable in s to a rotation of as a final note for this section here s a comment on the optimal strategy for the warden corollary 1 given any position b s if a is the greatest number less than b such that a s then the optimal move for the warden from b is either to move to a or to pass so when the warden does decrease a number he should always do so by the smallest amount possible proof assume not assume there is a position b s where a is the greatest number less than b where a s but the warden s optimal move is to c where c a let r b m then the remoteness of c is m 1 where if c we are treating as an end position since s is closed under rotations and a s we have a s from lemmas 4 and 5 since a b we have r a r b so r a m but from the position a the warden can move to c a position of remoteness m 1 so r a m contradiction there seems to be no similar statements we can make about the opti mal strategy for the prisoner depending on the situation the prisoner may want to increase the value on a die by the least amount possible the greatest amount possible or some amount in between for example all such possib lities occur in our no primes example s 2 t 2 9 there seems to be no way for the prisoner to determine anything about his optimal next move from other than to generate the entire string greedy s until is reached 10 4 interesting examples in 2 there are a number of examples of interesting sets s t n k where the greedy algorithm produces a universal cycle for s here are some new such sets derived from theorem 1 4 1 strings increasable to a rotation of choose any t n k and let s t n k be the strings that are in creasable in t n k to a rotation of obviously s is then closed under rotations given any s is increasable in t n k to a rotation of so there are strings 0 1 m t n k such that 0 m is a rotation of and each i can be changed to i 1 by increasing one symbol then each i is increasable in t n k to a rotation of so each i s but that means is actually increasable in s to a rotation of since this is true for all s the greedy algorithm starting from generates a universal cycle of s for example let n 3 k 4 and 143 here s a universal cycle for the strings in t 3 4 increasable to a rotation of 143 143 1112113122123132133141142143 note we get the same collection of strings if is either 314 or 431 but the resulting universal cycle would be different in either such case here s the universal cycle for 314 314 1112113114212213214312313314 and here s the universal cycle for 431 431 1121131221231321331411421431 4 2 unions let s 1 s 2 g n k where s 1 and s 2 are both closed under rotations as sume all strings in s 1 and s 2 are increasable in their respective sets to rotations of a single string then all strings in s 1 s 2 are increasable in s 1 s 2 to a rotation of so the greedy algorithm starting from generates a universal cycle of s 1 s 2 11 this raises the question of whether the same can be said of intersections however this turns out to be false even if the greedy algorithm generates universal cycles for s 1 and s 2 the same may not be true of s 1 s 2 one simple example will demonstrate why let s 1 s 2 t 2 3 be as follows s 1 11 13 31 33 s 2 11 12 21 23 32 33 the greedy algorithm starting from 33 generates universal cycles for both s 1 and s 2 but does not do so for s 1 s 2 11 33 the problem is that there may be an element s 1 s 2 which is increasable to a rotation of in both s 1 and in s 2 but the paths from to may be different in each set here 11 we have 11 13 33 in s 1 and 11 12 32 33 in s 2 4 3 rotations of increasing strings assume that n k let s be the set containing all strictly increasing strings in t n k and their rotations for example in t 3 5 s contains the following strings and their rotations 123 124 125 134 135 145 234 235 245 345 by definition s is closed under rotations let be the lexicographically maximal strictly increasing string in t n k k n 1 k n 2 k 1 k any string s is increasable in s to a rotation of the greatest symbol in can be increased to k then the next greatest symbol can be increased to k 1 and so on so a universal cycle for s can be generated with the greedy algorithm 4 4 maximum cyclic increment or cyclic decrement choose integers i 0 and d 0 let s t n k be the set of strings with no cyclic increment of size greater than i and no cyclic decrement of 12 size greater than d for example if we take t 3 4 i 2 and d 1 then s consists of the following strings and their rotations 111 112 122 132 222 223 233 243 333 334 344 444 by definition s is closed under rotations let kn contains no cyclic increments or decrements so s to show that the greedy algorithm works here choose any s such that 6 kn assume 1 a 2 where a is the least symbol in let 1 a 1 2 this change from to will either decrease the size of cyclic increments decrements or will produce a new cyclic increment or decrement of size 1 which is legal so s thus for any s it s possible to increase a symbol of by 1 to produce another string in s this process can be continued until is reached so any s is increasable in s to and the greedy algorithm starting from produces a universal cycle 4 5 minimum span maximum span choose integers m and m such that 0 m m k let s t n k be the set of strings whose span is at least m and at most m the span of a string is the difference between the least and greatest symbols in for example if we take t 3 4 m 1 and m 2 then s consists of the following strings and their permutations 112 113 122 123 133 223 224 233 234 244 334 344 clearly s is closed under rotations any s can be increased in s to a rotation of k m kn 1 as follows if the span of is greater than m increase the least symbol of by 1 if the span of equals m increase the greatest symbol of by 1 unless the greatest symbol is k repeat this process until a string containing the symbol k is reached at that point the least symbol in will be k m leave that one symbol alone and increase all the other symbols of to k thus the greedy algorithm generates a universal cycle for s 4 6 avoiding a substring choose a string t m k for some m 1 and let s t n k be the set of strings that do not contain as a cyclic substring it was proven 13 in 2 that if does not contain k then s can be generated by the greedy algorithm if does contain k then we can still make a weaker statement let i j 1 k be two symbols such that i j if contains i but not j then s can be generated by the greedy algorithm as an example let s t 3 3 be the set of strings not containing 13 as a cyclic substring in this case i 1 and j 2 then s consists of the rotations of the following strings 111 112 122 123 222 223 233 333 the reason why the greedy algorithm works kn s since the forbidden substring includes a symbol a k given any s we can increase in s to kn as follows replace any occurrences of a in with b then increase all symbols in to k so all strings in s are increasable in s to kn it would seem to be a difficult question to completely categorize the for bidden substrings for which s can be generated by the greedy algorithm i have not found any examples of a forbidden substring containing a symbol a k 2 where the greedy algorithm fails and i would conjecture that there are none conjecture 1 let t m k be a string containing a symbol a k 2 let s t n k for some n m be the set of strings not containing as a cyclic substring then the greedy algorithm starting from kn generates a universal cycle for s now if all symbols in are either k or k 1 then the greedy algorithm may fail let s t n 9 for some n 4 be the set of strings not containing a particular as a cyclic substring i leave it as an exercise to the interested reader to show that the greedy algorithm starting from 9 n succeeds if is in the following set 8899 8989 but the greedy algorithm fails if is in the following set 89 889 899 8889 8999 note for some strings the outcome depends on the value of n one example is 8998 the greedy algorithm will fail if and only if n is a multiple of 3 all strings in s will be increasable in s to 9 n except for 889 n 3 and its rotations 14 5 conclusion and future work necklaces at this point we have classified the subsets s t n k closed under ro tations where the greedy algorithm produces a universal cycle for s but there s one major problem with generating universal cycles with the greedy algorithm we must store the entire cycle which could be exponential in length in order to generate the cycle fortunately when s t n k there is a faster method given t n k is a necklace if out of all rotations of itself is the lexicographically earliest such rotation if we take all such necklaces in lexicographic order and append their aperiodic prefixes we obtain a de bruijn cycle for t n k the same cycle produced by the greedy algorithm for example here s the resulting universal cycle for t 3 3 with spaces added between the prefixes 333 1 112 113 122 123 132 133 2 223 233 3 in 2 this is called the fkm algorithm it is proved in 2 that this algorithm produces a universal cycle for s t n k the same universal cycle produced by the greedy algorithm if 1 s is closed under rotations and 2 every necklace in s remains a necklace in s if the suffix of length i whenever 1 i n is replaced with ki when this second condition holds true s is referred to as a k suffix language however this is not an if and only if situation the following example of a set s t 4 3 is given in 2 s 1112 1121 1122 1211 1212 1221 1222 1322 2111 2112 2121 2122 2132 2211 2212 2213 2221 3221 not all necklaces in s remain in s when a suffix is replaced with all 3 s how ever the fkm algorithm works here the necklaces in s in lexicographic order are 1112 1122 1212 1222 and 1322 reduce 1212 to its aperiodic prefix 12 then concatenate all the strings and you obtain a universal cycle 1322 1112 1122 12 1222 1322 15 so it is natural to ask whether there is a necessary and sufficient condition on s t n k so that the fkm algorithm generates a universal cycle for s i have a possible candidate for just such a condition let s generalize the concept of a k suffix language as follows given a string t n k call a set s t n k an suffix language if for any s each symbol in is at most the corresponding symbol in and we obtain another element of s if we replace any suffix of with an equal length suffix of that is if b 1 bn and a 1 an then for all m such that 1 m n we have bm am and b 1 bm 1 am an s with this definition in place i would conjecture the following conjecture 2 let s t n k be a set that is closed under rotations then the fkm algorithm generates a universal cycle for s if and only if the set of necklaces in s is an suffix language where is the lexicographically maximal necklace in s the reason for this conjecture assume that s t n k is closed under rotations and is an suffix language where is the lexicographically max imal necklace in s under these circumstances it appears that the prisoner has a strategy such that if the current position is a necklace s the prisoner can ensure that the next necklace position reached is lexicograph ically earlier than thus in the universal cycle generated by the greedy algorithm the necklaces appear in lexicographic order perhaps then the fkm algorithm generates the same cycle as the greedy algorithm references 1 e berlekamp j conway and r guy winning ways for your mathe matical plays vol 2 a k peters ltd natick ma 2003 2 j sawada a williams and d wong generalizing the classic greedy and necklace constructions of de bruijn sequences and universal cycles the electronic journal of combinatorics 23 1 2016 p 1 24 3 g weiss a combinatorial game approach to state nullification by hybrid feedback in 46 th ieee conference on decision and control 2007 16 1 results 2 the warden s game 3 proof of theorem 1 4 interesting examples 4 1 strings increasable to a rotation of 4 2 unions 4 3 rotations of increasing strings 4 4 maximum cyclic increment or cyclic decrement 4 5 minimum span maximum span 4 6 avoiding a substring 5 conclusion and future work necklaces