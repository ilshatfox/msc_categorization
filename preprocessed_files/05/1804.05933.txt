ar x iv 1 80 4 05 93 3 v 1 m at h c o 1 6 a pr 2 01 8 unimodal polynomials and lattice walk enumeration with experimental mathematics by bryan ek a dissertation submitted to the school of graduate studies rutgers the state university of new jersey in partial fulfillment of the requirements for the degree of doctor of philosophy graduate program in mathematics written under the direction of doron zeilberger and approved by new brunswick new jersey may 2018 http arxiv org abs 1804 05933 v 1 abstract of the dissertation unimodal polynomials and lattice walk enumeration with experimental mathematics by bryan ek dissertation director doron zeilberger the main theme of this dissertation is retooling methods to work for different situations i have taken the method derived by o hara and simplified by zeilberger to prove unimodality of q binomials and tweaked it this allows us to create many more families of polynomials for which unimodality is not a priori given i analyze how many of the tweaks affect the resulting polynomial ayyer and zeilberger proved a result about bounded lattice walks i employ their generating function relation technique to analyze lattice walks with a general step set in bounded semi bounded and unbounded planes the method in which we do this is formulated to be highly algorithmic so that a computer can automate most if not all of the work i easily recover many well known results for simpler step sets and discover new results for more complex step sets ii acknowledgements i would like to thank my advisor doron zeilberger for his direction he provided several fun projects to work on that resulted in this dissertation i would also like to thank cole franks for his edits and suggestions and thank you to michael saks for his discussion and comments on my work that provided many insights for further analysis thank you to my committee for serving as such thank you to my friends for the welcome diversions and a big thank you to my whole family for supporting me along this journey this research was funded by a smart scholarship usd r e the under secretary of defense research and engineering national defense education program ndep ba 1 basic research iii dedication dedicated to my wife kaitlin iv table of contents abstract ii acknowledgements iii dedication iv list of tables viii list of figures ix 1 introduction 1 2 unimodal polynomials 4 2 1 introduction 4 2 1 1 motivation 4 2 1 2 symmetric and unimodal 6 2 1 3 partitions 10 2 1 4 chapter organization 10 2 2 maple program 11 2 3 q binomial polynomials 12 2 4 original recurrence 13 2 5 altered recurrence 19 2 5 1 restricted partitions 19 2 5 2 adjusted initial conditions 35 2 5 3 adjusted recursive call 35 2 6 oeis 37 2 7 conclusion and future work 39 v 3 lattice walk enumeration 41 3 1 introduction 41 3 1 1 motivation 42 3 1 2 definitions 43 3 1 3 chapter organization 45 3 2 bounded 47 3 2 1 walking anywhere 47 3 2 2 returning to the x axis 49 3 3 semi bounded 52 3 3 1 arbitrary lower limit 57 3 3 2 meanders 58 3 4 guess and check method 60 3 5 algebraic to recursive 62 3 5 1 conversion 62 3 5 2 searching 65 3 6 unbounded 69 3 6 1 walking anywhere 69 3 6 2 returning to the x axis 70 3 6 3 alternative method 72 3 6 4 selected step sets 73 3 6 5 time comparison 76 3 7 asymptotics 79 3 7 1 discriminant 83 3 7 2 meanders 84 3 8 applications 86 3 8 1 combining solutions 86 3 8 2 weighted walks 87 3 8 3 2 step examples 88 3 9 conclusion and future work 93 vi 4 conclusion 96 references 97 vii list of tables 2 1 unimodal sequences from the oeis 38 3 1 bounded walk enumeration 49 3 2 bounded bridge enumeration 1000 terms 51 3 3 500 term excursion enumeration 56 3 4 1000 term excursion enumeration 57 3 5 1000 term meander enumeration 60 3 6 finding excursion minimal polynomial s 1 2 1 1 1 0 1 1 1 2 61 3 7 finding meander minimal polynomial s 1 2 1 1 1 0 1 1 1 2 62 3 8 enumerating excursions more efficiently 63 3 9 enumerating meanders more efficiently 64 3 10 alternative recurrence step set 1 2 1 3 65 3 11 alternative recurrence step set 1 2 1 1 1 0 1 1 1 2 66 3 12 alternative recurrence step set 1 1 3 1 1 0 3 0 2 1 1 2 2 2 68 3 13 finding minimal polynomial s 1 2 1 1 1 0 1 1 76 3 14 finding minimal polynomial s 1 2 1 1 1 0 1 1 1 2 77 3 15 1000 term unbounded enumeration 78 viii list of figures 2 1 contributions from different partitions to produce g 5 5 26 3 1 walk examples 44 ix 1 chapter 1 introduction humans have been counting for millennia whether it was to keep track of how many berry bushes remained to gather from how many people lived in their village or how many days it had been since the water froze a single person could simply count the bushes or people or days the important jump for society was to communicate that number one of the earliest methods was tally marks in ancient babylon 5 000 years ago the abacus arose as a method of subtracting and adding numbers in shorthand a classic tale of gauss intellect is how he solved the grade school busy work problem of adding the numbers from 1 to 100 which can be generalized to adding any sequence of numbers with constant difference zeilberger used recurrences and properties of unimodal polynomials inspired by o hara to show that the q binomials are unimodal zei 89 a he and ayyer also used generating function relations to prove a result about polymers bounded between plates az 07 in addition to the important specific results the previous examples provide something more consequential the system of obtaining the result to the cavemen the amount of food left was probably their top priority but what they began paved the way for more complex analysis 1 of our world the methods allow for a solution to not just the original question or task but with simple tweaks can answer much more for many early questions particularly gauss busywork we can have a computer brute force a result but while computers are faster much faster than us they still take nonzero time for even the simplest computations over the years we have created machines that can compute faster and faster but instead of computing faster we want to compute smarter 1 and eventually complex analysis 2 we could go through the process of solving a system of 1 000 linear equations and variables by hand but that would take forever computers are very good at doing simple things quickly the important facet is the method and set up process to allow the computer to do its thing this is the methodology of experimental mathematics to use computers efficiently for mathematical investigations the more data we gather the easier it is to draw insights computing has come quite a long way for mathematics the main theme of this dissertation is retooling methods to work for different situations as a part of this retooling we have made two major maple packages for demonstrations of the various devices we begin by delving into unimodal polynomials the first chapter is all about how we can tweak a single recurrence that proves unimodality for the q binomial coefficients into a source of many more unimodal polynomials the recurrence provided by zeilberger zei 89 b and inspired by o hara o h 90 is given and several adjustments are introduced how these adjustments affect the final polynomial are explored for most of the chapter the unimodal polynomial chapter was produced in conjunction with the maple package gnk available at math rutgers edu bte 14 code gnk gnk txt the package provides for quick enumeration of families of unimodal polynomials as well as a few functions for insight into the background work the second chapter is on the subject of lattice walks given a certain set of allowable steps in a 2 d lattice none of which move to the left how many ways are there to walk between points in the plane to tackle this question i use generating function relations motivated by ayyer and zeilberger az 07 for walks bounded above and below we are guaranteed to find an exact expression for the generating function a rational function for more general walks we are only guaranteed to find a polynomial for which the generating 3 function is a root in terms of formal power series for some polynomials this means we can give an exact expression but in general the minimal polynomial is the best we or anyone can do the lattice walk chapter was produced in conjunction with the maple package scoringpaths available at math rutgers edu bte 14 code scoringpaths scoringpaths txt within this package are all of the procedures needed to generate the mentioned results automatically there are several different ways we can enumerate the walks this chapter discusses them their pros and cons and the specific methods of enumeration are included in scoringpaths 4 chapter 2 unimodal polynomials 2 1 introduction this chapter is available as a stand alone paper on arxiv org number 1711 11252 it has been submitted to the journal of difference equations and applications the q binomial coefficients were conjectured to be unimodal as early as the 1850 s but it remained unproven until sylvester s 1878 proof using invariant theory in 1982 proctor gave an elementary proof using linear algebra finally in 1989 kathy o hara provided a combinatorial proof of the unimodality of the q binomial coefficients very soon thereafter doron zeilberger translated the argument into an elegant recurrence we introduce several perturbations to the recurrence to create a larger family of unimodal polynomials we analyze how these perturbations affect the final polynomial and analyze some specific cases 2 1 1 motivation the study of unimodality and log concavity arise often in combinatorics eco nomics of uncertainty and information and algebra and have been the subject of considerable research aar 00 intuitively many sequences seem to be unimodal but how does one prove that fact we will review some methods of building unimodal sequences as well as a few lemmas that imply unimodality knowing a sequence is unimodal allows for guaranteed discovery of the global extremum using an easy search algorithm unimodality is also useful for probability applications 5 identifying a probability distribution as unimodal allows certain approximations for how far a value will be from its mode gauss inequality gau 23 or mean vysochanskij petunin inequality dfv 80 suppose we start with a set of nice combinatorial objects that satisfy property p how can we make the set larger and still satisfy property p or a slightly different property p the goal of this project is to use reverse engineering to obtain highly non trivial surprising theorems about unimodality example 2 1 all of the following functions are not only polynomial for n 0 0 0 4 4 respectively but they are also unimodal p 1 n 1 qn 1 1 q p 2 n 1 q 2 n 1 1 q p 3 n 2 q 3 n 2 2 q 3 n 1 q 3 n q 2 n 1 qn 1 q 2 2 q 2 1 q 2 p 4 n 5 q 4 n 2 5 q 4 n 1 3 q 4 n 2 3 q 4 n 3 4 q 4 n 4 4 q 2 n 3 4 q 2 n 1 4 q 6 3 q 5 3 q 4 5 q 5 1 q 2 p 5 n 2 q 5 n 3 4 q 5 n 2 7 q 5 n 1 5 q 5 n 5 q 5 n 3 5 q 5 n 4 4 q 5 n 5 4 q 5 n 6 6 q 5 n 9 6 q 5 n 10 3 q 5 n 11 5 q 4 n 2 5 q 4 n 1 4 q 4 n 2 4 q 4 n 3 3 q 4 n 4 5 q 3 n 4 5 q 3 n 3 3 q 3 n 2 6 q 3 n 4 6 q 3 n 5 3 q 3 n 6 3 q 2 n 9 6 q 2 n 8 6 q 2 n 7 3 q 2 n 1 5 q 2 n 5 q 2 n 1 3 qn 7 4 qn 6 4 qn 5 5 qn 2 5 qn 1 3 q 14 6 q 13 6 q 12 4 q 9 4 q 8 5 q 7 5 q 6 5 q 3 7 q 2 4 q 2 1 q 3 6 example 2 2 the following functions are all unimodal for n 0 q 1 n 4 1 qn 1 1 q q 2 n 5 8 q 2 n 4 2 qn 3 2 qn 2 8 q 3 q 5 1 qn q n q 4 q qn q n 2 q 1 q 1 q 2 q 3 n 16 3 3 q 16 q 2 16 qn 1 16 qn 3 16 qn 5 16 q 2 n 3 16 q 2 n 5 16 q 2 n 7 16 q 3 n 6 3 q 3 n 7 3 q 3 n 8 1 1 n q 3 n 9 2 8 q 17 8 q 16 64 q 15 9 q 14 55 q 13 60 q 11 57 q 10 125 q 9 125 q 8 57 q 7 60 q 6 55 q 4 9 q 3 64 q 2 8 q 8 1 1 n q 3 n 9 2 8 q 17 8 q 16 64 q 15 9 q 14 73 q 13 60 q 11 65 q 10 3 q 9 3 q 8 65 q 7 60 q 6 73 q 4 9 q 3 64 q 2 8 q 8 1 1 n q 3 n 6 2 12 q 14 12 q 13 64 q 12 75 q 11 74 q 10 127 q 9 127 q 5 74 q 4 75 q 3 64 q 2 12 q 12 1 1 n q 3 n 6 2 12 q 14 12 q 13 64 q 12 53 q 11 74 q 10 q 9 q 5 74 q 4 53 q 3 64 q 2 12 q 12 4 1 q 2 1 q 6 q 3 is truly amazing it appears quite unwieldy and at first glance one might doubt that it has real coefficients but for any nonnegative integer n q 3 n is guaranteed to be a unimodal polynomial in z q try simplifying q 3 assuming n is even odd one can obtain further simplifications assuming n 0 1 2 3 mod 4 2 1 2 symmetric and unimodal we recall several definitions and propositions from zeilberger zei 89 a for the sake of com pleteness definition 2 3 unimodal a sequence a a 0 an is unimodal if it is weakly increasing up to a point and then weakly decreasing i e there exists an index i such that a 0 a 1 ai an definition 2 4 symmetric a sequence a a 0 an is symmetric if ai an i for every 0 i n 7 a polynomial is said to have either of the above properties if its sequence of coefficients has the respective property definition 2 5 darga the darga of a polynomial p q aiq i ajqj with ai 6 0 6 aj is defined to be i j i e the sum of its lowest and highest powers darga is equal to 2 c p used by brent bb 90 example 2 6 darga q 2 3 q 3 5 and darga q 2 4 proposition 2 7 the sum of two symmetric and unimodal polynomials of darga m is also symmetric and unimodal of darga m proposition 2 8 the product of two symmetric and unimodal nonnegative 1 polynomials of darga m and m is a symmetric and unimodal polynomial of darga m m proof a polynomial is symmetric and unimodal of darga m if and only if it can be ex pressed as a sum of atomic entities of the form c qm r qm r 1 qr for some positive constant c and integer 0 r m 2 by proposition 2 7 it is enough to prove that the product of two such atoms of dargas m and m is symmetric and unimodal of darga m m qm r qr qm r qr qm m r r 2 qm m r r 1 2 qr r 1 qr r proposition 2 9 if p is symmetric and unimodal of darga m then q p is symmetric and unimodal of darga m 2 one example is the binomial polynomial 1 x m it is symmetric and unimodal of darga m definition 2 10 nonnegative bra 15 if h x is a symmetric function in its coeffi cients then we can write h x m 2 k 0 kx k 1 x m 2 k we call k m 2 k 0 the vector of h if the vector is nonnegative h is said to be nonnegative 1 nonnegative is necessary 1 x x 2 2 1 2 x 3 x 2 2 x 3 x 4 8 one can use propositions 2 7 2 8 and 2 9 to prove that nonnegative implies sym metric and unimodal of darga m example 2 11 to prove the polynomials in example 2 1 are actually unimodal one can show p 1 n n i 0 qi p 2 n p 1 2 n p 3 n 2 p 1 3 n q 2 p 1 2 n 2 p 1 n 2 p 4 n 5 p 1 4 n 3 q 4 p 2 2 n 4 4 q 6 p 1 2 n 4 p 2 n 4 p 5 n 2 p 1 5 n 5 q 2 p 1 4 n 2 p 1 n 2 4 q 8 p 2 2 n 6 p 1 n 4 5 q 6 p 1 3 n 4 p 2 n 4 3 q 12 p 1 2 n 6 p 3 n 6 and then use propositions 2 7 2 8 and 2 9 along with the property that darga pk n nk one must initially assume n 0 0 2 4 6 respectively but the k 3 5 bounds can be lowered by checking smaller values of n manually example 2 12 to prove the polynomials in example 2 2 are in fact unimodal one can show q 1 n 4 n i 0 qi q 2 n q 2 q 2 n 2 5 q 1 2 n q 3 n q 6 q 3 n 4 3 q 1 3 n 4 q 2 q 1 2 n 2 q 1 n 2 and then use induction on n for q 2 q 3 with base cases n 0 1 0 1 2 3 respectively and propositions 2 7 2 8 and 2 9 along with the property that darga qk n nk the wonderful aspect about these proofs is that they can be easily verified by computer being able to write a function in decomposed form allows us to quickly verify the unimodal nature of each part and hence the sum however the combined form generally does not lead to an obvious decomposition this is the motivation behind using reverse engineering to guarantee that the decomposed form exists 9 real rootedness and log concavity the following properties are greatly related to unimodality but turn out to not be applicable in our situation they are included for completeness of discussion definition 2 13 real rootedness the generating polynomial pa x a 0 a 1 q anq n is called real rooted if all its zeros are real by convention constant polynomials are considered to be real rooted definition 2 14 log concavity a sequence a a 0 an is log concave convex if a 2 i ai 1 ai 1 a 2 i ai 1 ai 1 for all 1 i n there is also a notion of k fold log concave and infinitely log concave with open problems that may be of interest to the reader bra 15 proposition 2 15 the hadamard term wise product of log concave convex sequences is also log concave convex lemma 2 16 bra nde n bra 15 let a ak nk 0 be a finite sequence of nonnegative numbers if pa x is real rooted then the sequence a ak n k nk 0 is log concave if a is log concave then so is a if a is log concave and positive 2 then a is unimodal for a self contained proof using less general and possibly easier to understand results see lecture 1 from vatter s algebraic combinatorics class vat 09 which uses the book a walk through combinatorics bo n 06 the converse statements of lemma 2 16 are false there are log concave polynomials that are not real rooted and there are unimodal polynomials which are not log concave bra nde n also references a proof by stanley sta 89 that lemma 2 17 if a x b x are log concave then a x b x is log concave and if a x is log concave and b x is unimodal then a x b x is unimodal 2 nonnegative is not sufficient 1 0 0 1 is log concave and log convex but not unimodal 10 it is not sufficient for a b to be unimodal 3 q q 2 2 9 6 q 7 q 2 2 q 3 q 4 3 2 1 3 partitions definition 2 18 partition a partition of k is a non increasing sequence of positive integers a 1 a 2 as s t s i 1 ai k we will use frequency representation ab 11 a b 2 2 a br r s t ai ai 1 and bi 0 to abbreviate repeated terms and 98 4 note now that r i 1 aibi k there is possible ambiguity as to whether xy is x repeated y times or xy counted once we always reserve exponentials in partitions to indicate repetition the size of a partition denoted will indicate the number of parts 5 in standard notation s in frequency notation r i 1 bi di is the number of parts of size i in the partition in frequency notation dai bi k indicates is a partition of k we will use to denote a partition unless otherwise stated is a partition of k 2 1 4 chapter organization this chapter is organized in the following sections section 2 maple program briefly describes the accompanying maple package section 3 q binomial polynomials describes the original interesting polynomials section 4 original recurrence introduces the recurrence that generates the q binomial polynomials and simultaneously proves their unimodality we briefly discuss properties of the recurrence itself section 5 altered recurrence modifications are injected into the recurrence that still maintain unimodality for the resulting polynomials we examine the effects 3 stanley sta 89 incorrectly writes the coefficient of q 3 as 1 4 if bi 1 it is omitted 5 many papers use k to denote what partitions 11 various changes have this section contains most of the reference to new unimodal polynomials section 6 oeis uses some of the created unimodal polynomials to enumerate sequences for the oeis 6 section 7 conclusion and future work provides avenues for future research 2 2 maple program the backbone of this paper is based on experimental work with the maple package gnk available at math rutgers edu bte 14 code gnk gnk txt i will mention how functions are implemented throughout this paper using implemented as for help with any function type help function the most important function is kohgeneral it modifies the original recurrence in eqn 2 3 in several different ways using this function one can change the recurrence call multiply the summand by any manner of constant restrict the types of partitions or even hand pick which partitions should be weighted most highly the key part of these changes is that the solution to the recurrence remains symmetric and unimodal of darga nk math rutgers edu bte 14 code gnk polynomials contains examples of many non trivial one variable rational functions that are guaranteed to be unimodal polynomials for n n 0 they were created using the kohrecurse function and restricting the partitions summed over in 2 3 to have smallest part 1 2 3 4 and distance 1 2 3 4 in decomposed form they are clearly unimodal but in combined form one is hard pressed to state unimodality with certainty the impressive polynomials in examples 2 1 and 2 2 were generated byrandomthe oremandproof it uses the recurrence in eqn 2 3 with random multiplicative constants in each term the parameters were n q 5 5 0 false and n q 3 5 0 true respectively 6 online encyclopedia of integer sequences nei 12 initially q 3 n was an even larger behemoth this will typically happen when maple solves a recurrence equation so going beyond k 3 and complicated true is not recommended unless one wants to spend substantial time parsing the polynomial into something much more readable or better yet one could come up with a way for maple to do this parsing automatically there are functions to test whether a polynomial is symmetric unimodal or both issymmetric p q isunimodal p q issymuni p q respectively as an extra take away generalpartitions outputs all partitions restricted to a minimum maximum integer size as well as difference 7 and congruence requirements one can also specify a finite set of integers which are allowed in genpartitions 2 3 q binomial polynomials of particular interest among unimodal polynomials are the q binomial polynomials n k q implemented as qbin n k q the q binomials are analogs of the binomial coefficients in the limit q 1 we obtain the usual binomial coefficients we parametrize q binomial coefficients in order to eliminate the redundancy n k q n n k q g n k g k n n k k q n k q n q k q 1 qn 1 1 qn k 1 q 1 qk 2 1 implemented as gnk n k q n q 1 qn 1 q is the q bracket n q n i 1 i q denotes the q factorial 8 implemented as qfac n q it is non trivial that g n k is even a polynomial for integer n k polynomial is proven since g n k satisfies the simple recurrence relation g n 1 k 1 qk 1 g n k 1 g n 1 k 2 2 this recurrence also shows that g n k is the generating function for the number of parti tions in an n k box a partition either has a part of largest possible size qk 1 g n k 1 or it does not g n 1 k to prove this one can simply check that g n k does satisfy 7 consecutive parts in the partition differ by d 8 the q factorial is the generating polynomial for the number of inversions over the symmetric group sn bra 15 13 this recurrence as well as the initial conditions g n 0 1 g 0 k 9 this argument also confirms g n k g k n 10 the question of unimodality for the q binomial coefficients was first stated in the 1850 s by cayley and then proven by sylvester in 1878 bra 15 the first elementary proof was given by proctor in 1982 he essentially described the coefficients as partitions in a box grid shading problem and then used linear algebra to finish the proof pro 82 lemma 2 16 does not apply here q brackets and q factorials are in the class of log concave use lemma 2 17 but not real rooted for n 1 polynomials while these g n k polynomials are in the class of unimodal but not necessarily log concave polynomials for example g 2 2 1 q 2 q 2 q 3 q 4 is unimodal but not log concave in fact most q binomial polynomials are not log concave since the first and last 2 coefficients are 1 explicitly g n k is log concave k 1 2 4 original recurrence the symmetric and structured nature of g n k and its coefficients is visually muddled by the following recurrence that zeilberger zei 89 a created to translate o hara s o h 90 combinatorial argument 11 to mostly algebra g n k d 1 dk k i 1 idi k qk k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i 2 3 is implemented as koh n k q the product is part of the summand and the outside sum is over all partitions of k di is the number of parts of size i in the partition the 9 the coefficients are symmetric since each partition of inside an n k box corresponds to a partition of nk 10 g n k k also counts the number of subspaces of dimension k in a vector space of dimension n over a finite field with q elements 11 her argument is rewritten explained by zeilberger zei 89 b 14 initial conditions 12 are g n 0 k 0 g n k 0 0 g 0 k 1 g n 0 1 g n 1 1 qn 1 1 q 2 4 by using propositions 2 7 2 8 and 2 9 and induction on the symmetric unimodality of g a b for a n or b k we can see after a straightforward calculation that the right hand side is symmetric and unimodal of darga nk for each partition the darga will be 2 k k i 1 di k 1 j i k i j didj k 1 i 0 k i n 2 i 2 i 1 j 0 i j dk j dk i nk recall that k i 1 idi k one is led to ask how long this more complicated recurrence will take to compute what is the largest depth of recursive calls that will be made in eqn 2 3 this is answered with a brute force method in kohdepth kohcalls returns the total number of recursive calls made but is there an explicit answer we will use n k to denote the new n k in the recursive call for a given partition we sometimes also treat them as functions of the index n i k i n 2 i 2 i 1 j 0 i j dk j once a partition only has distinct parts the recurrence will cease after a final recursive call since each k 1 therefore to maximize depth we need to maximize using partitions with repeated parts and maximize the size of n k one method is to begin by using k 2 2 with a 0 1 as needed and the recursive call with i k 2 then since k dk i 2 repeatedly use the partition 1 2 and i 1 this method calls g k k 2 n 2 k 2 2 k 2 1 j 0 k 2 j dk j dk k 2 g k 2 n 2 k 2 2 k 2 1 j 0 0 d k 2 g k 2 n 2 k 2 2 12 g n 1 is explicitly given because eqn 2 3 only yields the tautology g n 1 g n 1 15 then using the partition 12 and i 1 calls g n 2 2 thus the total depth of calls is k 2 n 2 k 2 2 1 k 2 n 2 k 2 1 in fact lemma 2 19 if k 1 2 or if k 4 is even odd and n 2 n 4 then the maximum depth of recursive calls is k 2 n 2 k 2 1 for k 3 the maximum depth of recursive calls is n 4 proof base case k 1 there are no recursive calls 1 2 n 2 1 2 1 0 n 2 1 1 0 for k 2 the only option that yields recursive calls is 12 and i 1 g n 2 2 thus we will have n 2 2 2 n 2 2 2 1 recursive calls which matches with expected for k 3 the only recursive call that does not immediately terminate is 13 and i 2 the call is g 3 2 n 2 2 2 2 1 j 0 2 j d 3 j d 3 2 g n 4 3 thus we will have n 4 recursive calls the difference from other k arises because 3 2 1 first consider k even and n 2 by proposition 2 20 the depth is 1 kn 4 k 2 1 k 2 n 2 k 2 1 now let k 4 and n 3 n 4 if k odd assume true for n k s t k k or k k and n n what if we repeat part m 2 times the recursive call uses i k m g k k m n 2 k m 2 k m 1 j 0 k m j dk j dm g mn 2 k 2 m 2 k j m 1 j m dj 16 by the induction hypothesis the depth of this call is note ml k 1 2 2 mn 2 k 2 m 2 k j m 1 j m dj 2 1 l 2 l 2 mn 2 k 2 m 2 k j m 1 jdj 2 1 2 2 mn 2 k 2 m 2 k m 2 1 2 2 m n 2 2 2 1 2 m n 2 2 4 1 2 k n 2 2 4 the upper bound is maximized when is minimized 2 upper bound kn 4 k 2 we now need to confirm that k 2 2 with 1 if needed i k 2 achieves this upper bound the depth is 1 2 2 2 2 k 2 n 2 k 2 k 2 2 k 2 n 2 k 2 2 k 2 n 2 k 2 which for k even directly matches the upper bound for k odd we adjust the upper bound by recognizing that if even then m k 1 and splitting into 2 cases 1 k j m 1 jdj 0 then the depth of the call is 1 2 2 mn 2 k 2 m 2 k j m 1 j m dj 2 1 2 m n 2 2 k 4 1 2 k 1 n 2 2 k 4 maximized for 2 and gives an upper bound k 1 n 2 4 k 4 k 1 n 4 k 1 2 17 2 k j m 1 jdj 0 then m k m 1 k 2 and the depth of the call is 1 2 2 mn 2 k 2 m 2 k j m 1 j m dj 2 1 2 mn 2 k 2 m 2 k m 2 m 4 1 2 m n 2 4 1 2 k 2 n 2 4 which again is maximized for 2 and gives an upper bound k 2 n 4 4 k 1 n 4 k 1 2 2 k n 10 4 k 1 n 4 k 1 2 since k 4 and n 2 13 the upper bound from either case matches the achievable bound for k odd if odd then the earlier 2 2 can be replaced by 1 2 thus the upper bound is 1 2 m 1 n 2 2 4 1 2 k 1 n 2 2 4 which is now maximized by 3 since we assume odd 14 giving the upper bound k 1 n 4 4 1 which is worse 15 than the bound when 2 so we can ignore odd when it comes to maximizing depth therefore our chosen and i achieve the greatest depth 1 k 2 n 2 k 2 to confirm that this recursive depth actually happens we must also confirm that g n k 6 0 for any other i i e we must show that n 0 for i k 2 n k i n 2 i 2 i 1 j 0 i j dk j k i n 2 i k k 2 n 2 k 2 k 2 n 2 k 2 0 since n 3 when k even and since n 4 when k odd for i k 2 n k i n 2 i 2 i 1 j 0 i j dk j k i n 2 i 2 i k 2 2 k i n 2 i 4 k 2 kn i n 2 4 k 2 kn k 1 n 2 4 k 2 kn kn n 2 k 2 4 k 2 n 2 2 k 4 k 2 13 actually we have k odd so k 5 and n 4 the bound improves further 14 actually 5 since we ignore 3 15 we only need k 1 18 which for k even is 0 since n 3 and for k odd n 0 since n 4 by induction the claim holds for all n k we have glossed over a few details we assumed that k 6 3 if 3 then this would lead to a different shallower recursive call than 2 n 4 n 2 2 2 n 2 2 2 1 we also need to ensure that if k 4 then n 3 or n 4 as needed actually if k 4 and n 3 n 4 then by proposition 2 20 their depth is 1 and since the extra depth of using k 2 2 with 0 1 as needed is 16 k 2 n 2 k 2 1 2 produces a recursive call that is at least as deep proposition 2 20 if k even then for n 1 2 the maximum depth of recursive calls is 1 if k 3 is odd then for n 1 2 3 the maximum depth is 1 proof consider a partition that repeats part m 2 times first consider n 2 the recursive call with i k m is n mn 2 k 2 m 2 k j m 1 j m dj 4 m 2 k 2 k j m 1 j m dj 4 m 2 k 2 k m m 4 2 m 4 4 0 thus the chain terminates after at most 1 step for all other partitions distinct we already know the chain terminates after 1 step now consider k odd and n 3 note that dk 0 otherwise we have a distinct partition the recursive call with i k 1 is n k k 1 3 2 k 1 2 k 1 1 j 0 k 1 j dk j 5 2 k 2 k 1 j 0 k j dk j 2 k 1 j 0 dk j 5 2 k 2 k 2 k 1 j 0 dk j 5 2 k j 1 dj 0 16 recall that k 4 and n 3 n 4 actually this is the only spot that needs n 3 when k even otherwise n 2 is sufficient 19 if 3 thus the only partitions that actually create recursive calls are those with 2 and since k odd will be distinct and therefore terminate after at most 1 step the explicit depth formula is implemented as kohdepthfast n k it is some what odd that the depth is not symmetric in n k g n k is symmetric so we can choose to calculate g k n if n k and have a shallower depth of recursive calls the total number of calls may be the same this was not analyzed 2 5 altered recurrence 2 5 1 restricted partitions we can alter the recurrence of eqn 2 3 in several ways to create g n k and maintain the property that g n k is symmetric and unimodal of darga nk 17 one simple way to do this is to restrict the partitions over which we sum this simply reduces the use of proposition 2 7 we can restrict the minimum maximum size of a partition min max integer in a partition distinct parts modulo classes etc suppose we restrict to partitions with size s and denote this new function as gs gs n k d 1 dk k i 1 idi k k i 1 di s q k k i 1 di k 1 j i k i j didj k 1 i 0 gs k i n 2 i 2 i 1 j 0 i j dk j dk i d 1 dk k i 1 idi k k i 1 di s q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i for k s gs n k g n k since all partitions of k will have size s and since dk i s by definition of the sum we can replace gs by g the actual q binomial in the product i found conjectured recurrence relations of order 1 and degree 1 in both n k for s 1 2 3 4 i then conjectured for general s 17 dependent on restrictions one may achieve g n k 0 20 conjecture 2 21 qn qk s 1 gs n 1 k qk 1 qn qs 2 gs n k 1 qn qk s 1 gs n 1 k 1 0 2 5 eqn 2 5 was verified for n k 20 and s 10 the bounds were chosen to make the verification run in a short time 2 minutes in the algebra of formal power series taking the limit as s thus obtaining the original g n k with no restriction recovers qn 1 g n 1 k qk 1 qn g n k 1 qn g n 1 k 1 0 g n 1 k qk 1 g n k 1 g n 1 k 1 which matches the recurrence relation in eqn 2 2 recall that gs n k g n k for k s it is somewhat surprising that g n k follows many recurrence relations for bounded k we can try to enumerate all gs n k using a translated eqn 2 5 gs n k 1 qn qk s 1 qn qk s 1 1 gs n k 1 qk qn qs 1 gs n 1 k implemented as gs s n k q however this recurrence by itself cannot enumerate all gs n k as we will eventually hit the singularity causing n k s 1 if n s however we do obtain an interesting relation along that line gs k s k 1 qk 1 1 qk s gs k s 1 k 1 or gn k 1 n 1 k 1 qk 1 1 qn 1 gn k 1 n k 1 so far eqn 2 5 has been verified for s 1 2 3 using the explicit formulas in eqns 2 6 2 9 and 2 10 respectively it is quite remarkable that the generalized recurrence in eqn 2 5 yields polynomials using the initial conditions of eqn 2 4 18 let alone unimodal polynomials are there other sets of initial conditions potentially for chosen values of s that will also yield unimodal polynomials when iterated in eqn 2 5 19 18 gs n 0 gs 0 k 1 19 at least until the singularity 21 there are a couple of avenues for attack of conjecture 2 21 a good starting place may be to tackle the easier question of whether the recurrence even produces symmetric polynomials since we have base case verification we could try to use induction to prove the conjec ture this would likely involve writing gs 1 gs gs 1 where gs 1 is the contribution from all of the partitions of size s 1 gs 1 n k d 1 dk k i 1 idi k k i 1 di s 1 qks 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i another possibility since we have an explicit expression for gs and for g if needed may be to simply plug in to eqn 2 5 and simplify cleverly a more general question would be to analyze recurrences of type a n k f n 1 k 1 b n k f n 1 k c n k f n k 1 that produce symmetric and unimodal polynomials what are the requirements on a b c if a 1 b 1 c 1 and a 2 b 2 c 2 both produce unimodal polynomials what if anything can be said about a 1 a 2 b 1 b 2 c 1 c 2 about a 1 a 2 b 1 b 2 c 1 c 2 if one can build from previously known valid recurrences one could potentially build up to eqn 2 5 from eqn 2 2 natural partitions lemma 2 22 suppose we restrict partitions to only use integers p if p 2 k n 2 then g n k 0 20 proof we have di 0 for i p in the product of eqn 2 3 consider i k 1 for any 20 the bound n 2 2 k p is sufficient to make g n k 0 22 restricted partition then for the new n in the recursive call we obtain n k 1 k k 1 n 2 k 1 2 k 1 1 j 0 k 1 j dk j n 2 k 1 2 k 2 j k p k 1 j dk j n 2 k 1 2 p j 2 k 1 k j dk k j n 2 k 1 2 p j 1 j 1 dj n 2 k 1 2 k 2 n 2 2 k p n 2 2 k p n 2 2 k 2 k n 2 0 then g n d 1 0 for any partition and therefore g n k 0 0 what do other natural partitions yield for a recursive call let us first consider 1 k then d 1 k and di 6 1 0 q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i qk k kg n 2 k 1 k k 2 i 0 g k i n 2 i 2 i 1 j 0 i j 0 0 qk k 1 g n 2 k 1 k k 2 i 0 g k i n 2 i 0 qk k 1 g n 2 k 1 k since k i n 2 i 2 n 2 k 2 and if 2 n 2 k 2 0 then n 2 k 1 0 if we define g n k as only being over partitions 1 k then g n k qnk 2 if 2 k 1 n and 0 otherwise one can confirm the monomial by either looking at how many times qk k 1 is multiplied or by recognizing that g n k must be a monomial of darga nk 23 now consider k then dk 1 and di 6 k 0 qk k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i qk kg kn 1 k 1 i 1 g k i n 2 i 2 i 1 j 1 i j dk j 2 i 0 dk 0 g kn 1 k 1 i 1 g k i n 0 g nk 1 1 qnk 1 1 q since k i n n 0 so k provides the base of g n k 1 q qnk if we restrict to partitions of size 1 then g 1 n k 1 qnk 1 1 q 2 6 we can use this to verify the recurrence relation in eqn 2 5 for s 1 lemma 2 23 let us restrict partitions to those with distinct parts fix k n let 1 2 8 k 1 1 21 then g n k is a polynomial of degree k in qn for n 2 2 22 proof since k is distinct g n k is of degree k in qn let be a partition with distinct parts then di 1 and k j 1 dk l and for each recursive call g n di 0 1 or 1 qn 1 1 q since k is fixed it has a fixed number of partitions into distinct parts thus it remains to show g n di 6 0 by showing n i 0 for all i n i k i n 2 i 2 i 1 j 0 i j dk j n i n i 1 2 i 1 j 0 i j dk j 2 i 1 j 0 i j dk j 2 i 2 j 0 dk j 2 dk i 1 n 2 2 i 1 j 0 dk j n 2 2 n 2 0 21 i e the index of the largest triangular number k or the maximum size of a distinct partition of k 22 it appears that n 2 3 also fits the polynomial though this was left unproven 24 thus the minimum occurs at i k 1 and has value n k 1 k k 1 n 2 k 1 2 k 1 1 j 0 k 1 j dk j n 2 k 1 2 k 1 j 0 k 1 j dk j n 2 k 1 2 k 1 j 0 k j dk j 2 k 1 j 0 dk j n 2 k 1 2 k 2 k 1 j 0 dk j n 2 2 0 let us return to the minimum of n for general partitions it occurs either at i k 1 or if n 2 2 2 of 1 s in then at the final i s t n 2 2 i 1 j 0 dk j see the simplification of n i n i 1 above the second difference is n i 2 n i 1 n i 2 2 dk i 1 0 thus the extrema of n found is in fact a minimum and if we fix the i such that there exists a minimum or equivalent to the minimum we obtain a value of k i n 2 i 2 i 1 j 0 i j dk j k i 2 i 1 j 0 dk j 2 2 i 2 i 1 j 0 i j dk j 2 i 1 j 0 k j dk j 2 k 2 k 2 k 0 to avoid the approximation step consider the next i k i 1 n 2 i 1 2 i j 0 i 1 j dk j k i 1 2 i j 0 dk j 2 2 i 1 2 i j 0 i 1 j dk j 2 i j 0 k j dk j 2 k 2 k 2 k 0 the recursive call is then seen to be 0 for any partition that has 1 s in n 2 2 25 now we consider k for some 1 k 2 q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 2 k k k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j 0 g k n 2 2 1 j 0 j dk j dk k 1 i 1 g k i n 2 i 2 i 1 j 0 i j dk j 0 g k k n 2 k 2 k 1 j 0 k j dk j d k 1 i k 1 g k i n 2 i 2 i 1 j 0 i j dk j 0 q 2 1 i 0 g k i n 2 i 0 g k n 2 1 k 1 i 1 g k i n 2 0 g n 2 1 k 1 i k 1 g k i n 2 i 2 k 0 which to be nonzero requires that assuming n 2 otherwise we get 0 in the recursive call 0 k i n 2 i k 1 n 2 1 2 1 2 2 1 4 and 0 k i n 2 k k 1 n 2 1 n 2 2 and 0 k i n 2 i 2 k k k 1 n 2 k 1 2 k n 2 0 the leftmost inequality is what we need and the other inequalities deduce that to be true thus the recursive call is q 2 1 q k n 2 1 1 q 1 q n 2 1 1 q 26 for a visual of how the different partitions can contribute to the final polynomial see figure 2 1 figure 2 1 contributions from different partitions to produce g 5 5 the partitions 15 and 2 13 both contribute the 0 polynomial lemma 2 24 if we restrict to partitions with consecutive difference k d and d 2 3 k 1 then the coefficient of qnk 2 in g n k is nd d 1 2 d 2 1 for d d 2 proof the bound on d implies that the maximum size of a partition is 2 by proposition 2 25 d can be seen to be the relevant number because it is the number of possible size 2 partitions of k k k 1 1 k d d are valid since k d d k 2 d 2 k d 27 then g n k 1 qnk 1 1 q d i 1 q 2 i 1 q k i n 2 i 1 1 q 1 q in 2 i 1 1 q 2 7 note that the middle coefficient of 1 qa 1 q 1 qb 1 q is going to be min a b also note that the darga of the summand in eqn 2 7 is 2 2 i k i n 2 i 1 1 in 2 i 1 1 nk so qnk 2 is the middle monomial 23 thus the coefficient is 1 d i 1 min k i n 2 i 1 in 2 i 1 1 d i 1 in 2 i 1 1 2 n 2 d 2 d 1 proposition 2 25 if we restrict to partitions with difference k d and minimum part then to have a partition of size s it is required that d k s 1 s 2 s s 1 2 s 1 ds 2 ks 2 ds ks 2 k 2 s k ds d 2 s s 1 s 2 proof a partition of size s minimum part and difference k d will have total k s i 1 i s i 1 i 1 k d s 2 2 k d k d s 23 as one should expect since the summand of eqn 2 7 is a specific case of the summand in eqn 2 3 28 size 2 partitions another special partition to consider is k 2 2 when k is even then dk 2 2 and di 0 otherwise q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 2 k k 0 k 2 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i g k k 2 n 2 k 2 2 k 2 1 j 0 k 2 j dk j dk 2 k 1 i k 2 1 g k i n 2 i 2 i 1 j 0 i j dk j dk i qkg k 2 n k 2 k 2 1 i 0 g k i n 2 i 0 k 1 i k 2 1 g k i n 2 i 2 i k 2 2 0 qkg k 2 n k 2 k 2 1 i 0 g k i n 2 i 0 k 1 i k 2 1 g k i n 2 i 2 k 0 which is nonzero only if assuming n 2 otherwise we get 0 in the recursive call 0 k i n 2 i k k 2 1 2 2 k 2 1 k 2 1 2 k 2 4 0 k i n 2 i 2 k k k 1 n 2 k 1 2 k n 2 0 thus the recursive call is qkg k 2 n k 2 while proving lemma 2 24 maple produced this useful gem d i 1 q 2 i 1 q k i n 2 i 1 1 q 1 qin 2 i 1 1 q q 2 1 qnk 2 d 1 q 2 d 1 q 2 1 q 2 qn 1 1 qnk nd n 1 qnd 1 q 2 1 qn 2 8 we can then look at using only partitions restricted to maximum size 2 the possible partitions are k and k for 1 k 2 we can find the exact form of g 2 n k by including all partitions with size 2 29 lemma 2 26 for n 1 g 2 n k qnk n 4 qnk n 3 qnk n 1 qnk 4 q n 1 k n 3 q n 1 k 3 qk n 1 qk 1 qn q 3 q 1 1 q 2 1 q 2 1 qn 2 9 if n 0 then g 2 0 k 1 proof if k odd then utilizing eqn 2 8 g 2 n k 1 qnk 1 1 q k 1 2 1 q 2 1 q k n 2 1 1 q 1 q n 2 1 1 q 1 qnk 1 1 q q 2 1 qnk 2 k 1 2 1 q 2 k 1 2 1 q 2 1 q 2 qn 1 1 qnk n k 1 2 n 1 qn k 1 2 1 q 2 1 qn 1 qnk 1 1 q q 2 1 qnk k 1 1 qk 1 1 q 2 1 q 2 qn 1 1 q n k 1 1 q 2 1 qn if k even then g 2 n k 1 qnk 1 1 q k 2 1 1 q 2 1 q k n 2 1 1 q 1 q n 2 1 1 q qkg 2 k 2 n k 2 1 qnk 1 1 q q 2 1 qnk k 2 1 qk 2 1 q 2 1 q 2 qn 1 1 q nk 2 1 qn k 2 2 1 q 2 1 qn qk 1 qnk 2 k 1 1 qnk 2 k 2 1 q 1 q 2 we again utilized eqn 2 8 and noted that g 2 n 2 g n 2 and used eqn 2 1 one can use maple or any other mathematics software to verify that both cases simplify to the expression given above notice also that the bound of n 2 required from characterizing partition calls has been lowered to n 1 if n 1 then the size 2 partition calls will be 0 which is exactly what the extra summands reduce to we can use this to verify the recurrence relation in eqn 2 5 for s 2 to compute g 2 n k using the explicit expression use g 2 n k q 30 the expression given in eqn 2 9 obfuscates that g 2 n k is unimodal of darga nk the expanded expressions in the proof allow for a heuristic argument by reasoning the darga of each summand this would be a great way to prove unimodality of general functions however the useful decomposition is often difficult to ascertain size 3 partitions by looking at 1 2 3 k for the separate cases 1 2 3 1 2 6 3 1 6 2 3 and 1 6 2 6 3 one can add this to lemma 2 26 and find an explicit expression for g 3 n k we start with 1 6 2 6 3 then d i 1 we will need n 4 for nonzero calls qk k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 2 2 2 3 k 1 1 i 0 g k i n 2 i 0 g 1 n 2 2 3 1 k 2 1 i k 1 1 g k i n 2 k 1 0 g 2 n 2 2 3 1 k 3 1 i k 2 1 g k i n 2 2 3 0 g 3 n 4 1 k 1 i k 3 1 g k i n 4 0 q 2 2 2 3 1 q 1 n 2 2 3 1 1 q 1 q 2 n 2 2 3 1 1 q 1 q 3 n 4 1 1 q 31 now k 2 2 for k 3 then dk 2 1 d 2 again we need n 4 q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 6 2 1 i 0 g k i n 2 i 0 g k 2 n 4 1 k 1 i 2 1 g k i n 4 0 g n 4 2 k 1 i k 1 g k i n 4 0 q 6 1 q k 2 n 4 1 1 q 1 q n 4 1 1 q n 4 2 1 q 1 q 2 we continue by analyzing 2 k 2 for k 2 k 3 then d 2 dk 2 1 n 4 is needed as usual q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 4 k 6 k 1 i 0 g k i n 2 i 0 g n 2 k 2 2 2 1 i k 1 g k i n 2 i 4 k 0 g k 2 n 8 4 k 1 k 1 i 2 1 g k i n 4 0 q 4 k 6 1 q n 2 k 2 1 1 q n 2 k 2 2 1 q 1 q 2 1 q k 2 n 8 4 k 1 1 q 32 finally consider k 3 3 for k 0 mod 3 then dk 3 3 again we need n 4 q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i q 2 k 2 k 3 1 i 0 g k i n 2 i 0 g n 4 k 3 3 k 1 i 2 k 3 1 g k i n 4 0 q 2 k 1 q n 4 k 3 1 1 q n 4 k 3 2 1 q n 4 k 3 3 1 q 1 q 2 1 q 3 lemma 2 27 for n 2 g 3 n k q 4 k q 3 1 qn q qn q 3 k q 1 q 1 qn q q 2 q 5 qn q 2 k qnk q 2 n q 9 q 8 q 7 q 6 q 5 q 3 q qn q 10 q 8 q 6 q 5 q 10 q 2 n qn q 5 q 4 q 2 1 q 9 q 7 q 5 q 4 q 3 q 2 q qk qnkq 3 1 q 1 qn q 5 qn qn 3 qn 4 qnkq 6 1 qn q qn 1 q 2 1 q 2 2 1 q 3 1 qn 1 1 qn q 2 k 1 2 10 for n 2 g 3 n k g 2 n k proof for n 4 g 3 n k g 2 n k k 3 1 3 1 k 3 1 2 2 3 1 q 2 2 2 3 1 q k 3 2 n 2 2 3 1 1 q 1 q 2 n 2 2 3 1 1 q 1 q 3 n 4 1 1 q k 1 3 1 q 6 1 q k 2 n 4 1 1 q 1 q n 4 1 1 q n 4 2 1 q 1 q 2 k 1 2 k 1 3 q 4 k 6 1 q n 2 k 2 1 1 q n 2 k 2 2 1 q 1 q 2 1 q k 2 n 8 4 k 1 1 q the first nested summation is for the distinct size 3 partitions the other 2 sums are for partitions of type k 2 and k 2 respectively if k 0 mod 3 then for the 33 k 3 3 partition we need to add the extra term q 2 k 1 q n 4 k 3 1 1 q n 4 k 3 2 1 q n 4 k 3 3 1 q 1 q 2 1 q 3 amazingly maple is able to simplify the above expression into closed form once one makes assumptions about k mod 6 it is also necessary to divide the first sum into 2 parts based on the parity of l 3 in the divided sum we are replacing 3 by 2 3 1 and 2 3 respectively k 3 1 2 3 1 k 2 3 2 2 3 q 2 2 2 2 3 1 1 q k 2 3 1 2 n 2 2 2 3 3 1 q 1 q 2 n 2 2 2 3 3 1 q 1 q 2 3 1 n 4 1 1 q k 1 2 3 2 2 3 1 q 2 2 4 3 1 q k 2 3 2 n 2 2 2 3 1 1 q 1 q 2 n 2 2 2 3 1 1 q 1 q 2 3 n 4 1 1 q if k 0 1 2 mod 6 then k 3 1 1 mod 2 and so we need to add the final inner sum when 3 k 3 1 k k 3 2 2 k 3 q 2 2 2 k 3 1 1 q k 2 k 3 1 n 2 2 k 3 3 1 q 1 q 2 n 2 2 k 3 3 1 q 1 q k 3 1 n 4 1 1 q for each k 0 5 mod 6 the decomposition simplifies to the same result eqn 2 10 24 if n 4 then the additions from size 3 partition calls will all be 0 see the character ization of size 3 partition calls above and so g 3 n k g 2 n k it is a simple exercise to check that the difference evaluates to 0 when n 2 3 the difference between the two 24 this was only fully done for the k 5 mod 6 case however the other cases were partly simplified and found to be in agreement empirically after removing the assumption on k mod 6 all cases still gave the same result and the explicit formula in eqn 2 10 matches the polynomials found by recursion for all n 2 30 and k 0 30 if the reader does not wish to take our word for it they are encouraged to show the other cases for themselves we highly recommend using maple or another computer assistant if you do not have time to waste 34 polynomials is given by g 3 n k g 2 n k q 4 k q 2 1 qn q qn q 3 k q 1 q 1 qn qn 3 qn 2 qn q 3 q 2 k q q 3 qn qnk qn 1 q 3 q 2 1 qn q 3 q 1 q 2 qk qnkq 3 1 q 1 qn 1 q q 3 qn qnkq 5 1 qn q qn 1 q 2 1 q 2 2 1 q 3 1 qn 1 1 qn q 2 k we can use this result to verify the recurrence relation in eqn 2 5 for s 3 to compute g 3 n k for numeric n k using the explicit expression use g 3 n k q because we will always have k s it is possible to automate the process of finding gs n k for any s and have it terminate in finite time characterize all of the new size s partitions and add their contributions to gs 1 n k however the number of new types of partitions to consider grows exponentially as 2 s 1 each new part is either the same as the previous part or smaller also the partitions become more and more complex to describe one general partition that we can tackle is k then dk and the recursive call is q k k i 1 di k 1 j i k i j didj k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j dk i qk 1 k 1 1 i 0 g k i n 2 i 0 g k n 2 k 1 k 1 i k 1 1 g k i n 2 i 2 i k 1 0 qk 1 g k n 2 1 which to be nonzero requires that n 2 1 35 the final functions found in lemmas 2 26 and 2 27 are by no means obviously unimodal if one instead writes them in decomposed form they can be reasoned to be unimodal by looking at the darga of each term knowing the proper decomposition beforehand allows for easy proof of unimodality but finding any decomposition is typically extremely difficult this is the motivation behind reverse engineering 2 5 2 adjusted initial conditions we can also multiply each recursive call by constant factors or multiply initial conditions while still maintaining base case darga nk g n 0 k 0 g n k 0 0 g 0 k g n 0 g n 1 1 qn 1 1 q 2 11 we can also adjust the recursive call on each k by multiplying it by need not be constant it can be a function of the largest part of or even more generally each gets its own specific value we choose to normalize the final answer by dividing by k and when it is constant so that we do not have arbitrary differences even after normalizing there will still be differences from g n k though we have not yet found meaningful results using the techniques of this section we are hopeful that in the future we can find a pattern for the difference between the largest and second largest coefficients 2 5 3 adjusted recursive call a more complex method is to adjust the recursive call we return to using the initial conditions in eqn 2 4 g n k a b c d 1 dk k i 1 idi k q k k i 1 di k 1 j i k i j didj qka k i 1 di b c k k 1 n 2 a k k 2 b k i 1 dii 2 k 1 i 0 g k i n 2 i 2 i 1 j 0 i j dk j 2 a k i 2 b dk i 2 c a b c 36 the reduction in darga in the recursive call is exactly balanced by the extra factors of q however if c 0 since there is some i s t dk i 0 for any partition the product will be 0 by initial conditions and thus g n k a b c 0 0 and if c 0 we obtain infinite recursion for nontrivial choices of n k therefore we should ignore this parameter g n k a b d 1 dk k i 1 idi k q k b k i 1 di k a 1 1 j i k i j didj k 1 i 0 g k i n 2 a 2 i b 2 i 1 j 0 i j dk j dk i a b 2 12 implemented as kohgeneral unless otherwise stated we are now assuming the type of partition is unrestricted proposition 2 28 1 g n k a b will have smallest degree ka b 2 if a b n 2 then g n k a b 0 3 if a b n 2 then g n k a b qka b 1 qnk 1 2 ka b 1 q proof 1 this follows from inspecting factors of q note that k k i 1 di k 1 j i k i j didj 0 since g n k has smallest degree 1 recall it 0 for k 37 2 let k consider n k 1 in the recursive call n k 1 k k 1 n 2 a 2 k 1 b 2 k 1 1 j 0 k 1 j dk j 1 n 2 a 2 k 1 b 2 k 1 j 0 k 1 j dk j n 2 a 2 k 2 2 b 2 k j 1 k 1 k j dj n 2 a 2 b 2 2 k 2 k j 1 jdj 2 k j 1 dj n 2 a b 2 2 k j 1 dj n 2 a b 2 2 1 0 thus g n k 1 d 1 a b 0 and since was arbitrary g n k a b 0 3 the above has equality only if 1 i e k then g n k a b q k b k i 1 di k a 1 1 j i k i j didj k 1 i 0 g k i n 2 a 2 i b 2 i 1 j 0 i j dk j dk i a b qka bg k n 2 a 2 b 1 a b k 1 i 1 g k i n 2 a 2 i b 2 i 1 j 0 i j dk j 0 a b qka bg k n 2 a 2 b 1 a b k 1 i 1 g k i n 2 a 2 i b 2 i 0 0 a b it only remains to confirm k i n 2 a 2 b 0 which follows from a n 2 b 2 6 oeis when we take q 1 for the normal q binomials we obtain the common binomial coef ficients what happens if we do that to the modified gs polynomials there is no direct 38 combinatorial interpretation yet but we can derive some cases to start the search re call the explicit forms of g 1 n k g 2 n k and g 3 n k in eqns 2 6 2 9 and 2 10 respectively lim q 1 g 1 n k nk 1 lim q 1 g 2 n k 1 12 k 1 k 2 n 2 3 k 2 n kn 2 2 k 2 9 kn 8 k 12 lim q 1 g 3 n k 1 720 k 2 k 1 k 3 n 3 9 k 3 n 2 3 k 2 n 3 26 k 3 n 42 k 2 n 2 2 kn 3 24 k 3 153 k 2 n 33 kn 2 162 k 2 247 kn 378 k 360 we can also conjecture the form of g 4 n n and g 5 n n from experimental data lim q 1 g 4 n n 1 120960 n n 2 n 1 n 8 32 n 7 462 n 6 3836 n 5 20013 n 4 66836 n 3 140804 n 2 171216 n 100800 lim q 1 g 5 n n n n 3 n 2 n 1 43545600 n 10 50 n 9 1140 n 8 15420 n 7 136533 n 6 824370 n 5 3436190 n 4 9762880 n 3 18198936 n 2 20242080 n 10886400 the sequences for g 1 n n g 5 n n are now in the oeis oeia oeib oeic oeid oeie only s 1 was already in the oeis table 2 1 unimodal sequences from the oeis a 002522 s 1 1 2 5 10 17 26 37 50 65 82 101 122 145 170 197 226 257 290 a 302612 s 2 1 2 6 20 65 186 462 1016 2025 3730 6446 10572 16601 25130 a 302644 s 3 1 2 6 20 70 252 896 2976 8955 24310 60038 136500 289016 a 302645 s 4 1 2 6 20 70 252 924 3432 12705 45430 152438 472836 1352078 a 302646 s 5 1 2 6 20 70 252 924 3432 12870 48620 183755 683046 2443168 h the sequences will approach the central binomial coefficients a 000984 oeif since gs g g http oeis org a 002522 http oeis org a 302612 http oeis org a 302644 http oeis org a 302645 http oeis org a 302646 http oeis org a 000984 39 2 7 conclusion and future work in this work we found a new way to generate unimodal polynomials for which unimodality is a priori very difficult to prove many of the recurrences found produce surprisingly unimodal polynomials given the correct initial conditions the proof is trivial because of our method of reverse engineering there are many promising avenues for future work 1 we were not able to make interesting use of the techniques in section 5 2 with much more care it may be possible to glean some interesting results by adjusting initial conditions 2 an ultimate goal would be to find a restriction on the partitions and other parameters that yields non trivial polynomials that can be expressed as a function in 2 variables we have a few for the restricted partition size but more is always better 3 find other initial conditions that still yield unimodal polynomials when iterated in the recurrence of eqn 2 5 4 try to fully automate the process of finding gs n k in section 2 5 1 use them to verify eqn 2 5 for larger values of s the ideal result would be to prove eqn 2 5 for all s 5 i also tried looking at how restricting to odd partitions compares to restricting to distinct partitions as these are conjugate sets i thought there may be a relation in the resulting polynomials alas i could see no connection one could reexamine these pairs or look at other partition sets that are known to be equinumerous e g odd and distinct partitions compared to self congruent partitions 6 an appealing result would be to find combinatorial interpretations for any of the restricted polynomials particularly the gs polynomials and the oeis sequences a 302612 oeib a 302644 oeic a 302645 oeid and a 302646 oeie 7 instead of only using an adjusted eqn 2 12 one might be able to arbitrarily combine polynomials of known darga to create another polynomial with known darga do this in a similar recursive manner instead of using partitions are there other http oeis org a 302612 http oeis org a 302644 http oeis org a 302645 http oeis org a 302646 40 combinatorial objects that can be applied what other unimodal and symmetric polynomials are out there to use as starting blocks what recurrences do they satisfy that can be tweaked to reverse engineer unimodal polynomials 8 unimodal probability distributions have special properties one could use these polynomials for that purpose after normalizing by g n k q 1 various properties can be discovered using gauss s inequality gau 23 or others 9 unimodal polynomials can be constructed from multiplication very easily is the inverse process of factoring them easier than for general polynomials if so there could be applications in cryptography and coding theory where factoring is a common theme 41 chapter 3 lattice walk enumeration 3 1 introduction this chapter is available as a stand alone paper on arxiv org number 1803 10920 it is being submitted to the journal of integer sequences trying to enumerate all of the walks in a 2 d lattice is a fun combinatorial problem and there are numerous applications from polymers to sports computers provide a wonderful tool for analyzing these walks we provide a maple package for automatically describing generating functions of walks restricted to any step set in a 2 d lattice we always obtain a closed system of relations for generating functions of walks that are bounded semi bounded or unbounded for bounded walks this leads to explicit rational solutions for semi bounded or unbounded walks we may get lucky and obtain algebraic solutions if not we still have a short self referential description of the generating function we consider walks in the two dimensional square lattice with an arbitrary set of integral steps x y subject to x 0 in addition to unbounded walks we also separately constrain the walks to lie in regions bounded above and below as well as bounded only below one would then like to count all possible walks of a certain length possibly with a specific total change in y value rather than a brute force search of the entire space looking for 1 value one could use generating function relations as a bonus one would obtain not only the initial generating function of desire but also many related ones that may be of interest 42 studies of this kind have been done in the literature with simple step sets such as dyck paths 1 1 1 1 dr 71 borw 05 and old time basketball games az 07 philippe duchon analyzed the case of nonnegative bridges with step set 1 2 1 3 see oeis 1 sequence a 060941 oeig for further developments on the subject see vr 00 and the references therein the accompanying maple package is able to extend and inform on old sequences and create many new sequences much of the analysis thus far has been on steps with x value exactly equal to 1 one of the aspects of this paper that sets it apart is the ease with which it can analyze more generic cases 3 1 1 motivation we want to enumerate walking paths constrained to specific allowable steps most of the time we are looking for paths that begin and end on the x axis an earlier motivation for bounded walks came from physics analyzing polymers con strained between plates borw 05 ayyer and zeilberger gave one solution in an earlier paper az 07 that provided the main motivation for this research the kernel method has received attention lately for analyzing specific cases of walks bkk 17 there are several advantages to describing walks using the method of this paper the main idea is the same writing functional equations to describe possible steps in a walk the difference is that this method then describes new components of the functional equation in an iterative manner the kernel method uses analytical number theory on the roots and can be reliant on very case specific techniques compared to the kernel method we believe our method is a lot easier to understand combinatorially is more insightful faster and easier to produce trying to picture an entire walk at once can be difficult this is where the awesome powers of dynamical programming come into play instead of trying to think about the en tirety of a walk think about a part either the beginning step end step or the middle step 1 online encyclopedia of integer sequences nei http oeis org a 060941 43 across the x axis break the walk down into different parts irreducible versus reducible this is what the generating function equations accomplish originally we wrote out a single equation to describe the initial walk of interest then the next then the next until it eventually became a closed system and the wonderful part is that our descriptions always lead to closed systems finally we solved the system we created since this is a very algorithmic approach to answering the question why not have a computer work for us 3 1 2 definitions i will generically use the term walk to indicate any sequence of points x 0 y 0 xs ys in the xy plane though the walk will not necessarily start at the origin if the starting point is not given it is assumed to begin at 0 0 the steps of a walk are x 1 x 0 y 1 y 0 xs xs 1 ys ys 1 and are built from some step set s a set of ordered pairs i exclusively consider walks that are monotonically weakly increasing xi 1 xi 0 a walk is nonnegative nonpositive if the walk never crosses below above the x axis i will sometimes refer to the y value as the altitude of the walk definition 3 1 walks a bridge is an unbounded walk that begins at the origin and ends on the x axis i say bounded bridge for a bounded walk that begins at the origin and ends on the x axis an excursion is a semi bounded not necessarily nonnegative walk that begins at the origin and ends on the x axis a free walk can end anywhere not ending at any specific altitude a meander is a semi bounded free walk the length of a walk is n s i 0 xi the size of a walk is s see figure 3 1 for examples of the different types of walks 44 figure 3 1 walk examples x x nonnegative excursion of size 8 nonnegative meander of size 9 bridge of size 9 free walk of size 7 all of the example walks are of length 8 and are considered to have begun at the origin they are all built from the same step set s 0 1 1 0 1 1 1 2 2 1 note the vertical line in the excursion is actually 2 steps the excursion happens to be irreducible while the rest are not banderier et al bkk 17 uses walk path to reference any sequence of steps that start at the origin the only difference in definitions is that they always count excursions and meanders as nonnegative i will mostly consider them as nonnegative and explicitly say when i am not definition 3 2 the interior of a walk consists of every point other than the endpoints x 1 y 1 xs 1 ys 1 an irreducible walk is one in which the interior has a strictly higher altitude than the lower endpoint min y 1 ys 1 min y 0 ys for purposes of this paper and maple package the stationary walk 2 and walks that are direct steps to the right are not considered to be irreducible walks 3 irreducible is also used to refer to walks that do not exactly hit the final altitude until the final step 2 a single point 3 as the interior the edge between points is not strictly higher than the endpoints 45 3 1 3 chapter organization i will exclusively use t as the variable in generating functions i also abbreviate generating function s as g f s this chapter is organized in the following sections section 2 bounded this is the section in which a computer does the best it can give an exact g f solution since we have a linear system of equations computers are very good at solving these quickly and efficiently section 3 semi bounded an algebraic expression for the g f is no longer guaranteed however we can always find a polynomial in z t for which the g f is a root 4 section 4 guess and check finding a minimal polynomial is guaranteed so why not just guess this section gives a time and memory comparison showing why that would be a poor decision section 5 algebraic to recursive using the minimal polynomial of the g f is not always the fastest for enumerating this section introduces another maple package that converts the polynomial into a 1 d recurrence section 6 unbounded we find minimal polynomials for g f s of unbounded walks and show an alternative method of producing recurrences in specific cases section 7 asymptotics we discover asymptotic results for several step sets to show re lationships between the number of excursions bridges and to a lesser degree meanders section 8 applications we use the maple package to find some extended results and talk about probabilistic behavior we also express minimal polynomials for excursions of small step sets section 9 conclusions and future work a brief recap of what we can do with the scoringpaths maple package and how we can extend the work 4 in the formal power series sense 46 this paper is produced in conjunction with the maple package scoringpaths it is down loadable from math rutgers edu bte 14 code scoringpaths scoringpaths txt i will mention various functions of the package in bold all functions mentioned in this paper are included in the accompanying maple package some functions have been bor rowed from other packages with credit and included in scoringpaths for completeness all comparisons of time and memory are done with maple 17 s codetools usage on linux version 3 10 0 514 el 7 x 86 64 with 8 gb of ram all values are averages of at least 30 trials unless otherwise specified pay careful attention to the units in some examples we are considering discrete walks as such we can consider steps with only integral values if the x steps are fractional there will likely not be any issues if the y steps are fractional many functions will not work as intended if all of the steps share a common factor in the y value it should be factored out leaving an equivalent problem the bounds will need to be factored and truncated as well leaving the common factor may cause problems with some functions the g f may produce non zero coefficients only every mth value it may be desirable to make the substitution t t 1 m for ease of reading i commonly use b n and occasionally c n as the number of walks of length n the step set and walk restrictions will be obvious from context or given explicitly a few functions to create sets of random steps have been included for quick demon strations randomstepset produces a generic set randomzerostepset parses for walks that begin and end on the x axis randomsemiboundedstepset parses for walks bounded below and randomunboundedstepset produces a step set without any 0 y steps there are several paper functions that automatically produce an article with infor mation about a given step set see the paper producing functions section of the help function the package gfun by salvy and zimmermann sz 94 a staple included with recent 47 maple versions is also very useful for manipulating g f s it contains many functions for translating between algebraic expressions recurrences and differential equations satisfied by g f s 3 2 bounded the first case is walks that are bounded above and below consider an arbitrary set of steps s x 1 y 1 xn yn the goal is to find the g f denoted fa b for walks with step set s starting at 0 0 and bounded above and below by a 0 and b 0 respectively all walks paths in this section are constrained to a step set s and bounded above and below 3 2 1 walking anywhere first assume that the walk can end anywhere between the lines y a and y b a walk either never goes anywhere 1 or it takes a step tx and continues as if it is a walk starting at a new point fa y b y the following relation accomplishes that fa b 1 x y s txfa y b y this by itself gets us nowhere but if a y 0 or b y 0 then fa y b y 0 since it is already starting in a prohibited region now write out all a b equations f 0 b a 1 x y s txf 0 y b a y f 1 b a 1 1 x y s txf 1 y b a 1 y fa b 0 1 x y s txfa b y 0 y this is a linear system of a b equations with a b variables after discarding the constant 0 g f s for which maple s solve function can easily find the solution as a bonus we not only have fa b but also every fm n such that m n a b and m 0 n 0 48 the function boundedscoringpathseqsvars will produce all of the equations and variables for this system extremely quickly boundedscoringpaths will output only the g f fa b again this is very fast since it is solving a linear system of only a b equations to verify the values one can use boundedscoringpathsnumber which computes the number of walks by recursion allowable steps are any as long as there is not a 0 and a 0 such that they can sum to 0 within the bounds specifically if 0 m and 0 n are steps then it is allowable will not produce infinite values as long as the width is small enough a b n m gcd m n proof let s 0 m 0 n and assume m n also assume gcd m n 1 if a b n m 1 then we can always take at least one of the s steps since there is a finite number of altitudes then must be acollision at some point a loop if gcd m n g 1 then reconsider the same problem after factoring g out of every thing a a g b b g s 0 m g 0 n g this bound only works for two 0 steps for more than two 0 steps the width must be even shorter for some combinations e g 0 u v 0 u 0 u v there is no allowable width that includes all steps 5 examples example 3 3 close american football games consider trying to enumerate the num ber of american football games in which the teams are never separated by more than 1 score on a given play 6 it is possible for one team to score 2 3 6 7 or 8 points it is also possible for one team to score 6 points and the opposing team to score 1 or 2 points though these are pretty rare occurrences what if we want to enumerate the number of games with n 5 assuming that one can get to the edges of the boundary u v u u v u 0 a loop 6 counting untimed downs as part of the previous play 49 scoring plays that end separated by no more than 1 score we can use the step set s 1 2 1 3 1 6 1 7 1 8 1 5 1 4 1 2 1 3 1 6 1 7 1 8 1 5 1 4 each step represents 1 scoring play and how many points the home team gained relative to the away team since the maximum scoring play is 8 points we make the bounds y 8 8 the g f is then found with boundedscoringpaths s 8 8 t 1 10 t 13 t 2 37 t 3 40 t 4 28 t 5 26 t 6 2 t 7 1 4 t 59 t 2 77 t 3 170 t 4 234 t 5 92 t 6 142 t 7 4 t 8 6 t 9 this sequence is new in the oeis a 301379 oeih example 3 4 speed enumeration bounded 1 consider finding the first 1000 coef ficients of the g f found in example 3 3 above we could use brute force recursion in boundedscoringpathsnumber or take a taylor series expansion since we have an ex plicit form for the g f from boundedscoringpaths table 3 1 bounded walk enumeration method memory used memory allocation cpu time real time brute force recursion 60 23 mib 24 mib 309 53 ms 308 90 ms g f construction 3 27 mib 0 bytes 30 17 ms 33 50 ms taylor enumeration 4 86 mib 0 bytes 4 93 ms 5 07 ms total 8 13 mib 0 bytes 35 10 ms 38 57 ms using the g f method of enumeration is about 8 times as fast and uses a much smaller amount of memory 1 8 th 3 2 2 returning to the x axis the above equations are for g f s of walks that are able to end anywhere what if we want a g f for walks that must end back at the x axis ayyer and zeilberger solved the bounded bridge case but not the bounded free walk case using different relations but http oeis org a 301379 50 the same general method az 08 they also use the equivalent problem of walks between parallel lines of positive slope instead of between horizontal lines let fa b now denote the g f for walks that begin at 0 0 and end on the x axis again we either never get moving 1 or we take a step and then must take a path back to the x axis let ea b c denote the g f for paths that start at 0 c end on the x axis and never touch the x axis beforehand now that ea b c is introduced we can write the relation for fa b fa b 1 x 0 s tx fa b x y s y 6 0 txea b y fa b 3 1 there is also the possibility of just moving along the x axis to start after returning to the x axis we can now take any walk as before hence the multiplication by fa b we now need the equations for ea b c for a c b if any step would return to the x axis then we are done otherwise it must continue as a new ea b c path ea b c x c s tx x y s y 6 c txea b c y we now have a set of linear equations to solve for the ea b c to produce all of the equa tions and variables use equalboundedscoringpathseqsvars once the ea b c system is solved eqn 3 1 is linear in fa b so we or rather a computer will find a rational g f solution use equalboundedscoringpaths for the single solution to verify the result one can check using the enumeration in equalboundedscoringpathsnumber the irreducible g f s can be checked with specificirreducibleboundedscoringpathsnum ber old time basketball the methods of relating generating functions were inspired by ayyer and zeilberger s work az 07 they found the following relation theorem 3 5 let fw denote the generating function for the number of walks subject to step set s 1 2 1 1 2 1 1 2 1 2 that start at 0 0 end at n 0 and never go below the x axis or above the line y w then fw satisfies the following recurrence 51 relation fw 1 tfw 2 tfwfw 1 2 t 2 fwfw 1 fw 2 t 3 t 4 fwfw 1 fw 2 fw 3 t 5 fwfw 1 fw 2 fw 3 fw 4 proposition 3 6 the initial conditions are given as follows f 0 1 f 1 1 1 t f 2 1 t 1 2 t 3 t 2 f 3 1 2 t 3 t 2 1 3 t 5 t 2 2 t 3 t 4 f 4 1 3 t 5 t 2 2 t 3 t 4 1 4 t 6 t 2 2 t 3 if we compute equalboundedscoringpaths 1 2 1 1 2 1 1 2 1 2 w 0 t for w 0 4 then the initial conditions match and we can verify theorem 3 5 empirically for any fixed w examples example 3 7 tied american football games consider the similar example 3 3 but this time we want the teams to be tied at the end of the game our step set is the same the only difference is in which method we use equalboundedscoringpaths s 8 8 t 1 4 t 45 t 2 43 t 3 98 t 4 108 t 5 24 t 6 30 t 7 1 4 t 59 t 2 77 t 3 170 t 4 234 t 5 92 t 6 142 t 7 4 t 8 6 t 9 this sequence is new in the oeis a 301380 oeii example 3 8 speed enumeration bounded 2 once again let us find the first 1000 coefficients of a g f this time the one found in example 3 7 above table 3 2 bounded bridge enumeration 1000 terms method memory used memory allocation cpu time real time brute force recursion 55 98 mib 24 mib 278 93 ms 279 03 ms g f construction 10 13 mib 8 mib 102 43 ms 103 20 ms taylor enumeration 4 85 mib 0 bytes 5 20 ms 5 10 ms total 14 98 mib 8 mib 107 63 ms 108 30 ms http oeis org a 301380 52 again the g f method is faster this time about 2 5 times as fast and 1 4 th the memory 3 3 semi bounded we now remove the restriction of bounding walks from above 7 ayyer and zeilberger also provided relations for describing excursions that are similar to those included here az 08 duchon had previously tackled the case of excursions using much different language but the same overall method duc 00 let s denote the set of steps as in the previous section let f now denote the g f for nonnegative excursions with step set s that begin at 0 0 and end on the x axis how will we describe f in an equation we could try to use the same method as section 3 2 2 and write f 1 x 0 s tx f x y s y 6 0 txey f where ey is the g f for walks that start at 0 y end at n 0 and never hit the x axis beforehand however to describe ey as in section 3 2 2 by looking at the first step would require writing equations for all ei 0 since a walk could get arbitrarily far from the x axis before returning 8 at some point all of the ei equations would look essentially the same and it may be possible to take limits of their form to find a solution for ey however there is an easier method ayyer and zeilberger az 07 used a standard idea in combinatorics of irreducible walks to describe fw in section 3 2 2 we will use them as well let fa b denote the g f for nonnegative walks that start at 0 a and end at n b note that f 0 0 f is what we are typically looking for let ga b denote the g f for walks that start at 0 a end at n b and stay above the line y min a b except at the respective endpoint note then that 7 to look at walks solely bounded above simply change the sign of the y value of every step or note that every nonnegative excursion is in bijection with a nonpositive excursion by reversing the order of steps 8 we could instead look at the final step but that is essentially the method described in the next paragraph 53 ga b ga b 0 or g 0 b a if b a 9 then f 0 0 1 g 0 0 x 0 s tx f 0 0 3 2 either the walk is stationary 1 or it returns to the x axis g 0 0 x 0 s t x and then continues as if it were new multiplication by f 0 0 g 0 0 x 1 y 1 s y 1 0 x 2 y 2 s y 2 0 tx 1 fy 1 1 y 2 1 t x 2 3 3 an irreducible 0 0 walk can be characterized by how it departs from the x axis tx 1 and how it returns tx 2 there must be an intermediate walk between these two steps fy 1 1 y 2 1 that does not touch the x axis hence the shift now we need to describe each new fa b a b fa b b i 0 ga i 0 f 0 b i 3 4 a b fa a b 1 i 0 ga i 0 f 0 b i f 0 0 3 5 a b fa b a 1 i 0 ga i 0 f 0 b i f 0 0 g 0 b a 3 6 we can characterize a walk by how close it gets to the x axis an fa b walk can go i levels below the level of y min a b in this case we have an irreducible walk down to the lowest point ga i 0 and then an arbitrary walk to the final level that does not go any lower f 0 b i if a b then a walk that does not go below level y a is equivalent to f 0 0 if a b then a walk that does not go below level y a consists of an arbitrary walk back to the same level without going lower f 0 0 followed by an irreducible walk to the final level of y b g 0 b a now we must describe the irreducible walks that have not been covered ga 0 x y s y 0 fa 1 y 1 t x 3 7 g 0 a x y s y 0 txfy 1 a 1 3 8 9 in this definition g 0 0 does not include stationary walks or walks that are solely a step directly to the right if this is what one desires then use g g 0 0 1 x 0 s tx 54 an irreducible walk can be characterized by how it reaches tx the lowest point the rest of the walk is arbitrary as long as it does not hit the x axis again hence the shift we need to show that this iterated process does eventually terminate this can easily be justified because the largest index of either g or f will be max x y s y the max imum step size thus there is a finite number of g f that we need to describe in order to have a closed system use equalsemiboundedscoringpathseqsvars to generate these variables and their equations the equations are no longer linear and so maple s built in solve function does not work as nicely instead we use the basis procedure in the groebner package to find definition 3 9 minimal polynomial the minimal algebraic equation satisfied by the generating function p such that p f 0 in terms of formal power series we refer to p as the minimal polynomial when discussing the degree of the minimal polynomial we are considering the degree of f in p unless explicitly stated that we are considering t to produce this polynomial use equalsemiboundedscoringpaths to produce an ideal polynomial for each g f use allequalsemiboundedscoringpaths 10 if you want the minimal polynomial for only a single variable use specificequalsemibound edscoringpaths the minimal polynomial is typically found when the groebner basis receives the desired variable as the lowest order lexicographically occasionally the groeb ner basis will not produce the minimal polynomial but instead a product of it and another polynomial one can recover the minimal polynomial by factoring the output and testing which factor satisfies p f 0 in terms of formal power series 11 every function that out puts an algebraic expression has had findproperroot appended to the end to properly parse the minimal polynomial example 3 10 semi bounded example let s 0 3 1 2 2 0 3 1 the g f 10 this can be slow as it requires finding a groebner basis for every variable 11 by checking a truncated version of f in most cases f 1 is sufficient to see which factor works in general enumerate m terms first using the proper enumerating function and see if the corresponding polynomial is o tm signifying a root 55 f for the number of excursions that do not go below y 1 and have step set s is found to satisfy using equalsemiboundedscoringpaths s 1 t f t 18 f 4 t 14 t 2 1 f 3 2 t 7 t 2 1 2 f 2 t 2 1 5 f t 2 1 4 0 this is actually a fairly simple answer if we change 0 3 0 3 then the minimal polynomial is degree 10 in f and takes 4 lines to write this polynomial can then be used to discover the enumeration hidden in the coefficients of the taylor series expansion by setting f 0 1 and then iterating f 0 p f 0 f 0 to find a fixed point solution 12 finding the coefficients in this manner requires finding p use equalsemiboundedscoringpathscoefficients finding the minimal polynomial can be a time consuming process an alternative method is to iterate a fixed point solution of a vector of all g f and then pick out f 0 0 initialize fa a 1 and every other g f to 0 13 now iterate all of the g f into their respec tive equations truncating to the desired coefficient eventually we will reach a fixed point for the vector of solutions to do this use equalsemiboundedscoringpathsseries however for most reasonable calculations of the coefficients 1000 terms finding the values via brute force recursion with specificequalboundedscoringpathsnumber is faster than either iterating technique example 3 11 speed enumeration excursions we want to obtain the number of nonnegative excursions with step set s 1 2 1 1 1 0 1 1 1 2 let f denote the corresponding g f then 14 t 4 f 4 t 2 t 1 f 3 t t 2 f 2 t 1 f 1 0 3 9 a truncated solution in formal power series and the one that makes sense in terms of our problem is f 1 t 3 t 2 9 t 3 32 t 4 120 t 5 473 t 6 1925 t 7 8034 t 8 34188 t 9 147787 t 10 12 this glosses over why the convergence works it becomes an issue in the unbounded case 13 staying stationary is only valid for general walks that begin and end at the same level 14 using equalsemiboundedscoringpaths s 0 t f 56 we compare and contrast the amount of time and memory to enumerate the first 500 and 1000 coefficients of f in the following tables 1 set up the g f equations and then iterate a vector of solutions using equalsemi boundedscoringpathsseries 2 solve for the minimal polynomial eqn 3 9 and iterate a single solution with equalsemiboundedscoringpaths 3 use maple s taylor function on the minimal polynomial 15 4 use brute force recursion and maple s option remember specificequalsemibound edscoringpathsnumber table 3 3 500 term excursion enumeration method memory used memory allocation cpu time real time vector set up 16 58 kib 0 bytes 300 s 766 s iterating 100 04 gib 55 64 mib 4 45 m 4 09 m total 100 04 gib 55 64 mib 4 45 m 4 09 m polynomial 2 63 mib 0 bytes 19 23 ms 18 63 ms iterating 23 61 gib 20 84 mib 64 52 s 58 56 s total 23 61 gib 20 84 mib 64 54 s 58 58 s polynomial 2 63 mib 0 bytes 19 23 ms 18 63 ms taylor 328 97 mib 53 85 mib 3 20 s 3 18 s total 331 60 mib 53 85 mib 3 22 s 3 20 s brute force recursion 186 60 mib 328 mib 1 569 s 1 472 s finding the polynomials takes negligible time and memory in comparison to actually enu merating the coefficients beyond the first few terms 15 requires replacing f by z and using rootof p 57 table 3 4 1000 term excursion enumeration method memory used memory allocation cpu time real time vector iterating 1 31 tib 159 26 mib 63 84 m 51 86 m single iterating 300 84 gib 15 32 mib 14 50 m 11 93 m taylor 1 82 gib 489 68 mib 12 20 s 11 12 s brute force recursion 0 85 gib 508 mib 7 53 s 7 13 s so using recursion is the fastest but also must reserve the most memory the other methods use more memory in total but can recycle much of what they used we can best all of the methods with another recursion that is faster and uses less memory see example 3 16 before implementing findproperroot the groebner basis output a degree 5 poly nomial that took over 5 times as long to iterate as the degree 4 minimal polynomial whether iterating a single polynomial or the entire vector of solutions is faster depends on the degree of the minimal polynomial and the number of variables in the closed system and the number of terms to enumerate an interesting question would be to look at the time complexity of this method of enumeration the vector and single polynomial iter ation could potentially be optimized to pick out coefficients from each monomial instead of expanding everything and then picking only relatively few terms this would help the minimal polynomial iteration much more as the vector iteration only relies on degree 2 expressions 3 3 1 arbitrary lower limit what if we want to consider walks that stay above an arbitrary lower bound y c as in example 3 10 this is actually very easy by shifting the walk to be nonnegative we are now looking for fc c describe fc c using eqn 3 5 again iterating on all new g f will eventually yield a closed system since the indices are bounded by max max x y s y 1 c this shifting technique is what the maple package utilizes when it is given a lower limit other than 0 for semi bounded walks the maple functions are always focused on obtaining 58 g f s for walks that begin at the origin other produced g f are purely bonus to obtain a g f that starts at 0 c input a lower limit of c and take the g f that corresponds to starting at the origin 3 3 2 meanders what if we do not care where the walk ends as long as it stays above y c neither ayyer and zeilberger az 08 nor duchon duc 00 investigated semi bounded free walks in this case we can actually utilize the irreducible walks we have just created recall the irreducible g f s in eqns 3 7 and 3 8 let ka denote the g f for nonnegative meanders that begin at 0 a restricted to step set s then k 0 1 g 0 0 x 0 s tx k 0 x y s y 0 txky 1 the walk can be stationary 1 it can return to the x axis g 0 0 x 0 s t x and continue as a new meander k 0 or we take the first step t x and continue as a new meander that never returns to the x axis ky 1 g 0 0 the g f for irreducible walks that return to the x axis already has a description from our previous work we need only describe the new ki 16 ka a 1 i 0 ga ik 0 k 0 a i 1 gi 0 1 k 0 the meander can drop down to any lower altitude ga i ga i 0 and then continue as a new meander k 0 never dropping further or the meander will never go below y a so it is equivalent to a meander from the origin k 0 and since we have already described the irreducible walks earlier we now have a closed system that we can use to solve for k 0 to produce the entire system of equations use semiboundedscoringpathseqsvars again we use groebner basis to find a min imal polynomial semiboundedscoringpaths to find the minimal polynomials for all 17 of the variables use allsemiboundedscoringpaths though this will likely take 16 if they exist 17 including all of the irreducible and specific altitude walks from the previous section 59 a while for a specific ka use specificsemiboundedscoringpaths for any ga b fa b it is best 18 to use specificequalsemiboundedscoringpaths example 3 12 for comparison we use the same step set as in example 3 10 s 0 3 1 2 2 0 3 1 the g f k for the number of meanders that do not go below y 1 and have step set s is found to satisfy using semiboundedscoringpaths s 1 t k t 19 t 2 t 1 k 4 t 12 4 t 6 t 4 3 t 3 6 t 2 t 3 k 3 3 t 6 2 t 9 2 t 8 t 7 4 t 6 2 t 5 2 t 4 t 3 3 t 2 1 k 2 4 t 12 8 t 11 7 t 10 11 t 9 7 t 8 3 t 7 7 t 6 6 t 5 6 t 4 2 t 3 4 t 2 1 k t 9 3 t 8 4 t 7 2 t 6 6 t 5 4 t 4 3 t 3 3 t 2 1 0 sadly the coefficients do not factor as nicely as in example 3 10 now that we have a method of describing the g f for meanders let us compare how fast it is for enumeration example 3 13 speed enumeration meanders we use the simpler step set s 1 2 1 1 1 0 1 1 1 2 and let k be the g f for the number of nonneg ative meanders with step set s then 19 t 2 5 t 1 2 k 4 t 5 t 1 2 k 3 3 t 5 t 1 k 2 5 t 1 k 1 0 3 10 a truncated solution is k 1 3 t 12 t 2 51 t 3 226 t 4 1025 t 5 4724 t 6 22022 t 7 103550 t 8 490191 t 9 2333057 t 10 we repeat our analysis of differing methods of enumeration from example 3 11 1 iterating a vector of solutions using semiboundedscoringpathsseries 2 iterating a fixed point solution after solving for the polynomial eqn 3 10 with semiboundedscoringpaths 20 18 and necessary compatibility was removed for ease of use 19 using semiboundedscoringpaths s 0 t k 20 all of this can be accomplished with the one function semiboundedscoringpathscoefficients 60 3 using maple s taylor function on the minimal polynomial 21 4 enumerating using brute force recursion and maple s option remember specificsemiboundedscoringpathsnumber table 3 5 1000 term meander enumeration method memory used memory allocation cpu time real time vector set up 21 07 kib 0 bytes 233 s 233 s vector iterating 2 18 tib 15 29 mib 102 64 m 84 48 m total 2 18 tib 15 29 mib 102 64 m 84 48 m polynomial 6 37 mib 0 bytes 43 00 ms 43 03 ms single iterating 304 99 gib 30 58 mib 13 88 m 11 64 m total 305 00 gib 30 58 mib 13 88 m 11 64 m polynomial 6 37 mib 0 bytes 43 00 ms 43 03 ms taylor 1 85 gib 490 mib 11 33 10 62 s total 1 86 gib 490 mib 11 37 s 10 66 s brute force recursion 1 08 gib 0 52 gib 7 93 s 7 465 s again there is an even faster recursive formula see example 3 17 3 4 guess and check method zeilberger provided a guess and check method and maple package w 1 d ez 15 for find ing algebraic expressions in the semi bounded case where all steps have x step 1 phillippe duchon guaranteed that the results are algebraic thus the guess and check method will work eventually if you set the search parameter high enough for semi bounded cases with differing x steps and unbounded cases there is no guarantee that guessing will eventually work mr 09 though you may get lucky and produce an algebraic equation that has the minimal polynomial as a root 21 requires replacing k by z and using rootof p 61 another advantage of this paper s method over guess and check is that this method is typically much much faster setting up the equations takes a set amount of time that is linear in the maximum step size s and the lower limit the time sink comes in finding a groebner basis but this is still typically faster empir will take a list of the first few coefficients of the g f f and attempt to find an algebraic equation that f satisfies by guessing the degree and trying to solve for the coefficients empirf will do this faster 22 by utilizing the gfun package both empir and empirf require enumerating the first few terms example 3 14 excursion time comparison consider looking for an algebraic equation for the g f for nonnegative excursions with step set s 1 2 1 1 1 0 1 1 1 2 it takes 23 table 3 6 finding excursion minimal polynomial s 1 2 1 1 1 0 1 1 1 2 method memory used memory allocation cpu time real time esbsp 2 63 mib 0 bytes 19 23 ms 18 63 ms empir 91 61 mib 5 60 mib 734 ms 735 ms empirf 4 33 mib 0 bytes 33 87 ms 35 90 ms equalsemiboundedscoringpaths esbsp takes about 3 of the time and mem ory that empir requires and 60 of the time and memory as empirf example 3 15 meander time comparison now try to find an algebraic equation satis fied by the g f for nonnegative meanders with step set s 1 2 1 1 1 0 1 1 1 2 24 22 almost always 23 the actual minimal polynomial is shown in example 3 11 24 the minimal polynomial is shown in example 3 13 62 table 3 7 finding meander minimal polynomial s 1 2 1 1 1 0 1 1 1 2 method memory used memory allocation cpu time real time sbsp 6 37 mib 0 bytes 43 00 ms 43 03 ms empir 91 68 mib 5 45 mib 749 ms 770 ms empirf 4 74 mib 0 bytes 36 53 ms 38 63 ms sbsp semiboundedscoringpaths as expected this package is still much faster than empir interestingly empirf appears to be as fast if not a little faster empirf is still handicapped in its range of applications and so the slight speed up is sacrificed for versatility in fact adding 1 3 to the step set already makes empirf fail for the preset search bound the minimal polynomial has degree and order 10 in that case easily found by semiboundedscoringpaths in 1 4 s the other bonus is that this paper s method allows for any size x step w 2 d could po tentially be used to solve this problem once it has been restricted to look for the coefficient of xn y 0 however this would make the already slow guessing method even slower 3 5 algebraic to recursive 3 5 1 conversion there is a classical method for deducing from the algebraic function satisfying the g f a linear recurrence with polynomial coefficients satisfied by the coefficients of the g f in question see chapter 6 of the concrete tetrahedron by kauers and paule kp 11 the method is implemented in the maple package gfun sz 94 and also in zeilberger s maple package schutzenberger that is used here the schutzenberger package also contains empirf for obtaining the minimal polynomial but we now have a much better method of producing the minimal polynomial to convert an algebraic formula to a recurrence formula use algtorec let b n denote the number of walks of length n interestingly sometimes a larger non minimal polynomial produces a better lower order 63 recurrence example 3 16 better excursion recursion let s 1 2 1 1 1 0 1 1 1 2 let f denote the g f for nonnegative excursions 25 then its coefficients satisfy 0 3125 n 1 n 2 n 3 n 4 b n 250 n 4 n 3 n 2 27 n 122 b n 1 25 n 4 n 3 107 n 2 1457 n 4316 b n 2 10 n 4 304 n 3 3233 n 2 9864 n 6513 b n 3 2821 n 4 56794 n 3 425771 n 2 1407974 n 1731540 b n 4 2 n 7 413 n 3 6986 n 2 39356 n 73830 b n 5 n 8 n 7 99 n 2 1241 n 3900 b n 6 2 2 n 15 n 9 n 8 n 7 b n 7 3 11 the following are the time and memory requirements for various stages of enumerating we need to create the minimal polynomial with equalsemiboundedscoringpaths convert it to an improved recursive formula eqn 3 11 for the coefficients of f with algtorec and then enumerate with seqfromrec table 3 8 enumerating excursions more efficiently method memory used memory allocation cpu time real time esbsp 2 63 mib 0 bytes 19 23 ms 18 63 ms algtorec 35 84 mib 3 12 mib 267 93 ms 262 40 ms seqfromrec 123 05 mib 24 mib 375 27 ms 375 37 ms total 161 52 mib 27 12 mib 662 43 ms 656 40 ms esbsp equalsemiboundedscoringpaths as expected this streamlined recurrence is much faster and less memory intensive than the basic recurrence in example 3 11 there is an up front cost for creating the improved 25 the minimal polynomial is given in example 3 11 64 recurrence but if the goal is to enumerate enough terms it can be worth it in this case enough is less than 500 before findproperroot was implemented to automatically parse the minimal poly nomial we converted a larger polynomial into a sixth order recurrence in about 2 4 seconds example 3 17 better meander recursion let s 1 2 1 1 1 0 1 1 1 2 and k denote the g f for nonnegative meanders 26 the coefficients now satisfy 0 625 n 1 n 2 n 3 n 4 b n 250 5 n 21 n 4 n 3 n 2 b n 1 50 n 4 n 3 7 n 2 95 n 270 b n 2 20 n 4 32 n 3 367 n 2 1365 n 1620 b n 3 n 5 463 n 3 6691 n 2 32442 n 52704 b n 4 2 n 5 n 6 53 n 2 593 n 1674 b n 5 4 n 5 2 n 13 n 7 n 6 b n 6 oddly it is a lower order recurrence despite the slightly higher complexity of describing meanders the following are the time and memory requirements for various stages of enumerating table 3 9 enumerating meanders more efficiently method memory used memory allocation cpu time real time sbsp 6 37 mib 0 bytes 43 00 ms 43 03 ms algtorec 110 77 mib 29 39 mib 659 73 ms 633 10 ms seqfromrec 89 58 mib 4 mib 284 57 ms 257 23 ms total 206 72 mib 33 39 mib 987 30 ms 933 36 ms sbsp semiboundedscoringpaths this improved recurrence is about 8 times as fast as the basic recurrence in example 26 the minimal polynomial is given in example 3 13 65 3 13 it is not quite as much of a savings as the case of excursions but it is still extremely good 3 5 2 searching there is an alternative to converting the minimal polynomial into a linear recurrence since we know that this will be possible we could simply guess at the form of the recurrence and use a suitable number of starting values to determine the coefficients findrec will accomplish this guessing method the problem is that we do not know an upper bound for the order and degree setting the bound extremely high or searching until a recurrence is found would suffice however this is not ideal example 3 18 let s 1 2 1 3 the minimal polynomial is given later in section 3 8 3 let b n denote the number of nonnegative excursions of length 5 n b n was found to satisfy a 4 th order degree 11 recurrence relation using findrec and a 7 th order degree 9 recurrence relation using algtorec 27 both relations 28 are fairly large and so are not included here 29 we compare and contrast the methods in the table below table 3 10 alternative recurrence step set 1 2 1 3 method degree order memory used allocated cpu time real time algtorec 9 7 165 84 gib 2 46 gib 46 99 h 12 06 h findrec 11 4 0 50 gib 388 01 mib 4 47 s 4 31 s simply guessing at the form appears to be the much better choice here example 3 19 let s 1 2 1 1 1 0 1 1 1 2 see example 3 11 for the minimal polynomial let b n denote the number of nonnegative excursions of length n 272 trials 28 the findrec recurrence matches with andrew lohr s calculation as expected since they are computing the same result 29 they are available at math rutgers edu bte 14 articles scoringpaths 23 recurrence txt 66 then 0 2 n 4 2 n 11 n 7 n 6 b n 5 n 6 43 n 3 597 n 2 2738 n 4142 b n 4 124 n 4 2110 n 3 13305 n 2 36815 n 37686 b n 3 5 n 3 2 n 3 22 n 2 305 n 726 b n 2 25 n 3 n 2 8 n 2 72 n 159 b n 1 125 n 5 n 3 n 2 n 1 b n this was found with findrec while algtorec found 0 2 2 n 15 n 9 n 8 n 7 b n 7 n 8 n 7 99 n 2 1241 n 3900 b n 6 2 n 7 413 n 3 6986 n 2 39356 n 73830 b n 5 2821 n 4 56794 n 3 425771 n 2 1407974 n 1731540 b n 4 10 n 4 304 n 3 3233 n 2 9864 n 6513 b n 3 25 n 4 n 3 107 n 2 1457 n 4316 b n 2 250 n 4 n 3 n 2 27 n 122 b n 1 3125 n 1 n 2 n 3 n 4 b n the comparison in methods is given below table 3 11 alternative recurrence step set 1 2 1 1 1 0 1 1 1 2 method degree order memory used allocated cpu time real time algtorec 4 7 38 32 mib 42 61 mib 355 60 ms 354 44 ms findrec 4 5 62 38 mib 28 00 mib 618 07 ms 630 87 ms conversion is actually more efficient though not ideal in this case though the differ ence is not as extreme as that shown in table 3 18 with smaller step sizes conversion appears to be better this is likely due to the 67 intensive task of converting higher degree polynomials while guessing avoids that hurdle for small enough examples guessing is a larger search space than conversion because of the way findrec is programmed it is guaranteed that a found recurrence has order less than or equal to that of algtorec depending on the goal when enumerating lower degree save computation or lower order save memory is optimal one can use algotrec s order and degree as a proper bound for use in findrec but instead of directly converting the minimal polynomial it may be possible to find a bound on the order and degree of a recurrence based on the degrees of the g f and t in the minimal polynomial we may also be able to derive an upper bound based on the number of variables in the closed system we created i was unable to prove any useful bounds and these examples are evidence against bounding the order and degree directly by the degrees of the g f and t all three exam ples have minimal polynomials with smaller degree and total degree than the order of the found recurrences in fact we know that the sum of the degree and order of any recurrence has to be greater than the total degree of the minimal polynomial in these cases since we searched everything lower the first example showed that findrec can be an extreme improvement over al gtorec and the second example showed when algtorec can just edge out findrec the following example demonstrates that algtorec can be the significantly better choice example 3 20 let s 1 1 3 1 1 0 3 0 2 1 1 2 2 2 the minimal poly nomial letting k denote the g f of meanders with step set s is 1 t 3 5 t 2 4 t 1 k t 4 t 3 2 t 3 2 t 2 3 t 1 k 2 t t 1 2 t 3 2 t 2 3 t 1 k 3 the recurrences found by conversions and searching are much too large to include here for their information see math rutgers edu bte 14 articles scoringpaths recurrenceoutputfile 68 table 3 12 alternative recurrence step set 1 1 3 1 1 0 3 0 2 1 1 2 2 2 method degree order memory used allocated cpu time real time polynomial 2 55 mib 24 00 mib 20 80 ms 24 50 ms algtorec 3 31 73 92 mib 11 39 mib 491 03 ms 475 13 ms total 76 47 mib 35 39 mib 511 83 ms 499 63 ms 161 terms 24 11 mib 0 bytes 190 00 ms 193 00 ms findrec 5 15 2 46 gib 504 mib 23 30 s 21 20 s total 2 48 gib 504 mib 23 49 s 21 39 s conversion is surprisingly 43 times faster and has roughly 1 32 nd of the memory re quirements we chose to enumerate 161 terms of the sequence because that was sufficient once we knew the degree and order of the converted recurrence to guarantee findrec would en counter a solution typically we do not use both findrec and algtorec we should simply find a set large bound of numbers but enumerating was a small portion of findrec s time so it does not matter too much to this example we have used meanders instead of excursions for our 3 rd example but they are similar enough to compare the important facets of the problem are the degree of the minimal polynomial and the number of steps it would appear that increasing the number of steps does not affect the runtime of algtorec as much as the runtime of findrec the runtime of algtorec is highly depen dent on the degree of the minimal polynomial 30 the degree of the minimal polynomial is generally correlated with the number of variables in the system though not necessarily equal or bounded one way or the other example 3 11 has 7 variables in the closed sys tem and a minimal polynomial of degree only 4 section 3 8 3 shows that a step set of 1 3 1 5 for nonnegative excursions yields a closed system with 18 variables yet the minimal polynomial has degree 56 30 the degree of t is much less relevant 69 the most important aspects of the step set to algtorec runtime are then the maximum and minimum 31 y steps since these dictate how many other walks we must consider findrec is much weaker with larger step sets inherently the recurrences will become more complicated which means findrec must consider many more terms in its guesses the worst case most number of terms to address will occur when the order and degree of our search are the same since algtorec works better with minimal polynomials of lower degree and finding the minimal polynomial is generally very fast see example 3 13 i have chosen to have programs such as papersemibounded and bookequalsemibounded use findrec when the minimal polynomial has degree 8 and algtorec otherwise the cutoff was arbitrarily chosen based on a few random examples a rigorous cutoff would be useful for more widespread implementation 3 6 unbounded we remove the lower bound in this section and transition from analyzing excursions to analyzing bridges i was unable to find any current literature that analyzes the unbounded case with generating functions thus i am led to believe that this section is novel work again all walks are assumed to be constructed from a step set s 3 6 1 walking anywhere enumerating walks that go anywhere can be a trivial task first off the y values do not matter except for describing multiple steps with the same x step if all of the steps have x value m 0 then the number of walks of length m n is simply s n if we have steps with varying x values then the problem becomes finding combinations of the x values that sum to n in general the g f will be 1 1 x y s t x 31 most negative 70 this g f is produced by unboundedscoringpaths the terms are generated by using taylor series unboundedscoringpathscoefficients or via recursion unbounded scoringpathsnumber using maple s taylor series expansion is typically faster but both are extremely quick at enumerating the first 1000 terms 32 3 6 2 returning to the x axis a lot of the work we have done in the semi bounded case will prove useful here we cannot use the exact same method as in semi bounded section 3 3 suppose we tried describing a walk with a negative change in altitude the first and last steps could both be positive then we would need to describe a walk that has a larger negative change in altitude and so on we try a slightly different method let g denote the g f for walks with step set s that begin at 0 0 and end on the x axis a bridge we choose to introduce another g f which we denote hi for the number of walks from 0 i to n 0 that do not touch the x axis beforehand with the exception of h 0 starting on the x axis 33 recall the definitions of ga b and fa b the first equation is similar to f 0 0 g 1 h 0 x 0 s tx g a walk can be stationary or it returns to the x axis after some number of steps at which point it can take another g walk h 0 2 g 0 0 x y s y 2 y 1 i 1 g 0 it xhi y x y s y 2 y 1 i 1 gy i 0 t xhi an h 0 walk can be purely positive g 0 0 or purely negative g 0 0 34 note that walks below the x axis are in bijection with walks above the x axis by reversing the order of steps 35 we can then use g 0 a ga 0 and f a b fb a it is also possible for the h walk to cross 32 by utilizing maple s option remember in the recursive case 33 h 0 does not include stationary walks nor walks that are steps directly to the right for that one will want to use h h 0 1 x 0 s t x 34 this is also partially why irreducible walks do not include steps to the right if g 0 0 did then i would have to write h 0 2 g 0 0 x 0 s tx which is less elegant 35 equivalent to rotating the walk 180 71 the x axis without touching it this would involve an irreducible walk g 0 i a step across the x axis tx and another walk hi y to return to the x axis the previous sentence described crossing the x axis from above to below we could instead cross from below to above this would consist of an irreducible walk g 0 i y gy i 0 a step across the x axis tx and another walk hi to return to the x axis we already have equations to describe the irreducible walks we now need to describe the other h walks j 0 hj gj 0 x y s y 2 y 1 i 1 fj 1 i 1 t xhi y j 0 hj g 0 j x y s y 2 y 1 i 1 fy i 1 j 1 t xhi an hj 0 walk can either be a walk directly to the x axis gj 0 or it consists of an arbitrary walk that does not touch the x axis fj 1 i 1 followed by a step across t x and another walk hi y to return to the x axis similarly an hj 0 walk can either be a walk directly to the x axis gj 0 g 0 j or it consists of an arbitrary walk that does not touch the x axis fj 1 i y 1 fy i 1 j 1 followed by a step across t x and another walk hi to return to the x axis a brief lapse in concentration allowed me to write the alternative and much simpler relation h 0 2 g 0 0 x y s y 6 0 txhy the reason for shunning this simpler description is that the hy may be irreducible walks directly back to the x axis and thus double count a walk from g 0 0 the system of equations will be closed since the index of hi walks is bounded by max x y s y 1 all of the equations and variables are produced in equalunbound edscoringpathseqsvars again we use the basis procedure in the groebner package to find a polynomial p such that p g 0 in terms of formal power series to produce this polynomial use equalunboundedscoringpaths to produce the minimal polynomial for hj use specificunboundedscoringpaths 72 we can try to produce the coefficients of the taylor series using the iteration g 0 p g 0 g 0 however because of convergence issues this will typically not work it is also potentially not ideal because it requires finding a groebner basis which can be time consuming however iterating a vector of solutions a la the semi bounded section 3 3 does work to check these values use specificunboundedscoringpathsnumber to verify g and specificirreducibleunboundedscoringpathsnumber to verify hj 3 6 3 alternative method there is an alternative method for enumerating unbounded walks in the specific case that all of the steps have x step 1 az 90 the functions themselves are taken from the maple package ekhad by zeilberger i will start with an example example 3 21 consider the function g t n t 2 t 1 t t 2 n this represents a possible step set of s 1 2 1 1 1 1 1 2 a specific monomial in the expansion of g t n comes from all the ways of picking a power of t from each term this is equivalent to picking which step to take and in which order 1 g t 0 1 there is only 1 walk the stationary walk 2 g t 1 t 2 t 1 t t 2 there are 4 possible steps each leading to a different final altitude 3 g t 2 t 4 2 t 3 t 2 2 t 1 4 2 t t 2 2 t 3 t 4 there are 4 ways to return to the x axis after 2 steps g t n enumerates all the ways to change altitude by c in the coefficient of the tc monomial in general for a step set s letg t n x y s t y n the procedureazd a t n n from package ekhad will give a recurrence for the contour around 0 integral of a with respect to t under hypergeometric assumptions i e azd returns the residue and if we represent a as a power series that means we extract the t 1 term so to find a recurrence for the number of walks that return to the x axis we will use a g t n t 73 example 3 22 the input azd t 2 t 1 t t 2 n t n n yields as output 18 2 n 1 5 n 8 n 1 n 1 35 n 2 91 n 54 n 2 n 2 2 n 3 5 n 3 n 2 this translates as if we let b n denote the number of walks that return to the x axis after n steps 18 2 n 1 5 n 8 n 1 b n n 1 35 n 2 91 n 54 b n 1 2 n 2 2 n 3 5 n 3 b n 2 0 3 12 we can find a recursion for any change in altitude not just bridges if we are interested in walks that change in elevation by c then we should use a g t n tc 1 3 6 4 selected step sets the following examples are all produced by the one call equalunboundedscoringpaths s t g example 3 23 old time basketball we will follow up the previous example by us ing this paper s g f method of dynamical programming with the same step set let s 1 2 1 1 1 1 1 2 let g denote the g f for the number of unbounded bridges subject to step set s then g satisfies 9 t 4 4 t 1 2 g 4 2 3 t 2 4 t 1 g 2 t 0 and the coefficients satisfy using algtorec 108 n 1 2 n 1 b n 78 n 2 246 n 216 b n 1 n 2 17 n 9 b n 2 2 n 3 2 n 5 b n 3 0 interestingly we have obtained a different recurrence than what was found with the azd method eqn 3 12 both recurrences are correct typically azd will produce a lower order recurrence but with higher degree polynomial coefficients the simple alteration of the step set to s 2 2 1 1 1 1 2 2 makes the alternative method in section 3 6 3 ineffectual however the method presented in this 74 paper is not bothered in the slightest let g denote the g f for the number of unbounded bridges subject to step set s then g satisfies 8 t 2 5 4 t 4 8 t 2 1 2 g 4 2 4 t 2 3 4 t 4 8 t 2 1 g 2 1 0 now we only have the option of conversion or guessing to find a recurrence for the coeffi cients of g using algtorec took only 69 ms and produced 32 n 3 n 2 b n 4 5 n 2 110 n 356 b n 2 8 15 n 2 160 n 439 b n 4 59 n 438 n 6 b n 6 10 n 8 n 6 b n 8 0 the reason to have x step as all 1 s versus having x step equal to y step is that the choice changes what g counts if all x steps are 1 g will count the number of ways to be tied after n total baskets if x step equals y step then g counts the number of ways to be tied at a score of n 2 to n 2 note that this interpretation means g has coefficient 0 for all odd powers of t teams cannot be tied after an odd number of points have been scored we could make the substitution t t in g and then g would count the number of ways to be tied at a score of n n example 3 24 current basketball let s 1 3 1 2 1 1 1 1 1 2 1 3 let g denote the g f for the number of unbounded bridges subject to step set s then g satisfies 8 t 2 68 t 27 2 6 t 1 4 2 t 1 4 g 8 4 68 t 2 10 t 9 8 t 2 68 t 27 6 t 1 3 2 t 1 3 g 6 2 9120 t 4 3744 t 3 1264 t 2 212 t 135 6 t 1 2 2 t 1 2 g 4 4 1216 t 4 832 t 3 4 t 2 46 t 7 6 t 1 2 t 1 g 2 16 t 2 8 t 1 2 0 equalunboundedscoringpaths s t g originally gave a much larger polynomial that g satisfies after findproperroot was added to parse the output the smaller polynomial 75 above was the result the coefficients satisfy using algtorec 36864 n 1 n 2 n 3 b n 3072 n 3 n 2 97 n 142 b n 1 64 n 3 4031 n 2 17601 n 19504 b n 2 16 1684 n 3 13491 n 2 31178 n 15240 b n 3 24 663 n 3 7222 n 2 28628 n 41563 b n 4 4 467 n 3 7011 n 2 35842 n 62490 b n 5 2 n 6 115 n 2 1080 n 2273 b n 6 3 3 n 20 3 n 19 n 7 b n 7 0 or using azd 96 n 1 n 2 n 3 2058 n 3 20335 n 2 66857 n 73300 b n 8 n 2 n 3 201684 n 4 2295356 n 3 9540055 n 2 16998380 n 10742400 b n 1 4 n 3 310758 n 5 4313617 n 4 23611469 n 3 63712598 n 2 84804508 n 44608800 b n 2 2 n 3 41160 n 5 591920 n 4 3361281 n 3 9453847 n 2 13262292 n 7512000 b n 3 3 3 n 11 3 n 10 n 4 2058 n 3 14161 n 2 32361 n 24720 b n 4 0 let s 3 3 2 2 1 1 1 1 2 2 3 3 let g denote the g f for the num ber of unbounded bridges subject to step set s then g satisfies 108 t 6 99 t 4 52 t 2 44 2 4 t 6 4 t 4 8 t 2 1 4 g 8 4 36 t 6 29 t 4 24 t 2 20 108 t 6 99 t 4 52 t 2 44 4 t 6 4 t 4 8 t 2 1 3 g 6 2 2160 t 12 4248 t 10 4347 t 8 992 t 6 16 t 4 1184 t 2 976 4 t 6 4 t 4 8 t 2 1 2 g 4 4 112 t 12 288 t 10 665 t 8 412 t 6 552 t 4 112 t 2 96 4 t 6 4 t 4 8 t 2 1 g 2 4 t 6 3 t 4 12 t 2 4 2 0 76 again equalunboundedscoringpaths s t g originally gave a more complicated polynomial before findproperroot was added we cannot use azd for this case how ever we can still obtain a recurrence using algtorec the conversion only took about 13 seconds but produced a recurrence of order 66 and degree 3 and as such is not included here 3 6 5 time comparison to reiterate the benefits of this paper and maple package over guessing for the polynomial the following examples illustrate the time savings example 3 25 finding a polynomial let s 1 2 1 1 1 0 1 1 let g be the g f for bridges subject to step set s then 16 t 3 8 t 2 11 t 4 g 3 3 2 t g 1 0 this takes table 3 13 finding minimal polynomial s 1 2 1 1 1 0 1 1 method memory used memory allocation cpu time real time eusp 2 10 mib 0 bytes 18 27 ms 21 53 ms empir 34 94 mib 0 73 mib 294 93 ms 295 63 ms empirf 1 44 mib 0 bytes 14 27 ms 16 23 ms in this case empirf appears to be 25 faster than equalunboundedscoring paths eusp but the time is so small the difference is likely to go unnoticed the next example shows why the scoringpaths package is superior to using empirf example 3 26 finding a polynomial 2 let s 1 2 1 1 1 0 1 1 1 2 let g be the g f for bridges subject to step set s then 5 t 4 5 t 1 2 t 1 2 g 4 2 t 1 5 t 2 5 t 1 g 2 t 0 this takes 77 table 3 14 finding minimal polynomial s 1 2 1 1 1 0 1 1 1 2 method memory used memory allocation change cpu time real time eusp 7 70 mib 0 bytes 58 33 ms 61 43 ms empir 377 91 mib 31 29 mib 2 89 s 2 75 s empirf failed empirf happened to fail for this s while equalunboundedscoringpaths eusp only tripled in time and memory usage the only difference between this example and example 3 25 is the second step with positive y value eventually guessing should work but we have no way of knowing what the upper bound of search space is before blindly investigating expressing the g f equations is a set amount of time that is guaranteed to produce the solution the time complexity to find the minimal polynomial with groebner bases is an interesting question we leave to the reader we have many different ways to enumerate the number of bridges with step set s we will compare their speed and memory usage here example 3 27 speed enumeration unbounded as with most previous examples we use the benchmark step set s 1 2 1 1 1 0 1 1 1 2 the following are time and memory requirements for enumerating 1000 terms of the sequence of bridges with step set s the different methods are 1 iterating the single polynomial found with equalunboundedscoringpaths does not work due to convergence issues beyond the scope of this paper 2 taylor cannot be used it gives the error does not have series solution taylor tends to work only if the minimal polynomial contains a g 1 term see example 3 25 3 iterating a vector solution with equalunboundedscoringpathsseries 4 brute force recursion using specificunboundedscoringpathsnumber 5 converting minimal polynomial to recurrence 78 a obtain the polynomial with equalunboundedscoringpaths b convert to recurrence with algtorec the coefficients satisfy 0 125 n 1 n 2 b n 25 n 2 n 1 b n 1 5 21 n 2 89 n 96 b n 2 n 2 43 n 140 b n 3 2 n 4 n 7 b n 4 c enumerate using seqfromrec 6 using azd and then enumerating with seqfromrec 0 25 3 n 8 n 2 n 1 b n 5 3 n 5 2 n 5 n 2 b n 1 3 n 8 19 n 2 76 n 75 b n 2 2 3 n 5 2 n 5 n 3 b n 3 table 3 15 1000 term unbounded enumeration method memory used memory allocation cpu time real time vector set up 20 47 kib 0 bytes 200 s 200 s vector iterating 2 79 tib 30 54 mib 2 27 h 110 54 m polynomial 7 76 mib 0 bytes 59 40 ms 63 03 ms conversion 5 97 mib 8 kib 49 03 ms 51 97 ms enumeration 20 64 mib 2 16 mib 84 87 ms 81 50 ms total 34 37 mib 2 17 mib 193 30 ms 196 50 ms azd 2 45 mib 0 bytes 25 77 ms 30 53 ms seqfromrec 19 34 mib 3 59 mib 74 40 ms 74 43 ms total 21 79 mib 3 59 mib 100 17 ms 104 96 ms brute force recursion 1 41 gib 4 29 mib 12 69 s 11 91 s the alternate method is the fastest in this case it is about half of the time as converting but the actual enumeration after the preliminary set up is very similar the memory usage is similarly low however azd is only appropriate for specific cases with constant x step the key take away is that enumerating by combining scoringpaths and algtorec is much faster and leaner than brute force recursion and applicable in a wide range of cases 79 if we change the step set back to s 1 2 1 1 1 0 1 1 then we can use taylor on the minimal polynomial as well as iterating the single solution after an ap propriate change of iteration the difference is that example 3 25 had a g 1 term in its minimal polynomial while example 3 26 did not this allows one to write g as copies of itself which is what the iterative method is effectively accomplishing 3 7 asymptotics for determining asymptotic behavior i avoided analyzing the bounded cases as those re sulted in explicit rational solutions which can already be handled very easily the asymp totic behavior of unbounded general walks is simply finding the number of combinations of x steps to yield a length of n the actual walk altitude does not matter for semi bounded and unbounded cases once we have recurrences for the coefficients we can derive asymptotic expressions because of the nature of these quantities the num ber of walks of length n will always follow bn for some base b fs 09 wimp and zeil berger wz 85 created a method for automatically determining asymptotics for a linear recurrence including the constant of the leading term their package asyrec provides asy which attempts to determine the exponential power with which a recurrence grows asyc along with suitable starting values will also give the correct constant one task we can use this for is finding what proportion of walks are nonnegative let s 1 2 1 1 2 1 36 let f denote the g f for nonnegative excursions and b n denote the number of nonnegative excursions of length n then 37 0 1 f tf 2 0 4 n 2 b n n 2 b n 1 b n 4 n n 3 2 1 9 8 n 145 128 n 2 1155 1024 n 3 36939 32768 n 4 295911 262144 n 5 36 x step is 1 2 so that excursions and bridges do not all have even length producing a bunch of extraneous 0 s 37 all of this can be produced by the one command equalsemiboundedpaper s 20 true true 80 because the minimal polynomial is simple we could use the lagrange inversion formula to compute exact values of b n 38 but for most step sets with s 2 this will not work so the lif is not considered here let g denote the g f for bridges and c n the number of bridges of length n then 39 0 1 4 t 1 g 2 0 4 n 2 c n n 1 c n 1 c n 4 n n 1 1 8 n 1 128 n 2 5 1024 n 3 21 32768 n 4 399 262144 n 5 then the proportion of binary bridges that are dyck paths is asymptotically b n c n 1 n this matches with the known exact proportion of 1 n 1 the above example was not exactly revolutionary but the method allows for quick analysis of walks with any step set dyck paths have been studied quite extensively the typical result is for walks with step set 1 0 0 1 from 0 0 to n n that stay below the line y x this is equivalent to enumerating nonnegative excursions with step set 1 1 1 1 changing the slope of the upper bound to rational a b is equivalent to using a step set 1 a 1 b this is called rational catalan combinatorics for a general conversion from walks below a line with slope m reflect the walk across the line through the origin with slope m 2 this produces an equivalent nonnegative walk in the right hand plane andrew lohr studied the field of paths below rational slope with the goal of obtaining asymptotic constants lz 17 for his results go to http sites math rutgers edu ajl 213 drz rsp pdf lohr states a result by duchon in 2000 duc 00 that for any slope a b the number of paths below a line of that slope is asymptotically 1 n a b n an are we able to say anything about step sets of size 2 intuition would say the growth rate should be larger but how much larger 38 this is what duchon used for several simple cases duc 00 39 this can be produced by unboundedpaper s 20 true true 81 first we need to tackle the scenario if we have steps with x step 0 recall we can only have steps directly up or down the maximum number of up steps we could have in an excursion or bridge of length n is n min y x x y s x 6 0 min y 0 y s replace the mins with maxs for down steps 40 we can only take so many steps in one direction before we have to start returning in order to make it to the x axis before length n let c denote the fraction above c 0 for step sets without vertical steps the worst case scenario 41 is that the remaining steps all have x step 1 then we have n cn n ways to place the vertical steps let s denote the size of s with the 0 steps removed then the number of walks is upper bounded usually very poorly by n 1 c n sn 1 c 2 cn s 1 c 1 1 c c n so the number of every type of walk is o bn n for some b 42 the bound may seem to contradict the dyck path example but remember that we cut the steps in half to avoid extraneous 0 s a good goal would be to improve this bound to something more meaningful example 3 28 let s 1 1 1 0 1 2 then assuming f b g c are as before 0 1 t 1 f t 3 f 3 0 31 n 1 n 2 b n 6 2 n 5 n 2 b n 1 2 6 n 2 36 n 53 b n 2 2 2 n 9 n 3 b n 3 b n 0 8001188640 2 889881575 n n 3 2 1 1 7475722 n 2 6532889 n 2 4 0131981 n 3 40 we technically do not need the x 6 0 since we assumed there were no steps directly down 41 largest number of walks 42 which matches with the earlier mentioned asymptotic 82 and 0 1 3 t 1 g 31 t 3 12 t 2 12 t 4 g 3 0 31 n 1 n 2 c n 6 n 2 2 n 3 c n 1 2 6 n 2 24 n 23 c n 2 2 n 3 2 n 3 c n 3 c n 0 3488331868 2 889881575 n n 1 0 24757219 n 0 03549572 n 2 0 046925761 n 3 the exponential bound is simply s n 3 n fairly close to the actual asymptotic base and the proportion of excursions to bridges is b n c n 2 293700526 n also just a constant times 1 n finding the asymptotic behavior does not work in every case e g meanders with step set 0 1 1 1 2 1 2 0 2 1 if the asymptotic does not match with empirical data then asyc will notify the user of this is the ratio of nonnegative excursions to bridges always some constant times 1 n the following example is more experimental evidence for this conjecture example 3 29 let s 1 2 3 0 0 1 2 1 2 2 and f b g c as before then 0 1 t 1 t 2 t 1 f t 1 t t 2 1 2 f 3 b n 4 15 7 898354145 n n 3 2 0 1 3 t 1 t 2 t 1 g 4 t 9 15 t 6 27 t 5 54 t 4 66 t 3 27 t 2 27 t 4 g 3 c n 15 3 58 7 898354145 n n the actual recurrences obtained from conversion algtorec are not listed here due to size they are degree 2 order 18 and degree 2 order 16 respectively the base of the exponential is exactly the same for b and c they are the same root of the same polynomial 43 and once again b n c n 232 3 675 1 n 43 the polynomial in question is 4 x 9 27 x 8 27 x 7 66 x 6 54 x 5 27 x 4 15 x 3 4 and the root has index 1 in maple notation 83 to compute the ratio for any step set use the shorthand ratioofwalks s we can also try to reason the ratio heuristically suppose we start with an excursion e we can reorder the steps cyclically or in any order and still have a bridge consider the set of such walks there are size of e such walks the reason for reordering cyclically would be to maintain the unique excursion in the set while the rest are bridges actually e is only unique if it was an irreducible excursion but potentially there is not much overlap similarly from a bridge b we could reorder the steps cyclically and we must obtain at least 1 excursion starting from the step after the minimum altitude of b we actually have the same number of excursions in this cyclic set as points of minimum altitude we have a relation between excursions and bridges that appears to be roughly linear some issues may be that an excursion of length n does not necessarily have size n we still have a linear relationship between the two bounded by max x x y s and even steps with x step 0 do not mess this up too horribly because we are considering excursions and bridges the walk returns to the x axis so can only go so far away before it must start returning since the return rate y x is finite we do not have steps directly up and down this again leads to a linear number of x step 0 allowed steps 3 7 1 discriminant another interesting result from analyzing asymptotic behavior is what the base of the exponent appears to be for all three of our examples the base can be found by taking the reciprocal of the smallest modulus of the roots of the coefficient of the leading term in the minimal polynomial of the bridges g f i e min z 4 z 1 0 1 4 min z 31 z 3 12 z 2 12 z 4 0 1 3 22 3 1 2 89 min z 4 z 9 15 z 6 27 z 5 54 z 4 66 z 3 27 z 2 27 z 4 0 1 7 90 this is the first estimate of the asymptotics from the inverse of the radius of convergence actually the polynomial whose root modulus we need can be taken to be the discriminant 84 of the minimal polynomial which in the step sets given is the same for excursions and bridges in general one method that appears to find the base b for the exponential asymptotic behavior is 1 find the discriminant of the minimal polynomial 2 take the smallest positive real root 3 take the reciprocal of that root this will miss the possible sub exponential factors of n 3 2 etc the shorthand for this computation is implemented as asymptoticbase a more detailed analysis of singulari ties and the associated asymptotics is available in analytic combinatorics by flajolet and sedgewick fs 09 3 7 2 meanders we have yet to analyze the asymptotic behavior of meanders let k denote the g f and d n the number of nonnegative meanders of length n for the case of dyck paths with a step set of 1 1 1 1 since we can have odd length walks now meanders satisfy 1 2 t 1 k t 2 t 1 k 2 0 4 n 1 d n 2 d n 1 n 3 d n 2 0 d n 0 797 n 2 n this says there are roughly 2 283 nonnegative meanders for each bridge of the same length all of the asymptotic behavior in this section was found using the conversion to recurrence and extracting the asymptotics from there it turns out that meanders can follow very different asymptotic behavior depending on the step set 85 example 3 30 for s 1 1 1 0 1 2 0 1 4 t 1 k 3 t 3 t 1 k 2 t 3 t 1 2 k 3 0 93 n 1 n 2 n 3 d n 2 80 n 293 n 3 n 2 d n 1 n 3 115 n 2 793 n 1318 d n 2 4 18 n 3 210 n 2 820 n 1071 d n 3 4 n 4 7 n 2 65 n 152 d n 4 2 n 5 n 4 2 n 11 d n 5 d n 3 5 2 3 n the base of the exponent happens to match the inverse of the smallest modulus of the roots of the discriminant of the minimal polynomial so meanders can by virtue of their endpoint flexibility greatly outnumber excursions and bridges finally meanders do not always follow s n let s 1 1 1 0 1 1 2 2 then 0 1 3 t 2 3 t 1 k t 3 t 1 t 2 3 t 1 k 2 t 2 t 2 3 t 1 2 k 3 d n 0 307 3 13 2 n 0 307 3 303 n the recurrence found was 11 th order and 3 rd degree so is not included here 44 it was pro duced in less than one second using algtorec and s 1 2 2 1 1 0 1 2 2 1 yields relations of 0 1 2 t 2 3 t 1 k t t 2 2 t 2 3 t 1 k 2 t 2 t 2 3 t 1 2 k 3 2 t 2 3 t 1 2 t 2 k 4 d n 7 2 13 n 3 17 2 n 0 7615 n 3 562 n the recurrence for this step set was 25 th order and of 4 th degree 44 the 0 307 is actually a root of 169 x 4 1014 x 3 507 x 2 78 x 4 maple s identify command was used on experimental data 86 the behavior of meanders appears to be a lot harder to peg down than the anticipated bn n for bridges and b n n 3 2 for excursions though it appears that meanders are always at least as large as bridges asymptotically 3 8 applications 3 8 1 combining solutions after obtaining all of these g f s we can produce much more sports are always a subject of interest for a good portion of the population sports statistics are an integral part of many a fan base so a question of interest beyond the number of ways to be tied may be the number of ways to win by at least x the task at hand then is how to describe a walk such as that we have spent the majority of this paper breaking down walks into smaller components we can now use those components to build other types of walks the impor tant step is making sure that we count all of our walks and do not double count any walks suppose we want to win by 2 and never trail by more than 3 f 3 5 will count walks that drop by no more than 3 and we will have a 2 point lead at the end then any walk that stays above that line k 0 will produce what we want so does f 3 5 k 0 count what we want not necessarily f 3 5 ensures that at some point we are exactly 2 points ahead of where we began but depending on the step set we may skip over this lead and never actually hit the altitude 2 steps higher than our beginning in addition f 3 5 may finish with a step up and then down while k 0 could start that way effectively tracing the same walk in different ways thus f 3 5 k 0 double counts some walks and misses others there is at least one way though not as elegant of describing these walks let l denote the g f of interest then l k 3 f 3 0 f 3 1 f 3 2 f 3 3 f 3 4 we count all meanders that never drop more than 3 points and then remove those that change in altitude by exactly 3 2 1 0 1 87 example 3 31 let s 0 1 1 0 1 1 1 2 then l satisfies 0 t 3 t 12 63 t 11 555 t 10 2673 t 9 7671 t 8 13371 t 7 13745 t 6 7554 t 5 1615 t 4 179 t 3 138 t 2 21 t 1 9 t 14 216 t 13 2286 t 12 13986 t 11 54558 t 10 141402 t 9 246687 t 8 288270 t 7 221709 t 6 109548 t 5 33981 t 4 6448 t 3 715 t 2 42 t 1 l 3 t 3 3 t 7 36 t 6 153 t 5 261 t 4 126 t 3 50 t 2 26 t 2 l 2 9 t 6 l 3 and has truncated expansion l t 21 t 2 305 t 3 4064 t 4 52431 t 5 666657 t 6 8420130 t 7 106070229 t 8 1335635352 t 9 16832212452 t 10 the minimal polynomial was derived by finding a groebner basis we had to describe all of k 3 f 3 0 f 3 1 f 3 2 f 3 3 f 3 4 as well which included a chain of describing further walks but those methods are already set and have been shown to be closed 3 8 2 weighted walks one extension that would be fairly easy to implement is adding a weight to each step x y has an associated weight w then for example we would write 45 fa b 1 x y w s w txfa y b y simply multiply by the weight whenever we take a certain step now we can accomplish more with the weights in place if x y w s w 1 and all x 1 then w represents the probability of taking a specific step and then fa b is the g f for the probability that a given walk of length n maintains altitude a y b if we want to know the probability of a bounded walk being a bounded bridge use weights to describe f a b the g f for probability of a general walk being a bounded bridge and divide its coefficients by the appropriate coefficient of fa b the probability of a general walk being bounded this is an explicit 45 taken from general walks in bounded section 3 2 88 description of using pr a b pr a b pr b if all of the weights are the same then simply enumerate each one to get the probabilities it is much easier example 3 32 let us try finding the probability of a general walk with step set s 1 2 1 3 1 1 1 6 1 2 1 2 being bounded above by y 3 and below by y 2 then the g f is explicitly 3 3888 3888 t 756 t 2 972 t 3 12 t 4 t 5 11664 7776 t 2 432 t 3 1296 t 4 t 6 which has taylor expansion 1 t 17 36 t 2 49 108 t 3 77 324 t 4 811 3888 t 5 53 432 t 6 3407 34992 t 7 26483 419904 t 8 58247 1259712 t 9 o t 10 we need the steps to all have the same x value otherwise we aren t representing the probability that a given walk of length n has some property we would somehow be combining the probability that a walk has length n and the probability that it satisfies our desired property ies in a way i cannot currently describe 3 8 3 2 step examples with all of the tools at our disposal let s now use them to produce more information about many sequences bridges with s 1 1 1 k it is well known 46 that the g f for nonnegative excursions denoted f satisfies f 1 tk 1 fk 1 46 try proving it for yourself or prove it for any finite k with this package 89 we would like to show something about bridges with this step set the g f for the first k 0 7 step sets have minimal polynomials t 1 g 1 4 t 2 1 g 2 1 27 t 3 4 g 3 3 g 1 256 t 4 27 g 4 18 g 2 8 g 1 3125 t 5 256 g 5 160 g 3 80 g 2 15 g 1 46656 t 6 3125 g 6 1875 g 4 1000 g 3 225 g 2 24 g 1 823543 t 7 46656 g 7 27216 g 5 15120 g 4 3780 g 3 504 g 2 35 g 1 the general form appears to have leading term k 1 t k 1 kk gk 1 the g 1 term is fairly easy to see have coefficient k 1 k 1 the g 2 term after some manipulations has coefficients that follow k 2 2 k 1 k 2 the computer could only obtain up to k 9 before memory requirements became too large 3 gb allocated from that limited data i found that the g 3 term has coefficient that follows k 3 6 k 1 k 1 k 3 does this generalize and if so how these results are not groundbreaking as we can already enumerate the number of bridges of length a b n with step set 1 a 1 b with the simple a b n an they do allow a different view of the walks by considering how they can be built from copies of themselves duchon numbers the duchon numbers 47 are one of the cases that lohr analyzed for asymptotic behavior lz 17 we can derive more information for the g f which we will denote f of the duchon numbers the sequence is defined as the number of paths of length 5 n from 0 0 to the line y 2 x 3 with unit north and east steps that stay below the line or touch it it is equivalent 47 oeis a 060941 oeig http oeis org a 060941 90 to enumerating excursions with step set 1 5 2 1 5 3 to find the minimal polyno mial for its g f all we have to do is type equalsemiboundedscoringpaths s 0 t f and hit return 0 1 f 2 tf 5 tf 6 tf 7 t 2 f 10 we can also produce the minimal polynomial for the related g f of irreducible walks those that only touch at the endpoints we almost accomplish this with the call specificequalsemiboundedscoringpaths s 0 t f g g 0 0 but to match oeis a 293946 oeij we must allow the stationary walk simply substitute g 0 0 g 1 and we are done 0 g 10 19 g 9 162 g 8 816 g 7 2688 g 6 2 t 6048 g 5 19 t 9408 g 4 73 t 9984 g 3 142 t 6912 g 2 140 t 2816 g t 2 56 t 512 excursions with s 1 2 1 k we have some information for this family in the duchon numbers k 3 but what do they look like in general we will assume gcd 2 k 1 otherwise we could reduce the steps for an equivalent problem the first few g f have minimal polynomial we have made the http oeis org a 293946 91 transformation t t 1 2 k for ease of reading a 001764 k 1 f 3 t f 1 a 060941 k 3 f 10 t 2 f 7 t f 6 t 2 f 5 t f 1 a 300386 k 5 f 21 t 3 2 f 16 t 2 f 15 t 2 3 f 14 t 2 f 11 t f 10 t 2 f 9 t 2 f 8 t 3 f 7 t f 1 a 300387 k 7 f 36 t 4 3 f 29 t 3 f 28 t 3 4 f 27 t 3 3 f 22 t 2 2 f 21 t 2 6 f 20 t 2 3 f 19 t 2 6 f 18 t 2 f 15 t f 14 t 2 f 13 t 2 f 12 t 3 f 11 t 3 f 10 t 4 f 9 t f 1 a 300388 k 9 f 55 t 5 4 f 46 t 4 f 45 t 4 5 f 44 t 4 6 f 37 t 3 3 f 36 t 3 12 f 35 t 3 4 f 34 t 3 10 f 33 t 3 4 f 28 t 2 3 f 27 t 2 9 f 26 t 2 6 f 25 t 2 12 f 24 t 2 6 f 23 t 2 10 f 22 t 2 f 19 t f 18 t 2 f 17 t 2 f 16 t 3 f 15 t 3 f 14 t 4 f 13 t 4 f 12 t 5 f 11 t f 1 a 300389 k 11 f 78 t 6 5 f 67 t 5 f 66 t 5 6 f 65 t 5 10 f 56 t 4 4 f 55 t 4 20 f 54 t 4 5 f 53 t 4 15 f 52 t 4 10 f 45 t 3 6 f 44 t 3 24 f 43 t 3 12 f 42 t 3 30 f 41 t 3 10 f 40 t 3 20 f 39 t 3 5 f 34 t 2 4 f 33 t 2 12 f 32 t 2 9 f 31 t 2 18 f 30 t 2 12 f 29 t 2 20 f 28 t 2 10 f 27 t 2 15 f 26 t 2 f 23 t f 22 t 2 f 21 t 2 f 20 t 3 f 19 t 3 f 18 t 4 f 17 t 4 f 16 t 5 f 15 t 5 f 14 t 6 f 13 t f 1 the degree is simply 1 2 k 1 k 2 if one looks closer they may recognize that the degrees then decrease at a consistent rate the degree drops by k and then by 1 twice to create a group of 3 terms the degree then drops again by k 2 and then by 1 to create a group of 5 terms it can be seen that each polynomial follows this 1 3 5 7 pattern with the power of t decreasing by 1 in each successive group there is always a f 1 included we have empirically shown the general form of the minimal polynomial but were unable to describe what the coefficients themselves are a 001764 oeik and a 060941 oeig are sequences currently in the oeis a 300386 oeil a 300387 oeim a 300388 oein and a 300389 oeio are new and have been http oeis org a 001764 http oeis org a 060941 http oeis org a 300386 http oeis org a 300387 http oeis org a 300388 http oeis org a 300389 http oeis org a 001764 http oeis org a 060941 http oeis org a 300386 http oeis org a 300387 http oeis org a 300388 http oeis org a 300389 92 recently submitted and accepted excursions with s 1 3 1 k let us push our computers further what does this family look like we cannot derive a lot of information empirically as the 1 3 1 5 case already takes 28 seconds to run the case k 7 ran for over one day and had used 3 gib of allocated memory before it was terminated again we made the transformation t t 1 3 k for compact reading a 002293 k 1 f 4 t f 1 a 060941 k 2 f 10 t 2 f 7 t f 6 t 2 f 5 t f 1 a 300390 k 4 f 35 t 5 f 31 t 4 f 30 t 4 f 29 t 4 5 f 28 t 4 f 25 t 3 f 24 t 3 3 f 23 t 3 4 f 22 t 3 10 f 21 t 3 f 19 t 2 f 18 t 2 5 f 17 t 2 3 f 16 t 2 6 f 15 t 2 10 f 14 t 2 f 13 t f 12 t 3 f 10 t f 9 t 4 f 8 t 5 f 7 t f 1 a 300391 k 5 f 56 t 7 2 f 51 t 6 f 50 t 6 f 49 t 6 7 f 48 t 6 f 46 t 5 f 45 t 5 3 f 43 t 5 5 f 42 t 5 6 f 41 t 5 21 f 40 t 5 3 f 37 t 4 3 f 36 t 4 8 f 35 t 4 10 f 34 t 4 15 f 33 t 4 35 f 32 t 4 2 f 31 t 3 2 f 30 t 3 9 f 28 t 3 22 f 27 t 3 10 f 26 t 3 20 f 25 t 3 35 f 24 t 3 3 f 22 t 2 5 f 21 t 2 9 f 20 t 2 18 f 19 t 2 5 f 18 t 2 15 f 17 t 2 f 16 21 t 1 t f 15 t 3 f 13 t 3 f 12 t 5 f 11 t f 10 t 6 f 9 t 7 f 8 t f 1 a 002293 oeip and a 060941 oeig are already in the oeis while a 300390 oeiq and a 300391 oeir are new there appears to be some pattern again in the degree of f though it is not discernible at first with so few datum the degree happens to follow 3 k 3 conjecture 3 33 let s 1 a 1 b with gcd a b 1 let f denote the g f for excursions or meanders or bridges with step set s then the minimal polynomial of f has degree a b a the above conjecture is supported by all of the examples in this section 3 8 3 as well as several other quick tests of accuracy though what does this mean in terms of deconstructing a walk with step set s http oeis org a 002293 http oeis org a 060941 http oeis org a 300390 http oeis org a 300391 http oeis org a 002293 http oeis org a 060941 http oeis org a 300390 http oeis org a 300391 93 this is somewhat intuitive for the unbounded case since there are a b a ways to have a bridge of smallest length a b and we have provided ample evidence that the asymptotic behavior is only off by c n for these excursions 3 9 conclusion and future work to analyze walks we began by examining the first step bounded section 3 2 the last step semi bounded section 3 3 and finally a middle step that crosses the x axis unbounded section 3 6 the way we dissected the g f equations is not unique you could describe them in slightly different ways that may be more optimal however the minimal polynomial is called that for a reason there is no better way to describe the g f except for an exact solution in special cases it is important to make sure you do not double count or miss any walks in your descriptions define your various types of walks in a very particular manner for bounded cases we produced the new oeis sequences a 301379 oeih and a 301380 oeii as well as a 301381 oeis and a 300998 oeit which are not included in this thesis though they were produced in conjunction enumerating some semi bounded and unbounded examples may be much faster by actually solving the polynomial for the g f in cases where deg p 4 or p has nice roots one interesting note that appears in the semi bounded case is that no matter what we have chosen as our step set the minimal polynomial has had terms f 1 this seems to indicate that there is always a way to write semi bounded excursions and meanders as some combination and deductions of copies of only itself though it may be that the self description is extremely complicated seemingly without but it must be there any combinatorial interpretation see example 3 10 we cannot necessarily do that with unbounded cases because there is not always a f term another trick we can use the minimal polynomial for is a bijective proof all of the walks counted by terms with positive coefficients are also equally counted by those terms http oeis org a 301379 http oeis org a 301380 http oeis org a 301381 http oeis org a 300998 94 with negative coefficients the trouble with this is that the two sides are very artificial and rarely something of interest by themselves in section 3 7 we tried looking at the asymptotics of excursions and bridges one note that came up was the relationship between the number of excursions and bridges it is known that the number of dyck paths is 1 n 1 of the total number of bridges with a different looking step set we still obtained a c n asymptotic relationship for a constant c is this always the case we provided some heuristics and examples in support of the relationship but no found definitive proof the relationship to meanders of the same step set appears to be much harder to state exactly a little further in section 3 8 3 we examined many 2 step cases i contributed the new sequences a 300386 oeil a 300387 oeim a 300388 oein a 300389 oeio a 300390 oeiq and a 300391 oeir to the oeis these are equivalent to walks that stay below certain lines of rational slope a further question how does one translate walks with general step sets bounded by lines into bridges excursions or meanders what about bounded by something other than straight lines an extension that would be fairly easy though laborious to implement would be gen eralizing from 2 d walks to 3 d walks or to n dimensional walks beyond simply enumerating walks we might want to know more about them how many peaks or valleys do they contain what is the area beneath the curve how many times does the walk hit its maximal minimal altitude we can try to answer these questions by adding in a catalytic variable to count this new measurement the generating function relations are very similar but the g f s themselves are now functions of 2 or more variables this can lead to systems that are not closed under current descriptions however the system can still be iterated to enumerate terms ayyer and zeilberger analyzed how many times a bounded bridge or excursion hits its boundaries az 08 in the bounded and semi bounded cases the extension to measuring http oeis org a 300386 http oeis org a 300387 http oeis org a 300388 http oeis org a 300389 http oeis org a 300390 http oeis org a 300391 95 the area under the curve has been started the bounded case still yields explicit solutions but the semi bounded and unbounded cases are now left as a system of equations rather than a minimal polynomial thank you for reading this chapter i hope you have enjoyed it and can make use of this package 96 chapter 4 conclusion let us look back at what we have accomplished in chapter 2 we adapted a method of proving the unimodal nature of q binomials to build more families of unimomdal polynomials the special facet of the constructed fami lies is that the unimodal nature is not immediately obvious either an explicit formula or a recurrence with the correct initial conditions produce surprisingly unimodal polynomials in order to enumerate lattice walks in chapter 3 we generalized the technique of de scribing generating function relations with irreducible walks this allowed us to give exact generating functions in the bounded case and minimal polynomials in semi bounded and unbounded cases connected to these minimal polynomials are recurrences for enumera tion once we take a step back we realize that they produce surprisingly integral sequences given the correct initial conditions in both major chapters we produced new sequences for the oeis we have revised results of mathematicians before us to work in more ways than originally intended we created two maple packages to accompany the work and provide avenues for quick and easy investigation into more general questions we contributed to the field of experimental mathematics by devising methods for exploration and using them to gain insights into unimodal polynomial construction and lattice walk generating functions that we otherwise could not have gleaned 97 references aar 00 jenny alvarez miguel amadis and leobardo rosales unimodality and log concavity of polynomials tech report the summer institute in mathematics for undergraduates simu cited on page 161 2000 and 98 george e andrews the theory of partitions cambridge england cam bridge university press july 1998 az 90 gert almkvist and doron zeilberger the method of differentiating under the integral sign journal of symbolic computation 10 1990 571 591 az 07 arvind ayyer and doron zeilberger the number of old time basketball games with final score n n where the home team was never losing but also never ahead by more than w points the electronic journal of combinatorics 14 2007 az 08 two dimensional directed lattice walks with boundaries tapas in ex perimental mathematics vol 457 contemporary mathematics amer math soc providence ri 2008 pp 1 19 bb 90 francesco brenti and thomas h brylawski unimodal polynomials arising from symmetric functions proceedings of the american mathematical soce ity vol 108 april 1990 pp 1133 1141 bkk 17 cyril banderier christian krattenthaler alan krinik dmitry kruchinin vladimir kruchinin david tuan nguyen and michael wallner explicit for mulas for enumeration of lattice paths basketball and the kernel method arxiv 1609 06473 v 2 2017 bo n 06 miklo s bo na a walk through combinatorics hackensack new jersey world scientific publishing co 2006 borw 05 r brak a l owczarek a rechnitzer and s g whittington a directed walk model of a long chain polymer in a slit with attractive walls j phys a 38 2005 4309 4325 bra 15 petter bra nde n unimodality log concavity real rootedness and beyond hand book of enumerative combinatorics 87 2015 437 dfv 80 y i petunin d f vysochanskij justification of the 3 rule for unimodal distributions theory of probability and mathematical statistics 21 1980 25 36 dr 71 e a dimarzio and r j rubin adsorption of a chain polymer between two plates j chem phys 55 1971 4318 4336 98 duc 00 philippe duchon on the enumeration and generation of generalized dyck words discrete mathematics 225 2000 121 135 ez 15 shalosh b ekhad and doron zeilberger the method of guess and check arxiv 1502 04377 v 1 2015 fs 09 philippe flajolet and robert sedgewick analytic combinatorics cambridge university press june 2009 gau 23 carl friedrich gauss theoria combinationis observationum erroribus min imis obnoxiae pars prior commentationes societatis regiae scientiarum gottingensis recentiores 5 1823 kp 11 manuel kauers and peter paule the concrete tetrahedron springer 2011 lz 17 andrew lohr and doron zeilberger asymptotics of rational catalan combi natorics rsp april 2017 mr 09 marni mishna and andrew rechnitzer two non holonomic lattice walks in the quarter plane theor computer science 410 2009 3616 3630 nei neil j a sloane oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org oeia oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 002522 oeib oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 302612 oeic oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 302644 oeid oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 302645 oeie oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 302646 oeif oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 000984 oeig oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 060941 oeih oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 301379 oeii oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 301380 oeij oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 293946 99 oeik oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 001764 oeil oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300386 oeim oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300387 oein oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300388 oeio oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300389 oeip oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 002293 oeiq oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300390 oeir oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300391 oeis oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 301381 oeit oeis foundation inc 2018 the on line encyclopedia of integer sequences http oeis org a 300998 o h 90 kathleen o hara unimodality of gaussian coefficients a constructive proof journal of combinatorial theory series a 53 1990 29 52 pro 82 robert a proctor solution of two difficult combinatorial problems with linear algebra the american mathematical monthly 89 1982 no 10 721 734 sta 89 richard p stanley log concave and unimodal sequences in algebra combi natorics and geometry annals of the new york academy of sciences 576 1989 no 1 500 535 sz 94 bruno salvy and paul zimmermann gfun a maple package for the manipula tion of generating and holonomic functions in one variable acm transactions on mathematical software toms 20 1994 no 2 163 177 vat 09 vince vatter binomial coefficients unimodality log concavity math 68 al gebraic combinatorics dartmouth college september 2009 vr 00 e j janse van rensburg the statistical mechanics of interacting walks poly gons animals and vesicles vol 18 oxford university press oxford 2000 wz 85 jet wimp and doron zeilberger resurrecting the asymptotics of linear recur rences journal of mathematical analysis and applications 111 1985 no 1 162 176 100 zei 89 a doron zeilberger a one line high school algebra proof of the unimodality of the gaussian polynomials n k for k 20 pp 67 72 springer us new york ny 1989 zei 89 b kathy o hara s constructive proof of the unimodality of the gaussian polynomials amer math monthly 96 1989 no 7 590 602 abstract acknowledgements dedication list of tables list of figures 1 introduction 2 unimodal polynomials 2 1 introduction 2 1 1 motivation 2 1 2 symmetric and unimodal 2 1 3 partitions 2 1 4 chapter organization 2 2 maple program 2 3 q binomial polynomials 2 4 original recurrence 2 5 altered recurrence 2 5 1 restricted partitions 2 5 2 adjusted initial conditions 2 5 3 adjusted recursive call 2 6 oeis 2 7 conclusion and future work 3 lattice walk enumeration 3 1 introduction 3 1 1 motivation 3 1 2 definitions 3 1 3 chapter organization 3 2 bounded 3 2 1 walking anywhere 3 2 2 returning to the x axis 3 3 semi bounded 3 3 1 arbitrary lower limit 3 3 2 meanders 3 4 guess and check method 3 5 algebraic to recursive 3 5 1 conversion 3 5 2 searching 3 6 unbounded 3 6 1 walking anywhere 3 6 2 returning to the x axis 3 6 3 alternative method 3 6 4 selected step sets 3 6 5 time comparison 3 7 asymptotics 3 7 1 discriminant 3 7 2 meanders 3 8 applications 3 8 1 combining solutions 3 8 2 weighted walks 3 8 3 2 step examples 3 9 conclusion and future work 4 conclusion references