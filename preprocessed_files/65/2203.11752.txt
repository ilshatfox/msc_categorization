costarica estimator for rollback less systems handling in iterative co simulation algorithms yohan eguillon 1 2 0000 0002 9386 4646 bruno lacabanne 2 0000 0003 1790 3663 and damien tromeur dervout 1 0000 0002 0118 8100 1 institut camille jordan universite de lyon umr 5208 cnrs u lyon 1 villeurbanne france yohan eguillon damien tromeur dervout univ lyon 1 fr 2 siemens digital industries software roanne france yohan eguillon bruno lacabanne siemens com abstract co simulation is widely used in the industry due to the emer gence of modular dynamical models made up of interconnected black boxed systems several co simulation algorithms have been developed each with different properties and different levels of accuracy and robust ness among them the most accurate and reliable ones are the iterative ones although they have a main drawback in common the involved sys tems are required to be capable of rollback the latter denotes the ability of a system to integrate over a co simulation time step that has already been simulated non rollback capable system can only go forward in time and every integrated step is definitive in practice the industrial mod elling and simulation platforms rarely produce rollback capable systems this paper proposes a solution that slightly changes the co simulation methodology and that enables to use iterative co simulation methods on a modular model which contains non rollback capable systems in case the latter represent ordinary differential equations the idea is to replace such a system by a simplified version which is used to estimate the results of the integrations instead of integrating the real system once the co simulation method s surrogate iterations on these estimators predict the convergence on the co simulation step the non rollback capable systems genuinely integrate the step using the estimated solution on the other systems before moving forward transforming the iterative co simulation method into a non iterative one keywords cosimulation iterative co simulation method solver cou pling coupling algorithm integration method fmi rollback free pseudo iterative supported by organization siemens digital industries software ar x iv 2 20 3 11 75 2 v 1 ee ss s y 2 2 m ar 2 02 2 2 y eguillon et al 1 introduction co simulation is an area of research that now attracts more and more inter est in the industry 14 also called simulators coupling or solvers coupling a co simulation involves two or more interconnected systems each of the latter contains its own solver the set of interconnected systems is called a modular model the ability to connect such systems makes it possible to assemble modular models out of black boxed systems in the case of multiphysics simulation this enables each system to embed a solver tailored to the physics it represents for instance electrical systems can use a solver method dedicated to the electri cal simulation fluid systems can benefit from simulation algorithms preserving conservation laws etc in addition the intellectual property of the system man ufacturer can be protected even though the system can be simulated thanks to a simple set of interactions the industrial interest of co simulation lies in this possibility simulating a modular model made of systems which do not need to disclose their know how a minimal set of possible interactions is required from such systems in case one of them is not supported no co simulation can occur otherwise basic co simulation algorithms can be used to simulate the modular model many co simulation algorithms have been developed 20 3 16 4 31 8 6 and an alyzed 21 28 29 over the past few years indeed the most basic ones are usually not sufficient to generate accurate enough results the main trade off that is tackled by the advanced co simulation algorithms is the balance between accuracy and computational time a high accuracy can usually be reached when additional information can be retrieved from the systems among others the model based methods 6 34 33 use structural information in order to adapt the co simulation so that it leads to very accurate results usually through preser vation of some quantities for instance energy on a physical coupling 25 26 the main drawback of such methods is that the systems must be disclosed other methods do not require systems to be disclosed modular models can be made of interconnected black boxed systems such methods when they cor respond to advanced co simulation algorithms 24 15 11 12 18 usually require the systems to perform advanced actions in addition to the minimal set of possible ones indeed depending on the modeling and simulation platform that generates a system the latter might be able to perform more than just the basic actions these advanced actions are called capabilities some of these advanced capabilities are namely formalized in the fmi stan dard 7 with a dedicated mechanism for each system to notify the supported and unsupported ones some capabilities are well known and lots of co simulation methods use them some other are exotic and some capabilities are very rare in practice among the latter the rollback is one of the most promising yet scarce the rollback is the ability of a system to re integrate itself on a time slice on which it has already undergone integration when every system of a modular model has this capability an iterative co simulation algorithm can be used 20 3 4 11 12 18 31 30 or the methods referred to as icss implicit cou costarica estimator for iterative co simulation methods 3 pling schemes in 35 iterative methods when they converge are a good way to reach a required accuracy on a wide range of models while supporting black boxed systems the only problem of these methods is the scarcity in practice of rollback capable systems this paper introduces an alternative that mimics the rollback on rollback free systems corresponding to odes ordinary differential equations so that iterative co simulation algorithms can be adapted into a version that can be applied on modular models even if the latter involve rollback free systems this adaptation consists in replacing the rollback free systems by a simplified version which is used to estimate the results of the integrations instead of integrating them for real these simplified systems are estimators which require advanced capabilities that are less rare than the rollback on most of the black boxed sys tems embedding a tailored solver once the co simulation method s surrogate iterations on these estimators predict the convergence on the co simulation step the non rollback capable systems genuinely integrate the step using the esti mated solution on the other systems before moving forward thus transforming the iterative co simulation method into a non iterative adaptation of it on each non rollback capable system the associated estimator used in the surrogate iterative stage of the co simulation method is designed to imitate the integration as if it was done for real the predicted quantities are the data of the system that will be used by other systems the output coupling variables and eventually related data such as their time derivatives this estimation depends among other things on its input coupling variables determined by the co simulation method such an estimator possible on most of the systems given very common capabilities that do not require system disclosure lead to a surrogate system on the coupling variables the basics of this estimator are the following the ode of the system is linearized at the most recent reached time and thanks to a laplace transform of this linearized system a relation can be established between the input coupling variables and the output coupling variables in case the input coupling variables can be expressed as polynomials which is the case in the overwhelming majority of cases the output values at the time to reach have a linear expression in terms of the coefficients of the polynomial of the input coupling variables this linear expression involves transfer matrices that can be obtained using patel misra method 1 and their inverse laplace transform that can be computed with the gaver stehfest algorithm 17 this paper is structured as follows the motivation of a step estimator and the associated formalism will be described first then the costarica itself will be detailed both formerly mathematically and practically pseudo code finally a few examples will be presented in order to convince the reader about the practical aspect of the costarica process 4 y eguillon et al 2 framework and motivations elements of formalism about ode systems for co simulation will be given in this section starting from the equations inside of the systems the notions of co simulation step or macro step will be defined as well as the simulation function and its iterative version the purpose is to explain how a step estimator can approximately or exactly solve the problem of the application of an iterative co simulation algorithm to a modular model 2 1 system and macro step let s consider an abstraction of an iterative co simulation algorithm the latter can be any method that needs to proceed several times an integration of one or more systems on the same time slice 20 12 30 31 we will formerly define what an iterative co simulation method implies and how it works first of all as mentioned in the introduction each system is supposed to represent an ode as the systems may be and usually are connected with other systems of the modular model we consider the inputs u and the outputs y being vectorial functions of the time respectively of dimension nin and nout with x being the state vector of dimension nst a given system represents the ode equation as follows dx dt f t x u y g t x u where t tinit tend x l tinit tend rnst u l tinit tend rnin y l tinit tend rnout 1 the f and g functions of a system are respectively called the derivatives and the outputs functions of the ode the initial time tinit and the final time tend are supposed to be the same on every system of a modular model so that the co simulation occurs on the time domain tinit tend moreover a co simulation system embeds a solver abstractly a solver em bedded in a system enables to get the output response of the latter to a certain stimulus of its inputs which can be seen like a vectorial command and on a small time domain that starts at a time where the states have an initial value this small time domain is either called a macro step or a co simulation step as opposed to the micro step also called solver step in practice the output re sponse can rarely be retrieved on the whole macro step but only its final value can be retrieved as well as its time derivative in some cases the ability to retrieve intermediate values might exist in some cases as mentioned in 5 the system ode and solver can thus be represented by a discretized system over any macro step t n t n 1 where tinit 6 t n t n 1 6 tend dx n dt f t x n u n y n g t x n u n where t t n t n 1 x n l t n t n 1 rnst u n rn t nin y n l t n t n 1 rnout 2 costarica estimator for iterative co simulation methods 5 in 2 n 0 nmax denotes the index of the macro step and nmax the number of macro steps on the total co simulation time domain tinit tend please note that we are assuming that the inputs are polynomial in time in this paper in 2 we have u n rn t nin with n n denoting the maxi mum polynomial degree among all the nin inputs in most of the co simulation methods the inputs are not known on t n t n 1 when the integration of 2 is being performed so an extrapolation has to be made on this interval most of these extrapolations or interpolations used in practice are covered by the poly nomial form assumption zero order hold 31 first order hold hermite entries 13 12 smooth polynomial extrapolations 9 as a co simulation system interacts through its inputs and outputs the ini tialization of the state values at each macro step is done with respect to their ending values at the end of the previous macro step in other words the initial condition of 2 is x 0 tinit x 0 xinit 3 for the first macro step where the system embeds the information xinit and n 1 nmax x n t n x n lim t t n t t n x n 1 t 4 for the other macro steps the retrievable output at the end of a macro step n will be denoted by y n 1 and defined by y n 1 lim t t n 1 t t n 1 y n t 5 moreover we let y 0 be defined as the initial outputs of the system these initial outputs are supposed to be a known data of the co simulation model throughout this paper quantities corresponding to evaluation of vectorial or scalar time dependent function at a given time will be denoted by the name of the function with a tilde symbol added to it in particular x n rnst because x n 1 l t n 1 t n rnst see 4 and y n 1 rnout because y n l t n t n 1 rnout see 5 finally a call to a system on a given co simulation step t n t n 1 can be seen as a call to the following function called simulation function co simulation step function or simply step function s n rnst l t n t n 1 rnin rnst rnout x n u n 7 x n 1 y n 1 6 less formally yet more comprehensive a call to the step function acts as follows states at the end of the step outputs at the end of the step t s step index states at the beginning of the step input command over the step t 6 y eguillon et al in practice the successive calls to the s n function on a given system on successive macro steps t n t n 1 t n 1 t n 2 t n 2 t n 3 are done with only control on the inputs u n u n 1 u n 1 and with only retrievable outputs y n 1 y n 2 y n 3 indeed the system keeps its states from a call to the other at the correspond ing time both being the end of a macro step and the beginning of the upcoming one 2 2 rollback formalism iteration the co simulation algorithm has several roles among those the definition of the time mesh t 1 t 2 t nmax 1 also called the time stepping has been developed in the literature 27 5 22 19 the definition of the input variables another task the co simulation method is responsible of is not always a simple dispatching of the corresponding connected output values indeed such a dis patching might not be trivial on asynchronous cases 23 13 and sometimes the inputs might be reconstructed e g by using extrapolation on the past values 20 or with other methods 13 10 a particular range of methods called the iterative co simulation algorithms are namely designed to find very accurate input commands by iterating on the set of interconnected systems until a satisfactory result is found for instance the outputs and corresponding inputs can be compared at the end of each macro step so that a given coupling relationship is satisfied 20 31 30 this is namely the case for co simulation methods based on the fixed point method 20 11 the newton method 31 or newton like methods 12 when such algorithms are used every system must be able to integrate a step more than once this is called the rollback with the formalism introduced in 2 1 a rollback capable system is simply a system on which the step function 6 can be called several times on the same macro step t n t n 1 let s denote by a left subscript m the iteration index of a given call of the step function on a given macro step let also mmax n be the iteration index of the last iteration done on the macro step t n t n 1 on a given macro step t n t n 1 at a given iteration m 0 mmax n the call to the step function generates the mth output values m x n 1 m y n 1 s n mmax n 1 x n m u n 7 in 7 we can namely identify mmax n 1 x n the state variables at the end of the previous macro step m u n the input commands computed by the co simulation algorithm at the mth iteration of the co simulation on the step t n t n 1 and s n the step function defined in 6 the co simulation algo rithm can retrieve the outputs m y n 1 of this system at t n 1 corresponding to the final value on this step of the output response to the stimulus mmax n 1 x n costarica estimator for iterative co simulation methods 7 2 3 rollback formalism rejection iterative co simulation algorithms might redefine the end of the current co simulation step t n 1 for instance when they are based on a numerical iterative method that diverged or that did not converge fast enough in such cases the co simulation step t n t n 1 is said to be rejected 12 27 in this case a step restarting from t n but with a different ending time t n 1 is redefined and the iterative process restarts in the newly defined macro step this namely occurs in the context of adaptive step size iterative co simulation methods for the sake of readability no supplementary subscript of superscript will be added to the quantities introduced above we will simply consider that when the macro step starting at t n is considered the method can redefine t n 1 this case will be denoted as divergence the counter m restarts at 0 in this case and at each macro step n we can consider that mmax n 1 corresponds to the iteration that led to convergence and acceptance on the previous macro step fig 1 successive calls to the step function corresponding to a given scenario the same one as in figure 3 8 y eguillon et al figure 1 shows a scenario with both iterations described in 2 2 and rejections described in this subsection the parallel calls to the step function are also given next to each step computation 2 4 iterative co simulation algorithm for the sake of genericity let s consider an abstraction of an iterative co simulation method such method can be seen as a set of two algorithms also called pro grams an orchestrator program running in parallel with as many clones of a worker program as there are systems each clone of the worker program is responsible for one system also called simulation unit in this context that can in practice come from any modelling and simulation tool for instance simcenter amesim simulink or anything represented with the fmi co simulation standard 7 figure 2 schematically shows the architecture of such a way to represent a given co simulation algorithm fig 2 orchestator workers formalism of a co simulation algorithm an abstraction of the worker program is presented in algorithm 1 please note that on this algorithm the computations of u and t n 1 at each step are not detailed as they depend on the algorithm itself they might be determined using data received from the orchestrator program deduced from the past of the connected output computed from a numerical method also t n 1 t n might change across t n in the case of adaptive step size co simulation methods 27 22 as algorithm 1 is an abstraction of a worker program of an iterative co simulation method some iterative co simulation methods might need to have their formalism slightly adapted in order to fit in with this formalism for in stance some methods never reject a step in that case exiting from the internal loop also exits from the co simulation loop in other words the co simulation loop might do one iteration only for each macro step without loss of generality costarica estimator for iterative co simulation methods 9 algorithm 1 worker program of an iterative co simulation method 1 n 0 2 t 0 tinit 3 while t n tend do time loop 4 while step starting on t n is not converged do co sim step loop 5 m 0 6 method re computes t n 1 7 while true do internal loop 8 method computes m u n 9 compute m y n 1 by step integration s n with inputs m u n 10 from m y n 1 and outputs of other systems on other workers method decides if the step is converged to be redone or rejected 11 if step t n t n 1 is to be redone then 12 m m 1 13 else either step is converged or has been rejected 14 break 15 mmax n m 16 n n 1 in algorithm 1 three nested loops can be identified the time loop denoting the global forward movement of time during the co simulation the co simulation step loop denoting the attempts to locally move for ward once a time t n has been reached in other words this loop tries to reach convergence until a time strictly further than the currently farthest time where a convergence has been obtained and the internal loop corresponding to the attempt to validate a given macro step t n t n 1 either by convergence of an iterative numerical method like in 11 12 or 31 with a given procedure requiring several evalua tions of the step function on a macro step like in 30 or with any other methodology a way to visualize how these nested loops correspond to a co simulation the scenario presented in figure 1 is shown together with these different loops in figure 3 10 y eguillon et al fig 3 nested loops of an iterative co simulation algorithm and the corresponding scenario the same one as in figure 1 figure 3 as well as figure 1 shows that the rollback capability is required on the systems that compose a modular model meant to undergo a co simulation done with an iterative co simulation algorithm 2 5 replacing the rollback with a step estimator the idea of this paper is to replace the stages on which the rollback is required replacing the integrations by estimations on the non rollback capable systems would enable the latter to avoid moving forward in time in a macro step before convergence in other words the idea is to replace all integrations inside of the co simulation step loop and the internal loop by an estimation in order to let the co simulation algorithm find the inputs that lead to a convergence once convergence is reached the forward movement in time is done by a single genuine integration algorithm 2 represents this adaptation applied on algorithm 1 costarica estimator for iterative co simulation methods 11 algorithm 2 worker program of an iterative co simulation method adapted to a rollback less system 1 n 0 2 t 0 tinit 3 while t n tend do time loop 4 while step starting on t n is not converged do co sim step loop 5 m 0 6 method re computes t n 1 7 while true do internal loop 8 method computes m u n 9 compute m y n 1 by step integration s n with inputs m u n 10 compute m y n 1 estimator of m y n 1 depending on m u n 11 from m y n 1 and outputs of other systems on other workers method decides if the step is converged to be redone or rejected 12 if step t n t n 1 is to be redone then 13 m m 1 14 else either step is converged or has been rejected 15 break 16 mmax n m 17 compute mmax n y n 1 by step integration s n with inputs mmax n u n 18 n n 1 in algorithm 2 the strikethrough line has been removed from algorithm 1 and the boxed lines added to it the real integrations now only occur on successive steps of the time loop a first one on t 0 t 1 and then a single one on t 1 t 2 and then a single one on t 2 t 3 and so on until the last one on t nmax 1 t nmax where t nmax tend this way the system behaves as if it were used by a non iterative co simulation method and the iterative co simulation method can still iterate thanks to the estimations on the nested loops co simulation step loop and internal loop the estimator suggested in this paper is the costarica one yet this pro cess can be used with any estimator reduced versions of the concerned systems surrogate models moreover workers only need to be transformed from al gorithm 1 to algorithm 2 when they are attached to a system that is not capable of rollback see figure 2 indeed hybrid configurations both involving rollback capable and rollback less systems can be implemented in this case only the workers attached to rollback less systems must be adapted 12 y eguillon et al 3 costarica estimator costarica stands for cautiously obtrusive solution to avoid roll back in iterative co simulation algorithms the way it avoids requiring the rollback has been explained in 2 5 yet the cautiously obtrusive part hasn t this will be explained in this section and then the estimator itself will be defined finally a fast version of the update of this estimator will be given 3 1 cautious obtrusiveness the costarica process has been conceived to be usable in industrial co simulations one of the main constraints this specification brings is the need for genericity indeed model based co simulation approaches 34 33 25 26 usually take advantage of the knowledge about the systems internal structure yet industrial co simulation algorithms don t for the sake of genericity 16 31 9 12 13 although costarica is not a co simulation algorithm it is an estimator acting as described in 2 5 it must comply with the genericity specification this implies two things the required advanced interactions must be standardized details in 3 1 1 and they must be present on most of the systems details in 3 1 2 3 1 1 black box and interfacing as black boxed systems must be handled no assumptions can be done about what is inside of the systems no physical based information can be retrieved regarding the generic interactions that are possible without disclosing the systems there exists a standard on which we can base our method the fmi standard functional mock up interface 7 indeed a very large majority of modelling and simulation tools offer a way to export a system as an fmu functional mock up unit id est a standardized interface for the system referring to the features that are available in the fmi interface makes it possible to set up a generic procedure since we at least know that these actions are generic please note that although the considered interactions are among those listed in the fmi standard they might also be very similar to interactions available with other interfaces in this paper we consider five among the numerous possible interactions defined in the fmi standard 7 the support of time dependent usually polynomial inputs the possibility to retrieve instantaneous values of the internal state variables the possibility to retrieve the directional derivates the possibility to retrieve the time derivative of the outputs and the rollback costarica estimator for iterative co simulation methods 13 these interactions are not possible on any fmu id est on any system with an fmi interface yet each and every fmu embeds the information about the available interactions it provides this info is called the capability flag 3 1 2 required capabilities we distinguish the capabilities that costarica must mimic in case the algorithm on which this process is used requires them from the capabilities costarica requires in order to produce the estimations of the calls to the step function capabilities required by the co simulation algorithm the aim of costarica is to replace the rollback by estimating the re sults of the step function knowing that a legitimate question could be does costarica mimics calls to the step function on a system that has advanced capabilities such as time depending inputs the answer is yes for two advanced capabilities the time dependent inputs as far as the latter are polynomial in time and the ability to retrieve the time derivatives of the outputs at the end of a macro step in other words a co simulation method that requires these two advanced interactions can still use costarica as far as this process can mimic these interactions during the estimated steps capabilities required by costarica the costarica estimator requires some advanced capabilities from the system on which the rollback will be mimicked these capabilities are the pos sibility for the system to provide its internal state variables and directional derivatives at a given time in practice the reached time fortunately these capabilities are way more common than the rollback itself 14 y eguillon et al 3 1 3 summary the relation between the above mentioned interactions capabilities and costar ica are presented in table 1 table 1 capabilities related to costarica interaction capability name required by costarica in fmi standard costarica mimics it support of caninterpolateinput no it can polynomial inputs getting internal state variables not a capability yes nointernal state variables must be exposed getting directional providesdirectionalderivative yes no derivatives getting output maxoutputderivativeorder no it can time derivative rolling back cangetandsetfmustate no yes this is its purpose in the fmi standard nothing forces a modelling and simulation platform to reconstruct inputs with a polynomial shape when the capability caninterpo lateinputs is active in this paper we only consider the case where the inputs are reconstructed with a polynomial shape 3 2 estimator definition let s consider that the system already reached a time t n to avoid the loss of generality at the beginning of the co simulation we can consider that the system reached t 0 tinit let s build the costarica estimator based on quantities that the system can compute without moving forward in time the estimator is supposed to estimate the behavior of the system to a cer tain stimulus at the iteration m this stimulus is m u n as seen in 2 2 the costarica estimator only works on polynomial inputs see 2 covering the zero order hold case among others as the latter can be seen as polynomial of de gree 0 let s define n the maximum polynomial order of the inputs produced by the co simulation algorithm we denote by a the coefficients of the polynomials of every coordinate of the polynomial inputs n 0 nmax m 0 mmax n m u n t 7 n k 0 m a n jk t k j 1 nin 8 costarica estimator for iterative co simulation methods 15 let s consider the state space representation of 2 a n b n c n andd n matrices contain the instantaneous directional derivatives at time t n they are recoverable thanks to the providedirectionalderivatives capability see table 1 dx n dt a n m x n b n m u n m y n l c n m x n d n m u n where a n mnst nst r b n mnst nin r c n mnout nst r d n mnout nin r 9 in 9 m y n l l t n t n 1 rnout is the linear part of the output re sponse of the system to the stimulus m u n on t n t n 1 two phenomena can explain the difference between m y n l and m y n the non linearity of the system in case the system is non linear and time dependent outputs in case of a predefined signal for instance or an added offset converting physical units like degrees celsius into degrees fahrenheit for instance to take this difference into account we define the control part of the out puts as the difference between them and their linear part m y n c m y n c n x n d n m u n l t n t n 1 rnout 10 as the system has already reached the time t n and as the co simulation algorithm is supposed to use costarica at the stage where an estimation of the step function is required the following quantities are known table 2 known quantities at t n quantity definition source domain y n lim t t n t t n mmax n 1 y n 1 t iterative version of 5 the system thanks to the basic mandatory interaction to provide its outputs last call to s n 1 rnout x n lim t t n t t n mmax n 1 x n 1 t iterative version of 4 the system with the getting internal state variables interaction see table 1 rnst a n b n c n d n instantaneous directional derivatives the system with the getting directional derivatives interaction see table 1 matrices see 9 for the sizes m u n t 7 n k 0 m a n jk t k j 1 nin the co simulation algorithm as shown in algorithm 2 vectorial polynomial rn t nin 16 y eguillon et al the estimator should use the quantities from table 2 and potentially their equivalent at previous communication times like t n 1 t n 2 to compute the estimators of table 3 table 3 estimators at t n 1 estimator notation estimated quantity domain m y n 1 output response of the system to the stimulus m u n at the end of the macro step rnout m y n 1 time derivative of the output response of the system to the stimulus m u n at the end of the macro step rnout these estimators will be split into two terms their control part and their linear part m y n 1 y n 1 c m y n l m y n 1 y n 1 c m y n l 11 please note that in expressions 11 the control terms have no iteration indices indeed as the linear terms are supposed to be the ones already taking into account the behavior of the linearized system with the inputs the con trol terms might not depend on these inputs moreover none of the different estimation strategies for such terms presented in 3 2 1 depend on the inputs consequently instead of having 0 y n 1 1 y n 1 being equals we simply removed the iteration index 3 2 1 control part estimation in order to estimate the control parts of the estimators at time t n 1 we use the following vectorial sequences y n c n 0 nmax defined by n 0 nmax y n c y n c n x n d n mmax n 1 u n 1 t n 12 where by convention we consider that mmax 1 u 1 is constant and equal to the initial inputs of the system which are known data on every system of a given co simulation model once the system reached time t n the y n c n 0 n are known and the estimators y n 1 c and y n 1 c need to be computed any reconstruction algorithm can be used costarica estimator for iterative co simulation methods 17 simplest reconstruction the simplest definition of the control terms of the estimators has to be un derstood as the one using the least amount of points in the case of the output values this corresponds to a simple zero order hold y n 1 c zoh y n c 13 as the zero order hold cannot provide non zero time derivatives it cannot be used for the control term of the output time derivatives estimator therefore zoh estimation for control part can only be used when output time derivatives do not need to be estimated in other words when the co simulation algorithm does not require the time derivatives of the outputs of the systems first order reconstruction in case the co simulation algorithm requires the time derivative of the out puts we can increase the number of points to obtain a first order hold estimator for the outputs y n 1 c foh y n c t n 1 t n t n t n 1 y n c y n 1 c 14 so that the time derivatives can be estimated analogously y n 1 c foh 1 t n t n 1 y n c y n 1 c 15 the problem with this method is that the estimations can only occur from t 2 as two previous points need to exist at t 0 all data are supposed to be known initialization of the co simulation model but for the estimation at t 1 first order hold cannot be used during this estimation only y 1 c zoh can be used regarding the output values and artificially arbitrary 0 regarding the output time derivatives flexible order reconstruction as it might be difficult to know which reconstruction order is relevant zero one or more auto adaptive methods can be used for instance 19 or the flexible order signal reconstruction method presented in 13 enable to try to catch the best order at each step and for each coordinate as outputs might be vectorial and this is easily adaptable to the output time derivatives this flexible order reconstruction method the one in 13 is the one that has been used in the examples presented at the end of this paper 18 y eguillon et al 3 2 2 linear part estimation in order to estimate the outputs at time t n 1 using the known data at t n as presented in table 2 we will consider a linear ode problem from 0 to t n where the latter denotes the macro step size t n t n 1 t n 16 in order to express the time shifted problem we need to dispose of a time shifted version of the inputs this will be denoted with a caron symbol t 0 t n m u n t n k 0 m a n jk t k j 1 nin m u n t t n 17 we will now compute the value of the time shifted version of the linear system 9 that is to say d m x n dt a n m x n b n m u n m y n c n m x n d n m u n with m x n 0 x n as defined in table 2 18 the estimator we are computing is given by m y n 1 lim t t n t t n m y n t 19 let s compute the polynomial coefficients of the time shifted inputs based on the polynomial coefficients of the inputs j 1 nin m u n t j m u n t t n j n k 0 m a n jk t t n k n k 0 m a n jk k l 0 k l t l t n k l 06 l 6 k 6 n m a n jk k l t l t n k l n l 0 n k l m a n jk k l t l t n k l n l 0 t l n k l m a n jk k l t n k l n l 0 t l m a n jl 20 costarica estimator for iterative co simulation methods 19 by switching l and k in the above computations we get the expressions of the polynomial coefficients of the vectorial polynomial m u n j 1 nin k 0 n m a n jk n l k m a n jl l k t n l k 21 note for the sake of readability for the following computations in this subsection the newly introduced quantities won t have any m and n left and right superscripts despite the fact that they change depending on the macro step and the iteration this will only apply to the computations that will lead to the m y n 1 outputs estimator let mnin n 1 r be the matrix representation of the coefficients of the polynomial of all coordinates of the time shifted inputs m a n jk j 1 nin k 0 n 22 the rows and columns indexing of the matrix are intentionally numbered starting from 1 and starting from 0 respectively as the rows represent the differ ent coordinates from 1 to nin and the columns represent the successive terms of the polynomials from 0 for constant term to n for the term of maximum degree let s define the laplace transforms of the inputs outputs and states of the time shifted linear system 18 x x s l m x n s l r rnst u u s l m u n s l r rnin y y s l m y n l s l r r nout 23 we can now write the laplace transform of the time shifted linear system 18 sx x n a n x b n u y c n x d n u 24 let p and g be the matrix functions of the laplace domain as defined in 25 in particular g is the transfer function of the linear system p p s c n si a n 1 l r mnout nst r g g s p s b n d n l r mnout nin r 25 with p and g as defined in 25 we can use 24 to write y g u p x n 26 20 y eguillon et al the next step consists in splitting u into two parts one depending on the coefficients and one depending only on n u l m u n s j 1 nin l t 7 n k 0 m a n jk t k s j 1 nin t 7 n k 0 a jkl t k s j 1 nin u 27 where u l t 7 t k s k 0 n k sk 1 k 0 n 28 in order to remove ambiguity in the upcoming calculations let s define the notation as the outer product particular case of tensor product in particular applied to a matrix m and vector v the outer product gives a 3 rd order tensor n 1 n 2 n 3 n 3 m mn 1 n 2 r v rn 3 m vt m i 1 i 2 v i 3 i 1 1 n 1 i 2 1 n 2 i 3 1 n 3 29 in 29 the vector v is transposed so that vt is a row vector indeed this enables an analogy with the kronecker product kron n 1 n 2 n 3 n 3 m mn 1 n 2 r v rn 3 q mn 2 n 3 r m vt q n 2 i 2 1 n 3 i 3 1 m kron vt i 1 i 2 1 n 3 i 3 q i 2 i 3 i 1 1 n 1 n 2 i 2 1 n 3 i 3 1 m i 1 i 2 v i 3 q i 2 i 3 i 1 1 n 1 m kron vt vec qt 30 where vec qt denotes the vectorization of the matrix qt formed by stacking the columns of qt into a single column vector this can also be seen as the concatenated rows of the matrix q transposed into a single column vector costarica estimator for iterative co simulation methods 21 among other properties we notice the following the reordering of a matrix matrix vector product n 1 n 2 n 3 n 3 m mn 1 n 2 r v rn 3 q mn 2 n 3 r m q v m n 3 i 3 1 q i 2 i 3 v i 3 i 2 1 n 2 n 2 i 2 1 m i 1 i 2 n 3 i 3 1 q i 2 i 3 v i 3 i 1 1 n 1 n 2 i 2 1 n 3 i 3 1 m i 1 i 2 q i 2 i 3 v i 3 i 1 1 n 1 m vt q 31 thanks to all the elements introduced above we can express the linear con tribution to outputs estimator as the inverse laplace of y on the step size t n as this is the final time of the time shifted system 18 m y n 1 l l 1 y t n l 1 gu px n t n from 26 l 1 gu t n l 1 px n t n from l 1 linearity l 1 g u t n l 1 px n t n from 27 l 1 g u t t n l 1 px n t n from 31 l 1 g u t t n l 1 p t n x n from l 1 linearity gv pv x n 32 with gv l 1 g u t t n pv l 1 p t n 33 22 y eguillon et al analogously we can write the expression of y n 1 l the estimator of the time derivative of the outputs m y n 1 l d l 1 g u t l 1 p x n dt t n d l 1 g u t dt t n d l 1 p dt t n x n gd pd x n 34 with gd d l 1 g u t dt t n pd d l 1 p dt t n 35 3 2 3 linear part numerical evaluation the remaining problem lies in the evaluation of the quantities gv pv gd and pd indeed the inverse laplace transform of a function f of the laplace variable s can be evaluated at a given time t with several numerical methods 2 our implementation to generate the results of section 4 used the gaver stehfest method 17 based on 32 first of all the inverse laplace transform of a matrix in our case p or a tensor of order 3 in our case g u t is the matrix or a tensor of order 3 respectively of the inverse laplace transforms of every element the resulting matrix or tensor of order 3 respectively has the same size as the one in the laplace domain let f either denote a matrix or tensor function of the laplace variable s the numerical computation of l 1 f t for a given time t requires several evaluations of f at different values of s in our case any evaluation of g u t or p requires among others a matrix inversion see expressions 25 and several matrix products in case a n is diagonalizable it can be written as k k 1 where is diagonal the matrices p and g can then be written as follows p s c n si a n 1 c n si k k 1 1 c n skik 1 k k 1 1 c n k si k 1 1 c n k si 1 k 1 36 costarica estimator for iterative co simulation methods 23 and g s p s b n d n c n k si 1 k 1 b n d n 37 in that case the products c n k and k 1 b n can be computed only once when a n is known that is to say once for each iteration of the time loop in deed they do not depend on s moreover the inversion si 1 is immediate si 1 1 s 1 1 0 0 1 s nst nst 38 however this approach has two main drawbacks in case a n is not diagonalizable this cannot be done for instance in case a n is nilpotent but not zero and in case an evaluation at a given value s corresponding to an eigenvalue of a n is required si 1 cannot be computed in 38 at least one of the diagonal coefficients becomes 1 0 consequently the approach we used in our implementation is the explicit computation of every coefficient in the matrices g and p indeed every element of g is a rational function in terms of s and every coefficient of the rational functions of every element of g can be computed with the patel misra method 1 regarding matrix p we can notice that despite it is not strictly speaking a transfer function it would be the same as g in the following conditions if nin were equal to nst if b n were inst nst the identity matrix of size nst nst and if d n were 0 nout nst the null matrix of size nout nst hence running the patel misra method on the fake state space system made of matrices a n inst nst c n and 0 nout nst we obtain all the coefficients of the rational functions of every element of p the tensor gv and the matrix pv can finally be computed easily as every coefficient of g s p s and u s see 28 are known rational functions of s regarding gv l 1 g u t in particular the outer product g u t works as defined in 29 however due to the indexing of and u see 22 and 28 respectively we consider the indexing 39 for the outer product g u t g u t g ij u k i 1 nout j 1 nin k 0 n g u t ijk i 1 nout j 1 nin k 0 n 39 24 y eguillon et al the gaver stehfest method being applied element wise we obtain gv gv i j k i 1 nout j 1 nin k 0 n l 1 g u t i j k t n i 1 nout j 1 nin k 0 n pv pv i j i 1 nout j 1 nst l 1 p i j t n i 1 nout j 1 nst 40 in case the gaver stehfest method requires an evaluation with s being a pole of p or g the co simulation step will diverge and t n 1 will change leading to a different value of t n making the gaver stehfest method evaluate g and p at different values of s if an estimation of the time derivatives of the outputs is required gd and pd must be computed in order to evaluate m y n 1 l see 34 and 35 additional evaluations of the inverse laplace of g u t and p at different times than t n can help compute these quantities let h denote a small strictly positive quantity with respect to t n a simple first order estimation of gd and pd can be achieved by an additional inverse laplace computation for each of these quantities gd fo 1 h gv d l 1 g u t dt t n h pd fo 1 h pv d l 1 p dt t n h 41 higher order estimations can also be used for instance the implementation that has been used to present the results in 4 uses a 2 nd order richardson 2 rich approximation 42 with h 0 2 t n gd 2 rich d l 1 g u t dt t n h 4 d l 1 g u t dt t n h 2 3 gv h pd 2 rich d l 1 p dt t n h 4 d l 1 p dt t n h 2 3 pv h 42 indeed these estimations have a consistency order of 2 let s take an ar bitrary regular enough real scalar function f taylor formula of f t h and f t h 2 give f t h 4 f t h 2 3 f t h f t h 2 12 f t o h 2 f t o h 2 43 which shows the 2 nd order of consistence of the 2 rich formula used in 42 costarica estimator for iterative co simulation methods 25 3 3 estimator update let s recap the intermediate computations required the get the estimators of table 3 from the known quantities of table 2 figure 4 shows the intermediate quantities and the quantities they require to be computed fig 4 quantity dependencies to get the output estimators we notice on figure 4 that some intermediate quantities can be computed before the moment where the estimators are needed therefore instead of com puting the estimators when required algorithm 2 a lazy update version of costarica usage in a co simulation worker program can be achieved this lazy version avoids re computing intermediate quantities at stages where they are not supposed to change from the previous computations this is presented in algorithm 3 26 y eguillon et al algorithm 3 lazy costarica injection in single worker process in an iterative co simulation method 1 n 0 2 t 0 tinit 3 while t n tend do time loop 4 ask system to provide a n b n c n d n update 1 5 ask system to provide x n update 1 6 from these quantities and t n and y n known compute y n c and coefficients of rational functions at each element of s 7 g u t s and s 7 p s update 1 7 while step starting on t n is not converged do co sim step loop 8 m 0 9 method re computes t n 1 10 from t n t n 1 m y n c and eventually y n r c r 1 2 compute y n 1 c and y n 1 c update 2 11 compute t n t n 1 t n update 2 12 from expressions of s 7 g u t s and s 7 p s and as we now know t n compute several inverse laplace transforms to get gv pv gd and pd update 2 13 while true do internal loop 14 method computes m u n 15 compute m y n 1 by step integration s n with inputs m u n 16 from m u n compute matrix update 3 17 estimate outputs m y n 1 gv pv x n y n 1 c 18 estimate outputs m y n 1 gd pdx n y n 1 c 19 from m y n 1 and outputs of other systems on other workers and eventually the time derivative estimations too method decides if the step is converged to be redone or rejected 20 if step t n t n 1 is to be redone then 21 m m 1 22 else either step is converged or has been rejected 23 break 24 mmax n m 25 compute mmax n y n 1 by step integration s n with inputs mmax n u n 26 n n 1 costarica estimator for iterative co simulation methods 27 algorithm 3 enables the usage of costarica in an optimized way every time the co simulation method needs to iterate on a given macro step internal loop the cost of the estimation of the outputs is the computation 21 the tensor matrix product gv the matrix vector product pv x n and two vectors sums this might be multiplied by 2 in case the time derivatives of the outputs are required as well other computations are required yet they can be done outside of the internal loop which enables the co simulation method to iterate a lot internally in order to get a high convergence in case the internal part is due to an iterative numerical method for instance 12 finally the computational cost of the estimators only depends on the sizes nin nout nst and n unlike a minimal solver being responsible for the resolution of the linearized system 9 the dynamics of the linearized system do not affect the computational cost 4 examples and test cases this section presents the use of costarica on concrete cases first of all a simple generic equation is used to show the behavior of costarica on a tough case where the linearization is not representative of the system then co simulations on modular models will be presented the iterative co simulation algorithm on which the costarica process is injected is ifosmondi jfm 12 one of these modular models is a simple mechanical model made of two systems connected by a force and velocity displacement coupling this model has been introduced in 13 and is strongly inspired by test cases in 8 and 22 and it enables us to show the different terms of the estimators it will be presented in subsection 4 2 the second modular model presented in subsection 4 3 consists in the non linear lotka volterra model 36 decoupled in two non linear systems for the sake of reproducibility the equations of the latter models will be detailed important remark 1 please note that for the modular models presented in 4 2 and 4 3 the inputs u t of a system corresponds to the outputs y t of the other system and vice versa the output of a system is connected to the input of the other one the formalism of this paper was centered around one co simulation system and the modular models are made of several such systems connected to one another in order to remove ambiguity indices have been introduced on u y and x quantities in subsections 4 2 and 4 3 important remark 2 regarding the modular models of subsections 4 2 and 4 3 co simulations with ifosmondi jfm using rollback and with replacement 28 y eguillon et al of the rollback by the costarica process have been run and compared to the monolithic system acting as reference results simulated with simcenter amesim please note that in the context of industrial cases such monolithic references can usually not be assembled as the systems are black boxes the models presented in this paper have been designed on purpose so that error measurements can be done 4 1 tough case time only dependent terms the costarica estimator is based on the linearization of the considered sys tem the assumption is made that in case the system is not a linear ode it behaves similarly to its linearization in a neighborhood of the currently reached time the co simulation step size must therefore be small enough to stay in an acceptable neighborhood an example of model involving such non linear systems is presented fur ther in 4 3 however tough cases can arise from very simple systems without non linearities namely when the ode contains among others a term that is completely independent of the state variable x and the input u let a and b be real scalar functions of times let s consider the simple fol lowing system dx dt a t y x b t 44 this system is not sensitive to any input we can either consider the system as inputs less with nin 0 or as having unused inputs with nin 1 for instance to avoid degenerated matrices fortunately these two choices will generate the same results let s consider the case where there is one unused input nin 1 so that we can detail here all the involved matrices an equivalent version of system 46 is dx dt 0 x 0 u a t y 1 x 0 u b t 45 this system can be sketched in a modelling and simulation software an example is shown on figure 5 fig 5 tough system with time only dependent terms in simcenter amesim costarica estimator for iterative co simulation methods 29 at any point in time the linearization of 44 is the same i e the directional derivatives are the same regardless of the time index so let s use the notations a b c and d instead of a n b n c n and d n the linearized version state space representation of 44 is dx dt 0 yl x 46 because the directional derivatives are a 0 m 1 1 r b 0 m 1 1 r c 1 m 1 1 r d 0 m 1 1 r 47 we notice that the system 46 has a significant lack of information compared to 44 due to the terms that are transparent in the linearization regarding the directional derivatives let s detail the costarica estimator on a general co simulation step t n t n 1 to see the consequences of this information loss first we have g s c si a 1 b d s 1 0 0 0 p s c si a 1 s 1 48 so regarding the inverse laplace matrices we have gv l 1 g u t t n 0 pv l 1 p t n 1 gd d t 7 0 dt t n 0 pd dh dt t n 0 49 where h denotes the heaviside function and where the size of gv and gd is 1 1 n where n does not matter as it is the maximum polynomial degree of an unused input whatever the value of n is gv and gd are filled with zeros finally the expression of the linear parts of the estimators for the output value and derivative are m 0 mmax n m y n 1 l x n m y n 1 l 0 50 in other words the linear part of the outputs estimator exactly acts as a zero order hold estimator 30 y eguillon et al regarding the control part of the estimator of the output if a zero order hold is used see 13 the estimator is y n 1 c y n c y n cx n d mmax n 1 u n 1 t n y n x n x n b t n x n b t n 51 finally summing the terms see 11 the costarica estimator for the output is m y n 1 m y n 1 l y n 1 c x n b t n 52 which exactly corresponds to a zero order hold estimation recall in 44 we have y x b t regarding the estimation of the derivative of the output the term y n 1 c will be the only one that matters as m y n 1 l 0 this estimator will only be able to take into account the derivative of the b t part in case the estimation is done with a few past values y n c y n 1 c this tough case shows that even when the system is different from its lin earization state space representation due to lost information difference be tween 44 and 46 the costarica estimator is not worse than a zero order hold estimation as it reproduces it please note that while on the one hand the main drawback of a zero order hold estimation is that the inputs are not taken into account m does not appear in final expression of 52 on the other hand this example has no inputs or an unused one equivalently so it does not matter in this particular case if the system had inputs and used them the b and d matrices wouldn t have been null and thus the estimator would have taken them into account 4 2 mechanical bodies with behavior change this model is a uni dimensional linear mechanical model two bodies inertias of 10 000 kg are interconnected to one another and to zero speed points walls with springs and dampers after the instantaneous transition time t 100 s the body on the right vanishes and the corresponding system spontaneously acts as a constant pulling force of 1000 n a representation of this model introduced in 13 is presented in figure 6 the corresponding sketch in simcenter amesim is shown in figure 7 costarica estimator for iterative co simulation methods 31 c 1 1 kn m c 2 1 kn m c 3 1 kn m d 1 1 kn m s d 2 0 kn m s d 3 1 kn m s m 1 10000 kg m 2 10000 kg x 1 t init 1 m x 2 t init 0 m v 1 t init 0 m s v 2 t init 0 m s tinit tend 0 s 200 s fig 6 mechanical bodies with behavior change linear uni dimensional co simulation test case fig 7 mechanical bodies with behavior change in simcenter amesim let s detail the equations of the left body system and denote it by s 1 the left body system for co simulation as represented in figure 8 has nin 1 input the force coming from the right nout 2 outputs the displacement and velocity of the left body and nout 2 state variables the position and speed of the body modelled as a mechanical inertia fig 8 left body system s 1 in simcenter amesim the state variables are denoted by x 1 xl vl t the input force by u 1 input and the outputs by y 1 1 and y 1 2 respectively the spring of rate c 1 and the damper of rate d 1 see figure 6 in the left of the body generate forces c 1 xl and d 1 vl respectively measured positively from left to right second newton s law gives m 1 v l c 1 xl d 1 vl u 1 as the force at the interface is measured positively from right to left finally the equations of system s 1 are given in 53 32 y eguillon et al s 1 x l v r 0 1 c 1 m 1 d 1 m 1 xl vl 0 1 m 1 u 1 y 1 1 y 1 2 1 0 0 1 xl vl 0 0 u 1 53 let s detail the equations of the right body system and denote it by s 2 it has nin 2 inputs the position and the velocity of the body in s 1 nout 1 output the force at the left of the spring damper component on the left of figure 8 and nin 2 state variables the position and speed of the body as shown on the figure 9 the force interface variable produced by s 2 output of it and used by s 1 input of it is measured positively from right to left the other quantities forces of the springs and dampers around the body position and velocity of the body will be measured positively from left to right fig 9 right body system s 2 in simcenter amesim the body has a mass m 2 and is modelled as a mechanical inertia which position and speed are the state variables denoted by x 2 xr vr t it is submitted to 4 forces measured positively from left to right the spring of rate c 2 the damper with a damper rating of d 2 the spring of rate c 3 and the damper with a damper rating of d 3 see figure 6 let s focus on this situation which corresponds to the behavior of s 2 before the transition time t 100 s the forces coming from the left of the body in s 2 come from a spring and a damper and are respectively c 2 xr u 2 1 and d 2 vr u 2 2 they indeed depend on the left body s position input u 2 1 and the left body s velocity input u 2 2 the forces coming from the right of the right body also come a spring and a damper and they are respectively c 3 xr and d 3 vr second newton s law gives m 2 v r c 2 xr u 2 1 d 2 vr u 2 2 c 3 xr d 3 vr finally the equations of system s 2 are s 2 x r v r 0 1 c 2 c 3 m 2 d 2 d 3 m 2 xr vr 0 0 c 2 m 2 d 2 m 2 u 2 1 u 2 2 y 2 c 2 d 2 xr vr c 2 d 2 u 2 1 u 2 2 if t 0 100 1000 otherwise 54 as explained in the remark of the introduction of section 4 co simulations with ifosmondi jfm using rollback and with replacement of the rollback by costarica estimator for iterative co simulation methods 33 the costarica process have been run and compared to the reference mono lithic system presented in figure 7 a fixed step version of the ifosmondi jfm method has been used so that errors can be computed for various values of the co simulation step size the following results use the anderson version of ifosmondi jfm with an epsilon of 1 10 6 see 12 fig 10 comparison of the convergence graphs of ifosmondi jfm method on the mechanical test case depending on the way to iterate on the co simulation steps figure 10 shows that both the rollback and the costarica process make ifosmondi jfm method reach an order 3 of convergence on the characteristic variable of the modular model xr regardless of the numerical effects for small values of the co simulation step size the estimators involved in the costarica process are very accurate which enables the ifsomondi jfm co simulation method to be unaffected by the rollback avoidance indeed both systems s 1 and s 2 see 53 and 54 are linear this makes their linearizations 9 exact the left body s displacement position is indeed very close to the monolithic reference in both cases rollback and costarica as shown on figure 11 fig 11 left body s motion comparison depending on the co simulation method co simulation with ifosmondi jfm using rollback co simulation step size 2 10 1 co simulation with ifomsondi jfm replacing the need for rollback by the costarica process co simulation step size 2 10 1 and monolithic simulation reference 34 y eguillon et al therefore co simulations on this test case with an iterative co simulation method could have been performed even if the systems were not capable of rollback thanks to the costarica process and without loss of accuracy 4 3 lotka volterra predation non linear this model is a decoupled version of the classical two species lotka volterra predation equations 36 the monolithic system is shown on figure 12 and the two systems of the corresponding modular model for co simulation are presented on figures 13 and 14 0 67 1 33 1 1 p tinit 1 p tinit 1 tinit tend 0 s 20 s fig 12 lotka volterra predation model in simcenter amesim system s 1 represents the prey a sketch of it is presented on figure 13 the population of prey denoted by p is the single state variable of s 1 it is also the output the single input to this system is the population of predator the and parameters are the natural birth rate and the rate of predation upon the prey respectively the non linear equations of s 1 are given in 55 fig 13 prey system s 1 in simcenter amesim s 1 p p u 1 y 1 1 p 0 u 1 55 system s 2 represents the predator a sketch of it is presented on figure 14 the population of predator denoted by p is the single state variable of s 2 it is also the output the single input to this system is the population of prey costarica estimator for iterative co simulation methods 35 the and parameters are the natural death rate and the growth rate upon predator due to predation respectively the non linear equations of s 2 are given in 56 fig 14 predator system s 2 in simcenter amesim s 2 p p u 2 y 2 1 p 0 u 2 56 as for the previous test case ifosmondi jfm has been used as co simulation method to compare the costarica process to the rollback usage the refer ence results are the ones obtained from the simulation of the monolithic system of figure 12 a fixed step version of the ifosmondi jfm method has been used as well as the anderson version of the algorithm the epsilon parameter see 12 has been set to 1 10 6 fig 15 comparison of the convergence graphs of ifosmondi jfm method on the lotka volterra test case depending on the way to iterate on the co simulation steps figure 15 shows that the costarica process injected in ifosmondi jfm does not achieve the same accuracy than the real usage of the rollback the fact that the estimators used in costarica are based on the systems linearizations explains the higher error than the cases where the successive iter ations of ifosmondi jfm are done with the real systems integrations nevertheless a method of order one measured is obtained which allows any desired precision to be reached by simply refining the co simulation step size in case the systems are not capable of rollback this example shows that 36 y eguillon et al the ifosmondi jfm method or any other iterative co simulation method 11 29 35 18 can be used thanks to costarica regarding the results proportion of prey and proportion of predator figure 16 shows that the results are satisfactory even on the co simulation replacing the rollback usage by the costarica estimators the differences between the different co simulations can be observed more easily on the zoom on figure 17 fig 16 prey and predator proportions depending on the co simulation method co simulation with ifosmondi jfm using rollback co simulation step size 10 2 co simulation with ifomsondi jfm replacing the need for rollback by the costarica process co simulation step size 10 2 and monolithic simulation reference fig 17 zoom on the curves of figure 16 on 11 16 costarica estimator for iterative co simulation methods 37 5 conclusion the introduced costarica process enables to use iterative co simulation methods on modular models made of interconnected systems even in the case where not every of these systems is capable of rollback through the use of esti mators of the local behavior of the systems the iterative part of the co simulation methods prepares the final integration on every co simulation step these estimators are based on the local linearizations of the non rollback capable systems at the lastly reached time which might be more or less accurate depending on each system nature in case a system is linear or nearly linear the estimators of costarica can reach a precision similar to the one that would have been obtained by a real integration in that case the rollback re placement by the costarica process does not or slightly affect the accuracy of the co simulation otherwise in case a system is non linear the estimators of costarica only generate approximations of the behavior of the system and the co simulation step should not be too large in order to prevent this ap proximation from causing an unreasonable error it is anyway worth it to use this process on non rollback capable systems as in the worst case the zero order hold behavior is recreated and in the better cases extra information about the behaviors of the systems will enable the iterative co simulation method to com pute a solution on each step that couldn t have been obtained due to the rollback requirement enhancement will be tacked in further work of the authors such as the use of the final guess of the last iteration of the co simulation method with the costarica process in a comparison involving the result of the genuine integration such an error estimation could be used in a co simulation step size controlling strategy as the whole paper was written without supposing that the co simulation step size was constant a criterion estimating the urgency to reevaluate the matrices of the linearizations of the systems can also be developed to save numerical computations declarations of interest authors yohan eguillon and bruno lacabanne are currently siemens digital industries software employees the patent advanced cosimulation scheduler for dynamic system simula tion is currently pending to siemens and includes the costarica process computation of the estimators and injection in a co simulation algorithm acknowledgements the authors would like to thank siemens digital industries software for sup porting this work as well as institut camille jordan and universite de lyon for supervising this research 38 y eguillon et al references 1 computation of transfer function matrices of linear multivariable systems auto matica 23 5 635 640 1987 https doi org 10 1016 0005 1098 87 90059 8 2 abate j ward w a unified framework for numerically inverting laplace transforms informs journal on computing 18 408 421 2006 https doi org 10 1287 ijoc 1050 0137 3 arnold m unther m g preconditioned dynamic iteration for coupled differential algebraic systems bit 41 1 1 25 2001 4 bartel a brunk m gu nther m scho ps s dynamic iteration for coupled problems of electronic circuits and distributed devices siam j sci comp 35 2 315 335 2013 https doi org 10 1137 120867111 1 5 benedikt m watzenig d hofer a modelling and analysis of the non iterative coupling process for co simulation mathematical and computer modelling of dynamical systems 19 5 451 470 2013 https doi org 10 1080 13873954 2013 784340 6 benedikt m watzenig d zehetner j hofer a nepce a nearly energy preserving coupling element for weak coupled problems and co simulation in pro ceedings of the international conference on computational methods for coupled problems in science and engineering pp 1 12 jun 2013 7 blochwitz t otter m a kesson j arnold m clauss c elmqvist h friedrich m junghanns a mauss j neumerkel d olsson h viel a func tional mockup interface 2 0 the standard for tool independent exchange of sim ulation models in proceedings of the 9 th international modelica conference pp 173 184 the modelica association 2012 https doi org 10 3384 ecp 12076173 8 busch m continuous approximation techniques for co simulation methods anal ysis of numerical stability and local error zamm journal of applied mathemat ics and mechanics zeitschrift fu r angewandte mathematik und mechanik 96 9 1061 1081 2016 https doi org 10 1002 zamm 201500196 9 busch m performance improvement of explicit co simulation methods through continuous extrapolation in iutam symposium on solver coupling and co simulation iutam bookseries vol 35 pp 57 80 iutam 2019 https doi org 10 1007 978 3 030 14883 6 4 10 busch m schweizer b stability of co simulation methods using hermite and lagrange approximation techniques in multibody dynamics 2011 ecco mas thematic conference brussels belgium july 04 july 07 2011 11 e guillon y lacabanne b tromeur dervout d ifosmondi a generic co simulation approach combining iterative methods for coupling con straints and polynomial interpolation for interfaces smoothness in science s publications t eds proceedings of the 9 th international conference on simulation and modeling methodologies technologies and applications pp 176 186 insticc prague czech republic july 29 july 31 2019 https doi org 10 5220 0007977701760186 12 e guillon y lacabanne b tromeur dervout d ifosmondi co simulation algorithm with jacobian free methods in petsc engineering with computers 2021 https doi org 10 1007 s 00366 021 01558 6 13 e guillon y lacabanne b tromeur dervout d f 3 ornits a flexi ble variable step size non iterative co simulation method handling subsys tems with hybrid advanced capabilities engineering with computers 2022 https doi org 10 1007 s 00366 022 01610 z costarica estimator for iterative co simulation methods 39 14 gomes c thule c broman d larsen p g vangheluwe h co simulation a survey acm computing surveys csur 51 3 1 33 2018 15 gomes c oakes b moradi m ga miz a mendo j dutre s denil j vangheluwe h hintco hint based configuration of co simulations in proceed ings of the 9 th international conference on simulation and modeling method ologies technologies and applications simultech pp 57 68 insticc scitepress 2019 https doi org 10 5220 0007830000570068 16 gu b asada h h co simulation of algebraically coupled dynamic subsystems without disclosure of proprietary subsystem models jour nal of dynamic systems measurement and control 126 1 1 2004 https doi org 10 1115 1 1648307 17 jacquot r steadman j rhodine c the gaver stehfest algorithm for approx imate inversion of laplace transforms ieee circuits systems magazine 5 1 4 8 1983 18 kraft j klimmek s meyer t schweizer b implicit co simulation and solver coupling efficient calculation of interface jacobian and coupling sensi tivities gradients journal of computational and nonlinear dynamics 07 2021 https doi org 10 1115 1 4051823 19 kraft j meyer t schweizer b parallel co simulation approach with macro step size and order control algorithm international design engineering tech nical conferences and computers and information in engineering conference vol volume 6 15 th international conference on multibody systems nonlin ear dynamics and control 08 2019 https doi org 10 1115 detc 2019 97781 v 006 t 09 a 009 20 ku bler r schiehlen w two methods of simulator coupling mathemat ical and computer modelling of dynamical systems 6 2 93 113 2000 https doi org 10 1076 1387 3954 200006 6 2 1 m ft 093 21 li p meyer t lu d schweizer b numerical stability of explicit and implicit co simulation methods j 10 5 051007 2014 https doi org 10 1115 1 4028503 22 meyer t kraft j schweizer b co simulation error estimation and macro step size control journal of computational and nonlinear dynamics 16 4 02 2021 https doi org 10 1115 1 4048944 https doi org 10 1115 1 4048944 23 mu ller w breitenecker f an explicit approach for asynchronous step size control in co simulation pp 75 80 09 2016 24 ochel l a braun r thiele b asghar a buffoni l eek m fritzson p fritzson d horkeby s ha llquist r kinnander a palanisamy a pop a sjo lund m omsimulator integrated fmi and tlm based co simulation with composite model editing and ssp in haumer a ed proceedings of the 13 th international modelica conference regensburg germany march 4 6 2019 linko ping electronic conference proceedings vol 157 p 157 007 linko ping university electronic press 2019 https doi org 10 3384 ecp 1915769 25 sadjina s kyllingstad l t skjong s pedersen e energy conserva tion and power bonds in co simulations non iterative adaptive step size con trol and error estimation engineering with computers 33 3 607 620 2017 https doi org 10 1007 s 00366 016 0492 8 26 sadjina s pedersen e energy conservation and coupling error reduction in non iterative co simulations engineering with computers 36 1579 1587 2020 https doi org 10 1007 s 00366 019 00783 4 27 schierz t arnold m clau c co simulation with communication step size control in an fmi compatible master algorithm pp 205 214 11 2012 https doi org 10 3384 ecp 12076205 40 y eguillon et al 28 schweizer b li p lu d explicit and implicit cosimulation meth ods stability and convergence analysis for different solver coupling ap proaches journal of computational and nonlinear dynamics 10 5 2015 https doi org 10 1115 1 4028503 29 schweizer b li p lu d implicit co simulation methods stability and conver gence analysis for solver coupling approaches with algebraic constraints zamm zeitschrift fur angewandte mathematik und mechanik 96 8 986 1012 2016 https doi org 10 1002 zamm 201400087 30 schweizer b lu d predictor corrector co simulation approaches for solver coupling with algebraic constraints zamm journal of applied mathematics and mechanics zeitschrift fu r angewandte mathematik und mechanik 95 05 2014 https doi org 10 1002 zamm 201300191 31 sicklinger s belsky v engelman b elmqvist h olsson h wu chner r bletzinger k u interface jacobian based co simulation interna tional journal for numerical methods in engineering 98 418 444 2014 https doi org 10 1002 nme 32 stehfest h algorithm 368 numerical inversion of laplace transforms commun acm 13 1 47 49 jan 1970 https doi org 10 1145 361953 361969 33 stettinger g horn m benedikt m zehetner j a model based approach for prediction based interconnection of dynamic systems vol 2015 february pp 3286 3291 2014 https doi org 10 1109 cdc 2014 7039897 34 stettinger g horn m benedikt m zehetner j model based coupling ap proach for non iterative real time co simulation in 2014 european control con ference ecc pp 2084 2089 2014 https doi org 10 1109 ecc 2014 6862242 35 viot l saas l de vuyst f solving coupled problems of lumped pa rameter models in a platform for severe accidents in nuclear reactors in ternational journal for multiscale computational engineering 16 6 2018 https doi org 10 1615 intjmultcompeng 2018025643 36 volterra v variations and fluctuations of the number of individuals in animal species living together ices journal of marine science 3 1 3 51 04 1928 https doi org 10 1093 icesjms 3 1 3