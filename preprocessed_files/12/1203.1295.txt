ar x iv 1 20 3 12 95 v 1 cs s c 6 m ar 2 01 2 subtotal ordering a pedagogically advantageous algorithm for computing total degree reverse lexicographic order david r stoutemyer november 20 2018 abstract total degree reverse lexicographic order is currently generally regarded as most often fastest for computing gr bner bases this article describes an alternate less mysterious algorithm for computing this order using exponent subtotals and de scribes why it should be very nearly the same speed the traditional algorithm all other things being equal however experimental evidence suggests that subtotal order is actually slightly faster for the mathematica r gr bner basis implementa tion more often than not this is probably because the weight vectors associated with the natural subtotal weight matrix and with the usual total degree reverse lexicographic weight matrix are different and mathematica also uses those the corresponding weight vectors to help select successive s polynomials and divisor polynomials those selection heuristics appear to work slightly better more often with subtotal weight vectors however the most important advantage of exponent subtotals is pedagogical it is easier to understand than the total degree reverse lexicographic algorithm and it is more evident why the resulting order is often the fastest known order for computing gr bner bases keywords term order total degree reverse lexicographic tdeg grevlex gr bner basis 1 introduction total degree reverse lexicographic order degrevlex is currently generally regarded as most often fastest for computing gr bner bases 1 this order is usually determined by algorithm 1 however as indicated in the comments therein this algorithm tends to be mystifying and therefore difficult to recall dstout at hawaii dot edu 1 the adjective graded is sometimes used instead of total degree 1 http arxiv org abs 1203 1295 v 1 algorithm 1 degrevlex order of two exponent vectors given nonnegative integer exponent vectors 1 2 n 1 2 n returns one of or according to the degrevlex order between power products z 11 z 2 2 z n n and z 1 1 z 2 2 z n n with indeterminate order z 1 z 2 zn a 1 b 1 for k 2 to n do a a k b b k end for if a b then return if a b then return so far this all makes sense for k n to 1 by 1 do if k k then return whoa why is matched with if k k then return end for these must be typographical errors return at least this step makes sense this is the order that buchberger in his ph d dissertation and the order that gr bner always used when discussing multivariate polynomials buchberger personal communi cation 2 the next fastest widely discussed order is total degree lexicographic order and it too orders primarily by total degree therefore clearly total degree is very important for speed and that makes sense because if we are iteratively annihilating terms with the largest total degrees then the degree of each variable can t increase beyond that total degree consequently it seems plausible that it would be more consistent to break total degree ties with the sum of the degrees of all but the least main variable then break those ties with the sum of the degrees of all but the two least main variables and so on as described in algorithm 2 2 trinks 8 made the extraordinarily useful contribution of introducing the idea of admissible orderings and the particularly useful alternative example of lexicographic ordering 2 algorithm 2 subtotal order of two exponent vectors given nonnegative integer exponent vectors 1 2 n 1 2 n returns one of or according to the subtotal order between power prod ucts z 11 z 2 2 z n n and z 1 1 z 2 2 z n n with indeterminate order z 1 z 2 zn a 1 1 b 1 1 for k 2 to n do ak ak 1 k bk bk 1 k end for for k n to 1 by 1 do if ak k then return i have a better feeling about this if ak k then return end for return algorithms 1 and 2 both do 2 n additions followed by up to n comparisons with the same looping costs both algorithms assume that the variables have been extracted from the power prod ucts which requires that all power products have the same number of exponents even if some of these exponents are 0 if instead the power products have only non zero expo nents and therefore also contain variables to indicate the base for each exponent then the algorithms are slightly different but both of them still have the same complexity as each other section 2 discusses weight matrices weight vectors and their implications for subtotal versus degrevlex order section 3 describes the experimental procedures for comparing these two orders and the results of those comparisons with conclusions in section 4 2 weight matrices and weight vectors when i first thought of subtotal order i wondered if subtotal order would be faster than degrevlex order therefore i wanted a quick way to compare them experimentally without having to implement my own gr bner basis algorithm or learn the intricacies of an existing one to modify it fortunately some computer algebra systems permit users to specify their own ordering merely by providing a non singular real square weight matrix w to compare exponent vectors and for ordering we lexicographically compare corresponding weight vectors w w 1 w 2 w t w w 1 w 2 w t 3 the weight matrix corresponding to algorithm 2 is wsub 1 1 1 1 1 1 1 0 1 1 0 0 1 0 0 0 1 proposition 1 the ordering specified by wsub is an admissible ordering proof the first element of each column in wsub is positive also matrix wsub is non singular because the columns hence the variables can be permuted into an upper triangular matrix having 1 for every diagonal element and the determinant of a square upper triangular matrix is the product of its diagonal elements which consequently is non zero making the permuted wsub hence also wsub non singular these are sufficient conditions for an admissible ordering every admissible term order can be associated with a weight matrix and the one that is usually associated with algorithm 1 for degrevlex ordering is wdegrevlex 1 1 1 1 0 0 0 1 0 0 1 0 0 1 0 0 2 there are at least two ways to use weight matrices in an implementation 1 do a matrix vector multiplication for a power product every time we want to or der it relative to another power product to save some time we could interleave the matrix vector multiplication with the comparison of successive weight vector components to quit as soon as a difference is detected 2 do matrix vector multiplications only for the given input polynomials store the weight vectors in parallel with the corresponding exponent vectors then a whenever two power products are multiplied compute the weight vector of their product as the sum of the two weight vectors and b whenever two power products are divided compute the weight vector of their quotient as the difference of the two weight vectors at the expense of some additional storage space the second choice is clearly much faster because the number of power product comparisons during computation of a gr bner basis is usually far more than the number of power products in the given polynomials mathematica accepts weight matrices and it uses the second of these two methods even for the implemented built in orderings for which it uses essentially algorithm 1 4 rather than wdegrevlex to initialize the weight vectors in the case of degrevlex ordering thus we can expect built in degrevlex order for that implementation to be slightly faster than providing wdegrevlex but usually not dramatically so nonetheless to make the comparison fair more as if comparing built in degrevlex ordering to built in subtotal ordering with initialization via algorithm 2 i started timing a few examples done with both wsub and wdegrevlex i soon noticed that both matrices always gave the same gr bner basis this could have been a coincidence however proposition 2 subtotal ordering is equivalent to degrevlex proof the first rows of wsub and wdegrevlex are identical the second row of wsub given by formula 1 is the second row of wdegrevlex given by formula 2 plus the first row of wdegrevlex the third row of wsub is the first row of wdegrevlex plus the second and third rows of wdegrevlex and so on thus wdegrevlex can be transformed into wsub by a sequence of adding positive multiples of rows to rows below them this is a sufficient condition for orderings specified by two weight matrices to be equivalent remark after noticing the identical gr bner bases i discovered that chee keng yap 10 describes the computation of degrevlex ordering by algorithm 1 but lists wsub rather than the usual wdegrevlex as a weight matrix for degrevlex ordering he didn t explain why but i suspect that he had the idea of subtotals too with weight matrices wdegrevlex and wsub inducing the same ordering we should expect their speed ratios to be close to 1 0 section 3 indicates that this is often so but not always then explains why there are exceptions in the case of mathematica 3 experimental procedures and results the discussion in sections 1 and 2 suggests that subtotal order should be very nearly the same speed as degrevlex order regardless of whether they are both determined directly from exponent vectors or both determined via weight matrices and perhaps also weight vectors this section describes experimental procedures and results that test this hypothesis 3 1 experimental procedures a mathematica function invocation of the form timeconstrained timing groebnerbasis polynomial 1 polynomial 2 variable 1 variable 2 sort true monomialorder degreereverselexicographic maximumseconds computes a degrevlex gr bner basis of the polynomials after heuristically reordering the variables for speed then displays only the computing time or displays aborted if maximumseconds is exceeded 5 the rewrite rule subtotalweightmatrix n table table if i n j 1 1 0 j n i n defines a function that returns an n by n weight matrix for subtotal ordering the rewrite rule degrevlexweightmatrix n table table if i 1 1 if i n 2 j 1 0 j n i n defines a function that returns an n by n weight matrix for subtotal ordering therefore a mathematica function invocation of the form timeconstrained timing groebnerbasis polynomial 1 polynomial 2 variable 1 variablen sort true monomialorder subtotalweightmatrix n maximumseconds computes a subtotal gr bner basis of the polynomials after heuristically reordering the variables for speed then displays only the computing time or aborted a similar function invocation using degrevlexweightmatrix displays the computation time of a degrevlex basis using a weight matrix i didn t want to address the issue of inexact computation at this time because it is handled quite differently by different systems 3 therefore i avoided test cases that contain floats unless they were obviously representations of rational numbers having small magnitude denominators in which case i rationalized those floats i wanted to detect any difference in the relative speeds of term order comparisons and coefficient arithmetic tends to be a larger portion of the total computing time when gr bner bases are computed over the rational numbers rather than over the integers modulo a prime whose square fits in one computer word therefore i did all problems in the coefficient domain z 32003 because the prime 32003 maps only about 0 003 of all non zero integer coefficients to 0 but 32003 is small enough so that its square fits within one 32 bit computer word some of the original test cases and the ones obtained by rationalizing simple floating point coefficients contained rational coefficients that weren t integers such polynomials were multiplied by the least common multiple of their coefficient denominators so that computing a gr bner basis in z 32003 was straightforward my patience for typing examples checking for typographical errors and waiting for results is limited also i wanted to avoid the extra space of listing previously unpublished examples in two dimensional pdf format forcing others to do lengthy error prone typing to try all of these examples on some other gr bner basis implementation therefore i searched the internet for medium sized examples preferably available in text that i could copy paste and quickly edit to replace semicolons with commas etc and i used 120 3 many implementations make no special effort for floats making the results disastrously sensitive to differences in floating point arithmetic and differences in the order of operations 6 seconds as the time limit many such examples are available at 9 others are available at 6 and 1 these sites also give original references for the examples this article lists input polynomials for a few additional examples that i think have not previously been published although the sort true parameter should make the results rather insensitive to the order in variable 1 variablen i also entered the list of variables in the order specified in the sources or that i could infer in case it mattered some of the original problems involved eliminating some of the variables or treating some as parameters in the coefficient domain however for uniformity i simply computed the gr bner basis with respect to all of the variables my objective was to compare the speed of subtotal versus degrevlex ordering al gorithms to make the comparison fair i used a weight matrix for degrevlex too however i also used the built in degrevlex option to estimate how much improvement to expect if the subtotal ordering algorithm was built in the computer has a 1 60 ghz intel core 2 duo u 9600 cpu with 3 gigabytes of ram the windows vista operating system appears to have a timer resolution of only about 0 015 seconds therefore if a time was less than 1 second then i issued the command timing do groebnerbasis polynomial 1 polynomial 1 variable 1 variable 1 sort true monomialorder m with the number of repetitions m sufficient to make the time exceed 1 second then divided by m to obtain the time for one repetition despite this even with no network connection and no voluntary programs launched other than mathematica times tend to vary upon repetition within an interval of about 3 of their mean mathematica uses reference counts rather than garbage collection so this variation is probably caused instead by the multiple core architecture and the irregular competing activity of the many resident programs that lurk in most windows installations relative speed is most important for problems that require extensive time therefore of all the problems that i tried i included the ones that took the most time for built in degrevlex order without exceeding the time limit for any ordering algorithm as many examples as fit in a one page table the examples that i thus excluded didn t have noticeably different overall behavior regarding the relative speed of subtotal versus degrevlex ordering algorithms 3 2 the test examples here are the included examples that i believe aren t already publicly published in some form 7 1 lichtblau 1 4 t 4 zb x 3 ya tx 8 yz ab 4 cde xy 2 z 2 d zc 2 e 2 tx 2 y 3 z 4 ab 2 c 3 e 2 with variable order t x y z a b c d e 2 lichtblau 2 a 2 b 2 2 c 2 2 d 2 3 f 2 3 g 2 h 70 ab 140 ac 140 bd 28 cd 252 cf 252 dg 18 fg 105 u 28 bc 28 c 2 28 ad 28 d 2 42 af 12 df 24 f 2 42 bg 12 cg 24 g 2 35 v 36 cd 30 bf 24 cf 30 ag 24 dg 16 fg 35 x 8 df 2 f 2 8 cg 2 g 2 7 y 100 fg 77 z with variable order a b c d f g h u v x y z 3 lichtblau 3 3375 uv 3291 u 2 v 750 uv 2 732 u 2 v 2 2225 uv 3 2209 u 2 v 3 qx p qy p qz r 1 24 uv 24 u 2 v 24 uv 2 where p 400 u 350 u 2 4800 uv 4800 u 2 v 7425 uv 2 7359 u 2 v 2 2225 uv 3 2209 u 2 v 3 q 1 24 uv 24 u 2 v 24 uv 2 with variable order x y z u v r 4 a geometry problem of michael trott x 1 x 2 y 1 3 x 2 1 y 1 2 x 3 1 y 1 2 x 1 y 3 1 2 x 2 y 3 1 y 2 3 x 2 1 y 2 2 x 3 1 y 2 x 1 x 2 y 1 3 x 2 2 y 1 2 x 3 2 y 1 y 2 3 x 2 2 y 2 2 x 3 2 y 2 2 x 1 y 3 2 2 x 2 y 3 2 1 2 x 1 2 x 3 1 x 4 1 2 y 1 y 4 1 1 2 x 2 2 x 3 2 x 4 2 2 y 2 y 4 2 1 x 1 x 2 z y 1 y 2 z 2 with variable order x 1 x 2 y 1 y 2 z 5 mathematica help gr bnerbasis options sort 3 x 7 5 xyz 2 10 y 2 z 6 xz y 3 w 2 x 2 z 3 x 3 y 2 y 4 12 xz 8 xz 2 3 y 2 z 11 wxy 2 10 x 2 w 7 yzw 2 2 xz 4 w 4 x 2 y 3 xy 2 6 yz 3 w 2 w 3 wx 2 y xyz 2 2 wxz 2 3 w 2 xy 2 3 with variable order w x y z 4 the problems provided by daniel lichtblau are from a mix of literature user questions and bug reports with unrecorded individual provenance 8 6 variation on a theme of giovini et al one of my test files is so similar to giovini 3 7 4 that i must have entered it twice but once with typographical errors these seemingly minor changes make the example that is relatively nearly fastest for subtotal ordering algorithm become an example that is relatively slowest for that algorithm the variation is x 33 z 23 y 82 a x 45 y 13 z 21 b x 41 c y 33 z 12 x 22 y 33 z 12 d x 5 y 17 z 22 e 1 xyzt 1 with variable order t b c e d a z x y all of the other examples are already published elsewhere as cited in table 1 3 3 test results the last column of table 1 displays the most important results the ratios of the com puting time for subtotal ordering versus degrevlex ordering both using a weight matrix notice that the rows are ordered by non decreasing values in this last column in an attempt to discern correlations with the number of variables and or total degrees of the input polynomials these total degrees are also listed in the table with for example 63 5 meaning 3 polynomials each having total degree 6 and 1 polynomial having total degree 5 however the number of examples and or their variability doesn t appear to be large enough to reveal obvious correlations this might be partly because the standard deviation of the number of variables is only 2 8 for a median and mean of about 8 most of the speed ratios are rather close to 1 0 as expected however there are some notable outliers at at the top and bottom of the table a probable explanation for these outliers is that in mathematica the weight vectors are also used to select the next s polynomial or reducer polynomial if so then it is an indication that good selection of a next s polynomial and a next reducer polynomial should instead if possible be based on the ordering that the weight vector induces so as to be invariant to a property that doesn t correlate completely with ordering although re executing an example caused time variations for individual examples within an interval of about 3 there are enough examples so that the summary statis tics are more tightly repeatable the median speed ratio of 0 98 and mean of 0 92 suggest that the subtotal algorithm would be about this much faster than the degrevlex algorithm if both were built into mathematica the standard deviation of 0 24 weakens that conclusion but most of the standard deviation comes from the outliers at the top of the table where the subtotal algorithm was significantly faster the speeds of the two methods are close enough so that quite possibly the degrevlex algorithm could be faster than the subtotal algorithm if both were built into another gr bner basis implementation that used weight vectors in a different way to select s 9 polynomials and reducers however it seems highly likely that the speeds would be quite close if weight vectors weren t used for selection strategy the penultimate column of table 1 is next most interesting the summary statistics for that column weakly support the conclusion that built in degrevlex is faster than the degrevlex weight matrix by only 2 for the median or 8 for the mean this can only be attributable to computing the initial weight vectors from the weight matrices and these small percentages indicate that the initialization of weight vectors is usually only a small portion of the total time however there are a surprising number of instances where the weight matrix is slightly faster up to 7 i can think of no implementation reason why this should be if there is no such reason then it can be taken as an indication of the repeatability deviations in individual time ratios up to 7 rather than the 3 that i estimated from informal experiments 4 conclusions the main result is that subtotal ordering is an alternate way to view degrevlex ordering that more clearly explains its good behavior a secondary conclusion is that the the algorithm for computing subtotal order is very nearly the same speed as that for computing degrevlex order at least if the induced ordering rather than the weight vectors is used to select the next s polynomial and next reducer the relative speeds of the subtotal and degrevlex ordering algorithms are close enough so that it probably isn t worth replacing the degrevlex algorithm with the subtotal algorithm in existing implementations however it is well worth considering use of the subtotal algorithm instead of the degrevlex algorithm in new implementations acknowledgments thank you daniel lichtblau for your extensive patient help and encouragement references 1 blinkov yu a and gerdt v p 2006 ginv polynomial test suite http invo jinr ru ginv index html 2 buchberger b 1965 ein algorithmus zum auffinden der basiselemente des restk lassenringes nach einem nulldimensionalen polynomideal mathematical institute university of innsbruck austria phd thesis 10 http invo jinr ru ginv index html 3 buchberger b 2006 an algorithm for finding the basis elements in the residue class ring modulo a zero dimensional polynomial ideal an english translation of 2 journal of symbolic computation 41 3 4 pp 475 511 4 giovini a mora t niesi g robbiano l and traverso c 1991 one sugar cube please or selection strategies in the buchberger algorithm proceedings of issac 1991 pp 49 54 5 gonnet g h char b w geddes k o 1983 solution of a general system of equations acm sigsam bulletin 17 3 4 pp 48 49 6 d bini b mourrain 2011 polynomial test suite http www sop inria fr saga pol 7 tran q n 2004 efficient gr bner walk conversion for implicitization of geometric objects computer aided geometric design 21 9 pp 837 857 8 trinks w 1978 ber b buchbergers verfahren systeme algebraischer gleichungen zu l sen journal of number theory 10 pp 475 488 9 verschelde j 2011 a collection of examples for polynomial systems http www math uic edu jan demo charac html 10 yap chee keng 1999 fundamental problems in algorithmic algebra oxford uni versity press isbn 0 19 512516 9 lecture xii 11 http www sop inria fr saga pol http www math uic edu jan demo charac html table 1 coefficient in z 32003 seconds time ratios for subtotal vs degrevlex order search term citations vars input tot degrees grevlex builtin sec grevlex grevlex matrix subtotal grevlex matrix cohn 3 1 4 63 5 7 24 0 08 0 08 filter design 6 9 5 42 3 24 10 1 0 98 0 22 benchmark i 1 1 10 310 2 78 0 30 0 31 assur 44 1 8 33 25 6 30 0 40 0 38 giovini 3 7 4 9 83 453 44 4 36 7 0 95 0 65 benchmark d 1 1 12 32 29 1 0 71 0 59 0 73 des 22 24 1 9 10 28 12 0 75 0 70 0 73 lichtblau 2 9 11 10 62 0 44 0 72 0 90 gonnet et al 5 17 219 6 01 0 74 0 95 cdpm 5 1 5 35 4 60 0 95 0 95 reimer 5 9 5 6 5 4 3 2 1 59 0 99 0 96 kotsireas 4 body 6 6 53 23 2 92 1 05 0 97 lichtblau 3 12 26 0 50 0 88 0 97 cyclic 6 1 9 6 6 5 4 3 2 1 0 62 1 01 0 97 giovini 3 1 4 7 42 310 2 0 57 1 17 0 97 eco 8 1 8 33 2 1 1 18 0 95 0 98 redeco 7 9 8 26 12 0 67 0 96 0 98 extcyc 5 1 6 52 4 3 2 1 1 15 1 00 0 98 f 744 1 12 32 22 12 5 13 0 93 0 98 lichtblau 1 6 53 5 91 1 02 0 99 virasoro 9 8 28 23 8 0 99 1 00 trott geometry 5 43 3 12 4 0 99 1 00 kotsireaus 4 bodysymmetric 6 7 52 32 22 36 2 1 00 1 01 katsura 7 9 7 26 1 0 78 0 99 1 01 redcyc 6 9 6 11 5 4 3 2 1 0 43 1 00 1 01 harrier rk 2 13 44 32 2 14 33 5 0 95 1 03 mathematica help 4 7 6 5 4 5 98 1 01 1 04 rpb 124 9 9 32 26 1 1 87 1 07 1 04 tran rational implicitization 7 5 62 5 5 13 0 96 1 05 kinema 1 9 26 13 2 07 1 03 1 07 kotsireaus 5 body 6 9 6 53 23 3 18 1 03 1 10 rpbl 9 6 35 2 0 94 1 07 1 13 variation on giovini 3 7 9 83 46 453 4 19 8 0 94 1 39 statistics median 8 0 2 85 0 98 0 98 mean 8 1 7 34 0 92 0 92 standard deviation 2 8 10 7 0 19 0 24 count 1 0000 22 20 count 1 0000 10 11 12 1 introduction 2 weight matrices and weight vectors 3 experimental procedures and results 3 1 experimental procedures 3 2 the test examples 3 3 test results 4 conclusions