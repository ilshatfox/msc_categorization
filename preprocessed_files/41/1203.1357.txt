ar x iv 1 20 3 13 57 v 1 cs s c 7 m ar 2 01 2 series misdemeanors david r stoutemyer march 19 2019 abstract puiseux series are power series in which the exponents can be fractional and or negative rational numbers several computer algebra systems have one or more built in or loadable functions for computing truncated puiseux series perhaps generalized to allow coefficients containing functions of the series variable that are dominated by any power of that variable such as logarithms and nested logarithms of the series variable some computer algebra systems also offer functions that can compute more general truncated recursive hierarchical series however for all of these kinds of truncated series there are important implementation details that haven t been addressed before in the published literature and in current implemen tations for implementers this article contains ideas for designing more convenient cor rect and efficient implementations or improving existing ones for users this article is a warning about some of these limitations many of the ideas in this article have been implemented in the computer algebra within the ti nspire calculator win dows and macintosh products 1 introduction here is a conversation recently overheard at a car rental desk customer i followed your directions of three right turns to get on the high way but that put me in a fenced corner from which i could only turn right bringing me back to where i started agent make your first right turn after exiting the rental car lot the original directions were correct but incomplete the same was true of published algorithms for truncated puiseux series after read ing all that i could find about such algorithms i implemented them for the computer algebra embedded in the ti nspire handheld graphing calculator which also runs on pc and macintosh computers testing revealed some incorrect results due to ignorance dstout at hawaii dot edu 1 http arxiv org abs 1203 1357 v 1 about some important issues results for other series implementations reveal that their implementers have made similar oversights it required a significant effort to determine how to overcome these difficulties this article is intended as a warning for users of implementations that exhibit the flaws and as suggestions to implementers for repairing those flaws or avoiding them in new implementations many of the ideas here are implemented in ti nspire additional issues for truncated and infinite series are described in a sequel to this article tentatively titled series crimes 13 for real world problems exact closed form symbolic solutions are less frequently ob tainable than are various symbolic series solutions therefore in practice symbolic series are among the most important features of computer algebra systems almost all computer algebra systems have a function that produces at least trun cated taylor series iterated differentiation followed by substitution of the expansion point provides a very compact implementation however it can consume time and data memory that grows painfully with the requested order of the result knuth 5 presents algorithms that are significantly more efficient for addition multiplication raising to a numeric power exponentials logarithms composition and reversion he also suggests how to derive analogous algorithms for any function that satisfies a linear differential equation silver and sullivan 10 additionally give such algorithms for sinusoids and hy perbolic functions brent and kung 1 pioneered algorithms that are faster when many non zero terms are needed if for a truncated puiseux series expanded about z 0 the degree of the lowest degree non zero term is and g is the greatest common divisor of the increments between the exponents of non zero terms then the mapping z t g can be used with care to adapt many of the taylor series algorithms for puiseux series as described by zipple 14 15 many puiseux series implementations have generalized them to allow coefficients that contain appropriate logarithms and nested logarithms that depend on the series variable geddes and gonnet 3 gruntz 4 and richardson et al 9 give algorithms for more general truncated hierarchical series that also correctly prioritize essential singularities and perhaps nested logarithms in coefficients koepf 7 implemented infinite puiseux series in which the result is expressed as a symbolic sum of terms the general term in the summand typically depends on the summation index and powers of the series variable some implementations compute dirichlet fourier or poisson series most of the issues described in this article are relevant to most kinds of truncated series and some of the issues are also relevant to infinite series to obtain a series for f w expanded about w w 0 with w 0 finite and non zero we can substitute w z w 0 into f w giving g z then determine the series expansion of g z about z 0 then back substitute z w w 0 into that result however if the series is to be used only for real w w 0 then using instead w w 0 z might give a result that more candidly avoids unnecessary appearances of i particularly if f w contains logarithms or fractional powers to obtain a series for f w expanded from the complex circle of radius we can substitute 1 z into f w giving h z then determine the series expansion of h z about z 0 then back substitute z 1 w into that result 2 a proper subset of the complex circle at infinity can be expressed by an appropriate constraint on the series variable such as series f w w h 1 w where h x series f 1 x x 0 x 0 therefore without loss of generality the expansion point is z 0 throughout the remain der of this article with z x iy rei where r 0 and x y r also wherever braced case constructs occur the tests are presumed to be done using short circuit evaluation from top to bottom to avoid the clutter of making the tests mutually exclusive 2 the disorder of order what we imagine is order is merely the prevailing form of chaos kerry thornley truncated series functions usually have a parameter by which the user requests a certain numeric order for the result existing implementations treat this request in different ways some of which are significantly more useful than others 2 1 render onto users what they request good order is the foundation of all things edmund burke mathematics is the art of giving the same name to different things jules henri poincar unfortunately the word order is used in too many ways in mathematics relevant definitions used in this article are definition the exact error order of a truncated series result expanded about z 0 is if the error is o z but the error isn t o z the exact error order of an exact series result expanded about z 0 is remark knuth 6 introduced the convenient notation z to denote exact order in z in comparison to o z z avoids discarding valuable information when we also know that a result isn t o z definition the degree of a truncated puiseux series with respect to z expanded about z 0 is the largest exponent of z that occurs outside of any argument of any o o or term that is included in the result 3 it is unreasonable to request a degree because for example there is no way for series cos z z 0 degree 1 to return a result of degree 1 it is also unreasonable to request an exact error order because for example series cos z z 0 z 3 can t return a series having error z 3 definition if a series function order argument denotes a request that the result be o z then the degree of an as requested big o result should be the largest degree that satisfies degree exact error order 1 remark it seems likely that more often users prefer to specify the highest degree term they want to view rather than the lowest degree term they don t want to view thus most users would prefer that the series function parameter denotes a request for a result that is o z therefore definition if a series function order argument denotes a request that the result be o z then the degree of an as requested little o result should be the largest degree that satisfies degree exact error order 2 the maxima mathematica and ti nspire truncated puiseux series functions use this little o interpretation of a numeric parameter for example glossing over their input and output syntax differences they all give series sin z z 3 z 0 5 1 z 2 1 6 z 2 120 z 4 5040 3 to this maxima appends and mathematica appends o z 6 it is easier to implement an interpretation in which the order parameter denotes that the inner most sub expressions are computed to o z and the final result is computed to whatever order that yields for reasons described below that can and often does lead to a result that is o z with a that is smaller or occasionally larger than for example it would omit the last term of result 3 for such an implementation it is essential to display an error term because otherwise 1 if exact order requested little o order then the result doesn t reveal that it is less accurate than requested which can be disastrous 2 if degree requested little o order then the user must notice and perhaps somehow truncate the excess terms to use the result in further calculations as intended however even if there is an error term indicating a result that doesn t have the requested accuracy this design is inconvenient for users because 1 users often don t notice the deficient or excessive accuracy 2 users who notice excessive order must perhaps somehow truncate the excess terms to use the result in further calculations as intended 4 3 users who notice deficient order are forced to iteratively guess the order argument to use in series to obtain sufficient accuracy then perhaps somehow truncate a result that exceeds the desired order 4 if the user is another function then that function should test the returned order and correct it if necessary by iterative adjustment and or truncation this is a requirement that might not occur to many authors of such functions particularly those who aren t professional computer algebra implementers it is more considerate reliable and efficient to build any necessary iterative adjustment and or truncation into the series function rather than to foist it on all function im plementers and top level users it isn t prohibitively harder to implement an as requested result 2 2 how to deliver as requested order definition if an infinite puiseux series is 0 then its dominant term is 0 otherwise the dominant term is the lowest degree non zero term definition if an infinite puiseux series is 0 then its dominant exponent is otherwise the dominant exponent is the exponent of the dominant term remark some authors call the dominant exponent the valuation or valence but other authors confusingly call it the order a typical truncated puiseux series implementation recursively computes series for the operands of each operator and the arguments of each function combining those series according to various algorithms table 1 lists the dominant exponent of a result and the operand orders that are necessary and sufficient to determine a result to o zk in that table a result dominant exponent of signifies an essential singularity as indicated there cancellation of the dominant terms of series u and v can cause the dominant exponent of u v to exceed min when such as for series ez cos z z 0 o z 1 z o z 1 o z z o z if the coefficient domain has zero divisors such as for modular arithmetic or floating point with underflow then the dominant exponent of uv can exceed and the dominant exponent of u can exceed unfortunately most of the entries in column 3 require us to know the dominant exponents of the operands perhaps also together with a dominant coefficient c and the exponent of the next non zero term if any therefore we need this information before computing the operand series to the correct order but we don t have this information until after we have computed the first term or two of the operand series one way to overcome the difficulty is as follows we can guess the dominant expo nent of the operands by using a function written according to rewrite rules such as the 5 following which are heuristically motivated by the second column of table 1 guessde z z 1 guessde u v z min guessde u z guessde v z guessde uv z guessde u z guessde v z guessde uk z k guessde u z guessde eu z 0 guessde sin u z max 0 guessde u z guessde ln u z guessde u 1 z if u 0 1 0 otherwise guessde arctanu z guessde u i z if u 0 i guessde u i z if u 0 i max 0 guessde u z otherwise guessde u z u is independent of z 0 if using the guess results in computing more terms than necessary then we should truncate the excess if using the guess doesn t produce the required order but reveals the dominant term and where needed the next non zero term then we know precisely the necessary and sufficient order to request for recomputing the series operands if using the guess doesn t reveal this information then when there is only one function argument we can iteratively increase the guess starting with an initial increment 0 for each iteration we can double the increment added to the initial guess this way in a modest multiple of the time required for the last iteration the process terminates successfully or by resource exhaustion resource exhaustion can be caused by an undetected essential singularity insufficient simplification of an operand expression or undetected constancy around the expansion point such as for x 1 x 1 at x 0 which can be more candidly expressed as 2 x x 1 1 1 x 1 2 x otherwise to increase the likelihood of the first increment being sufficient to expose the first non zero term or two but not prohibitively more terms than needed we can use a function that guesses the increment between the exponents of the first two non zero terms let u and v be expressions with guessde u z and guessde v z then the following 6 ordered rewrite rules are examples for such a function guessinc z z 0 guessinc u z guessinc u z guessinc uv z guessinc u z guessinc v z 0 guessinc v z guessinc u z 0 min guessinc u z guessinc v z otherwise guessinc ln u guessinc u 1 z if u 0 1 guessinc u z otherwise guessinc eu z guessinc u z if 0 otherwise guessinc sin u z 2 if guessinc u z 0 guessinc u z otherwise same for sinh u guessinc cos u z guessinc u z if 0 2 otherwise same for cosh u guessinc arctan u z if 0 2 if 0 guessinc u z 0 guessinc u u 0 z if u 0 i u 0 i guessinc u z otherwise guessinc arctanhu z if 0 2 if 0 guessinc u z 0 guessinc u u 0 z if u 0 1 u 0 1 guessinc u z otherwise guessinc arcsin u z 2 if guessinc u z 0 guessinc u z 2 if u 0 1 u 0 1 guessinc u z otherwise guessinc arcsinh u z 2 if guessinc u z 0 guessinc u z 2 if u 0 i u 0 i guessinc u z otherwise guessinc arccosh u z if 0 2 if 0 guessinc u z 0 guessinc u z 2 if u 0 1 u 0 1 guessinc u z otherwise guessinc u z u is independent of z 0 7 the treatment of sums is more easily stated procedurally let s be a sum and guessde s z let s be the set of all terms in s that have as the guess for their dominant exponent and let s be the set of all the other terms if s is empty let 0 otherwise let be the minimum guessed dominant exponent of the terms in s let 0 if 0 is the guessed increment for all of the terms in s otherwise let be the minimum non zero guessed increment in s then the guessed increment for the sum is min because guessde might return an incorrect guess for a dominant exponent it is possible for this guessinc to return 0 when the increment is actually positive therefore we can instead guess an increment of 1 if a top level invocation of guessinc returns 0 the required argument order in table 1 for the inverse trigonometric and inverse hyperbolic functions depends on whether the dominant exponent of the argument u is positive negative or 0 with the corresponding coefficient being a branch point evaluating u 0 can help us decide this if u 0 is a branch point then we can use the above iteration scheme on u u 0 to obtain the required order o zk if u 0 0 then 0 if u 0 is otherwise finite and non zero then 0 either way the required order for u is o zk otherwise either a negative dominant exponent or a coefficient having a logarithmic singularity caused u 0 to have infinite magnitude or to be indeterminant for such u 0 if guessde u z 0 then we can request o zk truncating if the resulting domi nant exponent is actually negative otherwise we can request an iterative determination of the appropriate order with the proviso that the order be o zk if is actually positive or else 0 with c not a branch point for a product of two or more operands let u contain a proper subset of the operands and v contain the complementary subset use recursion if u and or v is thereby a product letting u and v denote the corresponding truncated series we can guess initial dominant exponents and then alternatively increase them if necessary until either u or v reveals its true dominant exponent then we know enough to compute the other operand series to the appropriate order without iteration after which we know enough to truncate or compute additional terms of its companion if necessary we can terminate and return 0 for both u and v if a guess for yields u 0 o zk a guess for yields u 0 o zk and k algorithm 1 presents details the chances for needing to truncate or iterate are reduced if we choose for v a factor for which the guess for is most likely to be accurate such as a linear combination of powers of z to aid this choice we can have guessde also return a status that is an element of lowerbound exact upperbound uncertain with these constants being a guarantee about the guess example rules for computing 8 and propagating such a status are statusofgde z z equal statusofgde u v z lowerbound statusofgde uk z statusofgde u z if k 1 upperbound if statusofgde u z lowerbound lowerbound if statusofgde u z upperbound statusofgde u z otherwise for example if statusandgde u z returned lowerbound 6 and statusandgde v returned exact 4 then we know that series uv z 0 o z 9 is 0 o z 9 without com puting series for u and v we can return and exploit a similar status for guessinc for example if statusandgde u z lowerbound 6 statusandginc u z exact 0 then there is no point to iteratively increasing the requested order for u beyond 6 another way to compute operand series to the necessary and sufficient order pio neered by norman 8 is to use lazy evaluation streams or lisp continuations the idea is to generate at run time a network of co routines that recursively request additional order or additional non zero terms for sub expressions on an incremental as needed basis the above guesses and iterative techniques are relevant there too because if the request is for an increment to the order it might not produce another non zero term and if the request is for an additional non zero term iteration might be necessary to produce it however for such algorithms that don t recompute all of the terms each iteration it is probably more efficient not to increase the increment each iteration 2 3 optional requested number of non zero terms often rather than a requested order users need a requested number of non zero terms regardless of what order is required to achieve that most often the needed number of terms is 1 for example a particularly effective way to compute many limits is to compute the limit of the dominant term this is particularly helpful for indeterminacies of the form as another example if we equate a truncated series to a constant then it is much more likely that we can solve this equation for z if there are only one or two terms in the truncated series thus it is important to implement a separate function such as nterms expression variable point numberofnonzeroterms parameter numberofnonzeroterms could default to 1 and or there could be a sepa rate function such as dominantterm expression variable point 9 for a hierarchical series the user often doesn t know a priori an appropriate set of basis functions for the series and the dominant basis function can be an essential singularity or a logarithm rather than z for such series it is much more appropriate for users to request the desired number of terms rather than an order in z in this context it is appropriate to count recursively displayed terms of a hierarchical series as if they were fully expanded for example only one such distributed term is necessary for purposes such as computing a limit it is dangerously misleading to include a term unless all of the preceding terms are fully developed which might and often does require infinite series for the coefficients of some preceding terms for example it is inappropriate to include the z 3 term of z k 0 ln z k 2 k 1 z 2 z 3 o z 3 4 if the series for the coefficient of z 2 is truncated because ln z k z 2 2 k 1 dominates z 3 for all k 0 this is another reason that a requested distributed term count is more appropriate than an order request for truncated hierarchical series this is also a good reason for providing the option of not expanding coefficients as sub series where the implementation can t express them as infinite series and they don t terminate at a finite number of terms for example there should be an option for even a hierarchical series function to return z 1 2 ln z z 2 z 3 o z 3 for expression 4 to achieve a requested number of non zero terms we can iteratively increase the requested order until we obtain at least that number of non zero terms then truncate any excess terms the iteration could begin with a requested order somewhere in the interval guessde u z 0 n 1 guessinc u z where n is the requested number of non zero terms if this attempt exposes no terms then we can increment the request by n where starts at guessinc u z and doubles after each failed attempt however the implementation should address the fact that an expansion might ter minate as exact with fewer than the requested number of non zero terms the fact that the returned number of terms is less than requested is a subtle indication that the series is exact but an explicit error order term of the form makes this fact more no ticeable this is additional motivation for having each intermediate series result include an indication of exactness if known as elaborated in subsection 3 2 3 issues about displaying truncated series results in contrast to most other expressions the terms of a truncated puiseux series expanded about w w 0 for finite w 0 are traditionally displayed in order of increasing powers of w w 0 even if there are logarithms involving w in expressions multiplying some of those powers if series are represented using the same data structures as general expressions but different ordering then the different ordering might prevent key cancellations because 10 efficient bottom up simplification typically relies on the simplified operands of every operator having the same canonical ordering for example z series ez z 0 o z 2 z 1 z z 2 2 z 1 z z 2 2 rather than simplifying all the way to 1 z 2 2 the series function is most often used alone as an input perhaps with the result assigned to a variable rather than embedded in an expression if so and the assigned value is ordered normally or the system re simplifies pasted and assigned values when used in subsequent expressions then the differently ordered series result would safely be re ordered into the non series order during simplification of that subsequent input one way to overcome this difficulty entirely is to use a special data structure for series results then use a special method for displaying those results however the next subsection describes how onerous it is to integrate such special data structures into a system in a thorough seamless way 3 1 the pros and cons of an explicit error order term maxima 5 18 1 displays at the end of a truncated series result which means o zn where n is the order argument provided by the user mathematica 7 0 1 0 displays a big o term and maple 13 0 displays a big o term if the result isn t exact even when result orders are always as requested a displayed ellipsis is useful and a displayed error term is even more valuable they remind users that although the result is symbolic it is perhaps or definitely approximate moreover it provides an opportunity for the implementation to make such truncated series infectious which helps prevent users from misusing inappropriate mixtures of approximate results with exact results or with results having different orders or expansion points for example if a result of series is w 2 1 2 w 2 2 o w 2 2 then adding sin w to this result would return w 2 1 2 w 2 w 2 2 o w 2 2 with this infectiousness f w o w w 0 m is an elegant and convenient alternative to the input series f w w w 0 o w w 0 m unfortunately the effort required to do a thorough job of implementing this syntactic sugar is extensive to correctly propagate the influence of an error order term every command operator and function should have a method for properly treating it this obligation also applies to every new command operator or function that is subsequently added to a system including user contributed ones that aspire to be first class citizens seamlessly integrated into the system table 2 shows some examples that test an implementation s handling of explicit error order terms also test if the implementations you use can directly plot series results or 11 apply operators and functions such as lim solve and series to series results without the nuisance of first explicitly converting the series result to an ordinary expression 3 2 computation propagation and display of an order term with a little o interpretation of the series function order parameter and strict ad herence to delivering as requested order it is unnecessary to represent and propagate error order during the internal calculations even if we display o z for that requested order mathematica 7 0 1 0 and maple 13 0 display an error order using o rather than o however correctly determining a correct and satisfying exponent to use in o requires more work than o to return a result with a requested order o z using a o z we must determine a such that the degree of the first omitted non zero term if any is at least we can t just display o z 1 because with fractional powers the exponent of the first omitted term can be arbitrarily close to one way to determine a correct is to actually compute the first omitted non zero term but not display it however that omitted term can have a degree arbitrarily greater than costing substantial computation moreover there might not be any non zero terms having degree greater than therefore we don t know in advance what order if any will just expose a next non zero term whose coefficient we discard also if we find such a term it would be more informative to display z rather than o z another way to determine a correct is to compute a series that is o z with a predetermined such as 1 then truncate to o z and display o z or z where is the dominant degree of the truncated terms or display o z if no terms were truncated however with fractional exponents there can be arbitrarily many non zero terms having exponents in the interval which is costly moreover users might judge the implementation unfavorably if the exponent in o is obviously less than it could be for example with sin z the series z z 3 3 o z 4 is disturbing compared to z z 3 3 o z 5 which can be more informatively displayed as z z 3 3 z 5 when computing series we often know the exact order for the series of some or all sub expressions for example if the requested order is 3 then z 2 is z whereas z 5 is z 5 if we decide to store error order information with the series for each sub expression then it preserves information to store with the error order whether it is of type o o or and to propagate it according to rules such as for z z z z z o z z o z o z z o z z o z o z o z 12 4 a frugal dense representation a sparse series representation can more generally accommodate truncated hahn series which can also have irrational real exponents for example z 2 z z 4 this extra generality is desirable for hierarchical series adaptive precision interval arith metic can be used to keep the exponents properly ordered however most published algorithms for series are written in a notation that encour ages a dense representation as an array or list of coefficients with implied exponents adding two series is easy for sparse representation otherwise adapting most of the published truncated power series algorithms to a sparse representation seems likely to make them more complicated moreover with typical applications dense representation is efficient for most univariate polynomials hence also for most series as described in 11 recursive dense representation is also surprisingly efficient for most sparse multivariate polynomials hence also for recursive hierarchical series or multi variate series therefore this section describes a particularly efficient dense representation and some algorithmic necessities for maintaining it the allowance of negative exponents suggests that we should also explicitly store the exponent of the dominant term the allowance of fractional exponents suggests that we should also store the implicit positive rational exponent increment between successive stored coefficients to minimize the number of stored 0 coefficients it is most efficient to make this increment be the greatest common divisor of all the exponent increments between successive non zero coefficients the gcd of two reduced fractions is the gcd of their numerators divided by the least common multiple of their denominators the truncated series 0 can be represented canonically as a leading exponent of 0 an exponent increment of 0 and consistently either no coefficients or one coefficient that is 0 using no coefficients is more frugal and easier to program but one zero coefficient permits distinguishing a floating point series 0 0 o z from a rational coefficient series 0 o z rather than the gcd of the exponent increments many implementation instead use the reciprocal of the common denominator of all the exponents however this can require arbitrarily more space and time for example it would store and process 21 coefficients rather than 3 for 1 2 z 10 3 3 z 20 3 and it would store and process 31 coefficients rather than 4 for z 10 2 3 z 20 either way for canonicality programming safety and efficiency it is important to trim leading trailing and excessive intermediate zero coefficients from intermediate and final results wherever practical however within a function that adds two series etc it might be convenient to temporarily use series that have leading 0 coefficients and or an exponent increment that is larger than necessary for example when two series having different exponent increments are multiplied we can use copies in which extra zeros are inserted between the given coefficients of one or both series so that their mutual exponent increment is the gcd of the two series exponent increments 13 let be the gcd of the dominant exponents and exponent increments of two se ries if the series have different dominant exponents and or different exponent increments then before the series are added copies of one or both series can be padded with extra zeros before the dominant coefficient and or between coefficients so that both series start with the same implicit exponent and have the same implicit exponent increment for both examples the resulting series should then be adjusted if necessary so that its leading coefficient is non zero and its exponent increment is as large as possible when computing any one series the sub expressions all have the same expansion variable and expansion point 0 after the transformations described in section 1 also the desired order of the result is specified by the user and can be passed into the recursive calls for sub expressions adjusted according to table 2 if an implementation delivers an as requested o order then there is no need to store it in the series data structure for intermediate series results therefore only the dominant exponent exponent increment and frugalized coefficient list or array are necessary for an internal data structure during computation of any one series for each function or operator such as ln and it is helpful to have a function that given an expression and a requested order for expansion at z 0 1 guesses the dominant exponents of the operand series where needed 2 computes the guessed necessary and sufficient order to request for the operand series from table 2 and the guessed dominant exponents 3 recursively computes those series to the guessed necessary and sufficient orders 4 truncates if the requested orders are excessive or iteratively increases the requested orders if they are insufficient 5 invokes a companion lower level function to compute the result series from the resulting operand series for computing a function of a given series this companion function would be invoked directly if we wish to report to the user the type of the resulting order o or o and the corresponding exponent then the internal data structure must also contain fields for those if we also wish to preserve with the final result the expansion variable and expansion point then we must have an external data structure that includes those together with the internal data structure 5 exponentials interact with logarithmic coefficients definition a function f z is sub polynomial with respect to z if lim r 0 rei f rei 0 0 0 examples include 14 an expression independent of the expansion variable z or an expression that is piecewise constant with respect to z or an expression of the form ln c z z where q and c z is sub polynomial or any sub exponential function of sub polynomial expressions definition a sub exponential function g z is one for which g ln z is sub polynomial examples of sub exponential functions include rational functions fractional powers ln inverse trigonometric and inverse hyperbolic functions non constant sub polynomial coefficients can arise for a series of an expression that contains logarithms inverse trigonometric or inverse hyperbolic functions of the series variable most puiseux series algorithms require no change for coefficients that are generalized from constants to sub polynomial expressions making this powerful generalization of puiseux series cost very little additional program space for example some algorithms for computing functions of constant coefficient taylor series are derived via a differential equation however once the algorithms are obtained for constant coefficients there is no need to incur the difficulties of including any dependent coefficients in the differentiations and integrations used in the derivations however the algorithm for computing the exponential of a series does require a change for series having a non negative dominant exponent the algorithm begins by computing the exponential of the degree 0 term to use in the result coefficients if the degree 0 term is a multiple of a logarithm of a monomial containing a power of z then the exponential of the leading coefficient generates a power of z to avoid incorrect truncation levels this power of z should be combined with the perhaps implicit power portions of the data structure so that the true degree of each term is manifest in a canonical way other places where coefficients interact with powers are computing derivatives or integrals of a series with respect to z for example d dz ln z z 1 and ln z dz ln z 1 z 6 essential singularities exponentials and sinusoids of negative powers of z are essential singularities at z 0 for a series let u be the sum of the terms having negative exponents and u be the sum of all the other terms we could use the transformation eu u eu eu then compute the series for eu then distribute the essential singularity eu over the resulting terms as factors in the coefficients we could similarly use angle sum transformations for sinusoids of series having negative exponents however essential singularities dominate any power of z at z 0 if we distribute the essential singularity then subsequent series operations can truncate terms that dominate retained terms that don t contain the essential singularity giving an incorrect result for example series ez 1 1 z 2 sin z z 0 o z ez 1 ez 1 z 2 z o z incorrect ez 1 z o z 15 therefore it is more appropriate to produce a recursively represented series in eu having coefficients that are generalized puiseux series in z a hierarchical series we could have one extra field in our data structure for a multiplicative essential singu larity however that complicates the algorithms for very little gain because subsequent operations can easily require a more general representation for example one field for a single multiplicative essential singularity can t represent ez 2 z the extra effort of implementing such a limited ability to handle essential singularities is better spent implementing more general hierarchical series collecting exponentials in an expression permits computation of generalized puiseux series for some expressions containing essential singularities that are canceled by the collection for example ecsc z ecot z ecsc z cot z ez 2 z 3 24 1 z 2 z 2 8 e 1 x sinx x r e sinx x e 1 x 2 6 e ex 2 6 7 unnecessary restrictions not all puiseux series implementations currently allow fractional requested order how ever if fractional exponents are allowed in the result then it is important to permit them as the requested order too otherwise for example a user will have to compute and view 1001 terms of exp z 1 1000 merely to see the first two terms 1 z 1 1000 not all implementations currently allow negative requested order however if neg ative exponents are allowed in the result then it is important to permit them as the requested order too otherwise for example a user will have to compute and view 1001 terms of ez z 1000 merely to see the first two terms z 1000 z 999 these restrictions are probably caused by restricting some field in the data structure to a one word signed or unsigned integer which can also unnecessarily limit the magnitude of the requested order although most likely motivated by a desire for efficiency the savings are probably a negligible percentage of the time consumed by coefficient operations and other tasks not all implementations currently allow non real infinite magnitude expansion points such as for series w 1 w i 3 w 1 w despite the fact that such limit points can be mapped to a real infinity by a transformation such as w iz not all implementations currently allow full generality for sub polynomial coefficients for example series arcsin ln z z 0 3 arcsin ln z z 16 the sub polynomial coefficient of z 0 can be developed as a truncated hierarchical infinite series ln z ln z 3 6 which is preferable for some purposes such as computing a limit at z 0 however if the request is for expansion in powers of z then arcsin ln z has the advantage of being exact and much simpler summary the generalization from taylor series to generalized puiseux series introduces a surpris ing number of difficulties that haven t been fully addressed in previous literature and implementations such issues discussed in this article are avoiding unnecessary restrictions such as prohibiting negative or fractional orders the pros and cons of displaying results with explicit infectious error terms of the form o o and or efficient data structures and algorithms that efficiently give users exactly the order they request acknowledgments i thank david diminnie and arthur norman for their assistance references 1 brent p p and kung h t fast algorithms for manipulating formal power series journal of the acm 178 1978 pp 581 595 2 corless r m davenport j h jeffrey d j litt g and watt s m reasoning about the elementary functions of complex analysis artificial intelligence and sym bolic computation editors j a campbell and e roanes lozano springer 2001 pp 115 126 3 geddes k o and gonnet g h a new algorithm for computing symbolic limits using hierarchical series proceedings of issac 1998 lecture notes in computer science 358 pp 490 495 4 gruntz d a new algorithm for computing asymptotic series proceedings of issac 1993 pp 239 244 5 knuth d e the art of computer programming volume 2 addison wesley 3 rd edition 1998 section 4 7 6 knuth d e big omicron and big omega and big theta acm sigact news 8 2 1976 pp 18 24 17 7 koepf w power series in computer algebra j symb comput 13 1992 pp 581 603 8 norman a c computing with formal power series acm transactions on math ematical software 1 4 1975 acm press new york pp 346 356 9 richardson d salvy b shackell j van der hoeven j asymptotic expansions of exp log functions proceedings of the 1996 acm symposium on symbolic and algebraic manipulation pp 309 313 10 silver a and sullivan e the numerical solution of ordinary differential equations by the taylor series method nasa tm x 70438 1973 11 stoutemyer d r which polynomial representation is best proceedings of the 1984 macsyma user s conference schenectady n y pp 221 243 12 stoutemyer d r ten commandments for good default expression simplifica tion proceedings of the milestones in computer algebra conference dvd 2008 http www orcca on ca conferences mca 2008 13 stoutemyer d r series crimes to appear acm communications in computer algebra 14 zippel r e univariate power series expansions in algebraic manipulation pro ceedings of the 1976 acm symposium on symbolic and algebraic manipulation pp 198 208 15 zippel r e effective polynomial computation kluwer academic publishers 1993 chapter 10 pp 157 171 16 zippel r e simplification of nested radicals with applications to solving polyno mial equations mit m s thesis 1977 18 http www orcca on ca conferences mca 2008 table 1 requested operand orders for a result having order o zk with u cz bz o zm and v az hz o zn where m n k q operation result dominant exponent request m and n u v min m n k uv m k n k u v m k n k 2 u m k 1 eu cosu coshu 0 if 0 otherwise m k if 0 essential singularity otherwise sinu tanu sinhu tanhu if 0 otherwise m k if 0 essential singularity otherwise lnu if cz 1 0 otherwise m k arctanhu if 0 0 otherwise m k if cz 1 cz 1 k 2 if 0 k otherwise arctanu if 0 0 otherwise m k if cz i cz i k 2 if 0 k otherwise arcsinhu if 0 0 otherwise m k 2 if cz i cz i k 0 k otherwise arcsinu if 0 0 otherwise m k 2 if cz 1 cz 1 k 0 k otherwise arccosu arccoshu 2 if cz 1 0 otherwise m k 2 if cz 1 cz 1 k if 0 k otherwise 19 algorithm 1 compute series u and series v for computing series uv to o zk input symbolic expressions u and v variable z and rational number k output the ordered pair of truncated series u v each computed to the necessary and sufficient order so that uv is o zk u 1 v 1 1 means these increments haven t yet been computed guessde u z guessde v z m m 0 k n n 0 k loop u series u z 0 o zm if u 6 0 o zm then dominantexponent u n k v series v z 0 o zn if v 0 o zn then return u v dominantexponent v if m k then return u v if m k then return truncate u k v return series u z 0 o zm v v series v z 0 o zn if v 6 0 o zn then dominantexponent v m k u series u z 0 o zm if u 0 o zn then return u v dominantexponent u if n k then return u v if n k then return u truncate v k return u series v z 0 o zn if m n k then return u v u 1 u 0 guessinc u z 0 guessinc u z u 0 u u otherwise v 1 v 0 guessinc v z 0 guessinc v z v 0 v v otherwise m min m 0 u k n n min n 0 v k m endloop 20 table 2 test examples for treating explicit error order terms input equivalent to increasingly informative results z series z z 0 o z 2 o z o z 3 0 ln series ez z 0 o z 2 z o z 2 z o z 3 z z 3 1 z series ez z 0 o z o z o z 2 z 3 series ez z 0 o z 5 series ez z 0 o z 2 o z 2 o z 3 z 3 series ez z 3 z 0 o z 2 series ez z 0 o z 2 o z 2 o z 3 z 3 series ez z 3 z 0 o z 2 series ez z 0 o z 2 1 o z 2 1 o z 3 1 z 3 21 1 introduction 2 the disorder of order 2 1 render onto users what they request 2 2 how to deliver as requested order 2 3 optional requested number of non zero terms 3 issues about displaying truncated series results 3 1 the pros and cons of an explicit error order term 3 2 computation propagation and display of an order term 4 a frugal dense representation 5 exponentials interact with logarithmic coefficients 6 essential singularities 7 unnecessary restrictions