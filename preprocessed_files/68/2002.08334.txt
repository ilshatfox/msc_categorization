holistic specifications for robust programs sophia drossopoulou 1 0000 0002 1993 1142 james noble 2 0000 0001 9036 5692 julian mackay 2 0000 0003 3098 3901 and susan eisenbach 1 0000 0001 9072 6689 1 imperial college london scd susan imperial ac uk 2 victoria university of wellington julian mackay kjx ecs vuw ac nz abstract functional specifications describe what program components can do the sufficient conditions to invoke a component s operations they allow us to reason about the use of components in the closed world setting where the com ponent interacts with known client code and where the client code must establish the appropriate pre conditions before calling into the component sufficient conditions are not enough to reason about the use of components in the open world setting where the component interacts with external code pos sibly of unknown provenance and where the component itself may evolve over time in this open world setting we must also consider the necessary conditions i e what are the conditions without which an effect will not happen in this paper we propose a language chainmail for writing holistic specifications that focus on necessary conditions as well as sufficient conditions we give a formal se mantics for chainmail and the core of chainmail has been mechanised in the coq proof assistant 1 introduction software guards our secrets our money our intellectual property our reputation 47 we entrust personal and corporate information to software which works in an open world where it interacts with third party software of unknown provenance possibly buggy and potentially malicious this means we need our software to be robust to behave correctly even if used by erroneous or malicious third parties we expect that our bank will only make payments from our account if instructed by us or by somebody we have authorised that space on a web given to an advertiser will not be used to obtain access to our bank details 43 or that a concert hall will not book the same seat more than once while language mechanisms such as constants invariants object capabilities 40 and ownership 15 make it possible to write robust programs they cannot ensure that programs are robust ensuring robustness is difficult because it means different things for different systems perhaps that critical operations should only be invoked with the requisite authority perhaps that sensitive personal information should not be leaked or perhaps that a resource belonging to one user should not be consumed by another to ensure robustness we need ways to specify what robustness means for a particular program and ways to demonstrate that the particular program adheres to its specific robustness requirements consider the code snippets from fig 1 objects of class safe hold a treasure and a secret and only the holder of the secret can remove the treasure from the safe ar x iv 2 00 2 08 33 4 v 1 cs p l 1 9 f eb 2 02 0 2 s drossopoulou j noble et al class safe field treasure field secret method take scr if secret scr then t treasure treasure null return t class safe field treasure field secret method take scr as version 1 method set scr secret scr figure 1 two versions of the class safe we show the code in two versions both have the same method take and the second version has an additional method set we assume a dynamically typed language so that our results are applicable to the statically as well as the dynamically typed setting 3 that fields are private in the sense of java i e only methods of that class may read or write these fields and that addresses are unforgeable so there is no way to guess a secret a classical hoare triple describing the behaviour of take would be classicspec method take scr pre this safe post scr this secretpre this treasure null scr 6 this secretpre s safe s treasure s treasurepre classicspec expresses that knowledge of the secret is sufficient to remove the treasure and that take cannot remove the treasure unless the secret is provided but it cannot preclude that safe or some other class for that matter contains more methods which might make it possible to remove the treasure without knowledge of the secret this is the problem with the second version of safe it satisfies classicspec but is not robust as it is possible to overwrite the secret of the safe and then use it to remove the treasure to express robustness requirements we introduce holistic specifications and require that holisticspec s s safe s treasure 6 null will s treasure null o external o o accesss secret holisticspec mandates that for any safe s whose treasure is not null if some time in the future its treasure were to become null then at least one external object i e an object whose class is not safe in the current configuration has direct access to s s secret this external object need not have caused the change in s treasure but it would have transitively passed access to the secret which ultimately did cause that change both classes in fig 1 satisfy classicspec but the second version does not satisfy holisticspec 3 we do not depend on the additional safety static typing provides so we only assume a dynam ically typed language holistic specifications for robust programs 3 in this paper we propose chainmail a specification language to express holistic specifications the design of chainmail was guided by the study of a sequence of examples from the object capability literature and the smart contracts world the mem brane 18 the dom 21 59 the mint purse 40 the escrow 19 the dao 13 16 and erc 20 61 as we worked through the examples we found a small set of language constructs that let us write holistic specifications across a range of different contexts chainmail extends traditional program specification languages 31 37 with features which talk about permission which objects may have access to which other objects this is central since access to an object grants access to the functions it provides control which objects called functions on other objects this is useful in identifying the causes of certain effects eg funds can only be reduced if the owner called a payment function time what holds some time in the past the future and what changes with time space which parts of the heap are considered when establishing some property or when performing program execution a concept related to but different from memory footprints and separation logics viewpoint which objects and which configurations are internal to our component and which are external to it a concept related to the open world setting while many individual features of chainmail can be found in other work their power and novelty for specifying open systems lies in their careful combination the contributions of this paper are the design of the holistic specification language chainmail the semantics of chainmail a coq mechanisation of the core of chainmail the rest of the paper is organised as follows section 2 gives an example from the literature which we will use to elucidate key points of chainmail 3 presents the chainmail specification language section 4 introduces the formal model underlying chainmail and then section 5 defines the semantics of chainmail s assertions sec tion 6 discusses our design 7 considers related work and section 8 concludes we relegate key points of exemplar problems and various details to appendices which are available at 1 2 motivating example the bank as a motivating example we consider a simplified banking application taken from the object capabilities literature 41 accounts belong to banks and hold money balances with access to two accounts of the same bank one can transfer any amount of money from one to the other this example has the advantage that it requires several objects and classes we will not show the code here see appendix c but suffice it to say that class account has methods deposit src amt and makeaccount amt i e a method called deposit with two arguments and a method called makeaccount 4 s drossopoulou j noble et al with one argument similarly bank has method newaccount amt moreover deposit requires that the receiver and first argument this and src are accounts and belong to the same bank that the second argument amt is a number and that src s balance is at least amt if this condition holds then amt gets transferred from src to the receiver the function makenewaccount returns a fresh account with the same bank and transfers amt from the receiver account to the new account finally the function newaccount when run by a bank creates a new account with corresponding amount of money in it 4 it is not difficult to give formal specifications of these methods in terms of pre and post conditions however what if the bank provided a steal method that emptied out every ac count in the bank into a thief s account the critical problem is that a bank implement ation including a stealmethod could meet the functional specifications of deposit makeaccount and newaccount and still allow the clients money to be stolen one obvious solution would be to adopt a closed world interpretation of specifica tions we interpret functional specifications as exact in the sense that only implementa tions that meet the functional specification exactly with no extra methods or behaviour are considered as suitable implementations of the functional specification the prob lem is that this solution is far too strong it would for example rule out a bank that during software maintenance was given a new method count that simply counted the number of deposits that had taken place or a method notify to enable the bank to occasionally send notifications to its customers what we need is some way to permit bank implementations that send notifications to customers but to forbid implementations of steal the key here is to capture the implicit assumptions underlying the design of the banking application we provide additional specifications that capture those assumptions the following three informal requirements prevent methods like steal 1 an account s balance can be changed only if a client calls the deposit method with the account as the receiver or as an argument 2 an account s balance can be changed only if a client has access to that particular account 3 the bank account component does not leak access to existing accounts or banks compared with the functional specification we have seen so far these requirements capture necessary rather than sufficient conditions calling the deposit method to gain access to an account is necessary for any change to that account taking place the function steal is inconsistent with requirement 1 as it reduces the balance of an account without calling the function deposit however requirement 1 is not enough to protect our money we need to 2 to avoid an account s balance getting modified without access to the particular account and 3 to ensure that such accesses are not leaked we can express these requirements through chainmail assertions rather than spe cifying the behaviour of particular methods when they are called we write assertions that range across the entire behaviour of the bank account module 4 note that our very limited bank specification doesn t even have the concept of an account owner holistic specifications for robust programs 5 1 a a account changes a balance o o callsa deposit o calls deposit a 2 a s set a account will changes a balance ins o o s external o o accessa 3 a s set a account will o external o o accessa ins o o s external o o accessa in the above and throughout the paper we use an underscore to indicate an existen tially bound variable whose value is of no interest assertion 1 says that if an account s balance changes changes a balance then there must be some client object o that called the deposit method with a as a receiver or as an argument o calls deposit assertion 2 similarly constrains any possible change to an account s balance if at some future point the balance changes will changes and if this future change is observed with the state restricted to the objects from s i e ins then at least one of these objects o s is external to the bank account system external o and has direct access to that account object o accessa notice that while the change in the balance happens some time in the future the external object o has access to a in the current state notice also that the object which makes the call to deposit described in 1 and the object which has access to a in the current state described in 2 need not be the same it may well be that the latter passes a reference to a to the former indirectly which then makes the call to deposit it remains to think about how access to an account may be obtained this is the remit of assertion 3 it says that if at some time in the future of the state restricted to s some object o which is external has access to some account a and if a exists in the current state then in the current state some object from s has access to a where o and o may but need not be the same object and where o has to exist and have access to a in the current state but o need not exist in the current state it may be allocated later assertion 3 thus gives essential protection when dealing with foreign untrusted code when an account is given out to untrusted third parties assertion 3 guarantees that this account cannot be used to obtain access to further accounts a holistic specification for the bank account then would be a sufficient functional specification plus the necessary specifications 1 3 from above this holistic specific ation permits an implementation of the bank that also provides count and notify methods even though the specification does not mention either method critically though the chainmail specification does not permit an implementation that includes a steal method 3 chainmail overview in this section we give a brief and informal overview of some of the most salient fea tures of chainmail a full exposition appears in section 5 6 s drossopoulou j noble et al example configurations we will illustrate these features using the bank account ex ample from the previous section we use the runtime configurations 1 and 2 shown in the left and right diagrams in figure 2 in both diagrams the rounded boxes de pict objects green for those from the bank account component and grey for the external client objects the transparent green rectangle shows which objects are contained by the bank account component the object at 1 is a bank those at 2 3 and 4 are accounts and those at 91 92 93 and 94 are client objects which belong to classes different from those from the bank account module each configuration represents one alternative implementation of the bank object configuration 1 may arise from execution using a module mba 1 where account objects have a field mybank pointing to their bank and an integer field balance the code can be found in appendix c fig 6 configuration 2 may arise from execution using a module mba 2 where accounts have a mybank field bank objects have a ledger implemented though a sequence of nodes each of which has a field point ing to an account a field balance and a field next the code can be found in appendix c figs 9 and 7 1 1 bank 91 92 2 acc 3 acc 4 acc 94 93 2 1 bank 91 92 2 acc 3 acc 4 acc 94 93 10 nd 12 nd 11 nd figure 2 two runtime configurations for the bank account example for the rest assume variable identifiers b 1 and a 2 a 4 and u 91 u 94 denoting objects 1 2 4 and 91 94 respectively for both 1 and 2 that is for i 1 or i 2 i b 1 1 i a 2 2 i a 3 3 i a 4 4 i u 91 91 i u 92 92 i u 93 93 and i u 94 94 classical assertions talk about the contents of the local variables i e the topmost stack frame and the fields of the various objects i e the heap for example the assertion a 2 mybank a 3 mybank says that a 2 and a 3 have the same bank in fact this asser tion is satisfied in both 1 and 2 written formally as 1 a 2 mybank a 3 mybank 2 a 2 mybank a 3 mybank the term x classid says that x is an object of class classid for example 1 a 2 mybank bank we support ghost fields 12 31 e g a 1 balance is a physical field in 1 and a ghost field in 2 since in mba 2 an account does not store its balance as can be seen in appendix c fig 9 we also support the usual logical connectives and so we holistic specifications for robust programs 7 can express assertions such as a a account a mybank bank a balance 0 permission access our first holistic assertion x accessy asserts that object x has a direct reference to another object y either one of x s fields contains a reference to y or the receiver of the currently executing method is x and y is one of the arguments or a local variable for example 1 a 2 accessb 1 if 1 were executing the method body corresponding to the call a 2 deposit a 3 360 then we would have 1 a 2 accessa 3 namely during execution of deposit the object at a 2 has access to the object at a 3 and could if the method body chose to call a method on a 3 or store a reference to a 3 in its own fields access is not symmetric nor transitive 1 6 a 3 accessa 2 2 a 2 access a 3 2 6 a 2 accessa 3 control calls the assertion x callsm y zs holds in configurations where a method on object x makes a method call y m zs that is it calls method m with object y as the receiver and with arguments zs for example 3 x callsa 2 deposit a 3 360 means that the receiver in 3 is x and that a 2 deposit a 3 360 is the next state ment to be executed space in the space assertion a ins establishes validity of a in a configuration re stricted to the objects from the set s for example if object 94 is included in s 1 but not in s 2 then we have 1 o o accessa 4 ins 1 1 6 o o accessa 4 ins 2 the set s in the assertion a ins is therefore not the footprint of a it is more like the fuel 3 given to establish that assertion note that a ins does not im ply a nor does it imply a ins s the other direction of the implication does not hold either time next will prev was we support several operators from temporal logic next a will a prev a and was a to talk about the future or the past in one or more steps the assertion will a expresses thatawill hold in one or more steps for example tak ing 4 to be similar to 2 the next statement to be executed to be a 2 deposit a 3 360 and mba 2 4 a 2 balance 60 and that mba 2 4 a 4 balance 360 then mba 2 4 will a 2 balance 420 the internal module mba 2 is needed for looking up the method body of deposit viewpoint external the assertion external x expresses that the object at x does not belong to the module under consideration for example mab 2 2 external u 92 mab 2 2 6 external a 2 8 s drossopoulou j noble et al mab 2 2 6 external b 1 ledger the internal module mba 2 is needed to judge which objects are internal or external change and authority we have used changes in our chainmail assertions in section 2 as in changes a balance assertions that talk about change or give con ditions for change to happen are fundamental for security the ability to cause change is called authority in 40 we could encode change using the other features of chainmail namely for any expression e changes e v e v next e v and similarly for assertions putting these together we now look at some composite assertions which use several features from above the assertion below says that if the statement to be executed is a 2 deposit a 3 60 then the balance of a 2 will eventually change mba 2 2 callsa 2 deposit a 3 60 will changes a 2 balance now look deeper into space assertions a ins they allow us to characterise the set of objects which have authority over certain effects here a in particular the assertion will a ins requires two things i that a will hold in the future and ii that the objects which cause the effect which will make a valid are included in s knowing who has and who has not authority over properties or data is a fundamental concern of robustness 40 notice that the authority is a set rather than a single object quite often it takes several objects in concert to achieve an effect consider assertions 2 and 3 from the previous section they both have the form will a ins p s where p is some property over a set these assertions say that if ever in the future a becomes valid and if the objects involved in making a valid are included in s then s must satisfy p such assertions can be used to restrict whether a will become valid if we have some execution which only involves objects which do not satisfy p then we know that the execution will not ever make a valid in summary in addition to classical logical connectors and classical assertions over the contents of the heap and the stack our holistic assertions draw from some concepts from object capabilities access for permission calls and changes for authority as well as temporal logic will a was a and friends and the relation of our spatial connective a ins with ownership and effect systems 60 15 14 the next two sections discuss the semantics of chainmail section 4 contains an overview of the formal model and section 5 focuses on the most important part of chainmail assertions 4 overview of the formal foundations we now give an overview of the formal model for chainmail in section 4 1 we intro duce the shape of the judgments used to give semantics to chainmail while in section 4 2 we describe the most salient aspects of an underlying programming language used in chainmail holistic specifications for robust programs 9 4 1 chainmail judgments having outlined the ingredients of our holistic specification language the next question to ask is when does a module m satisfy a holistic assertion a more formally when does m a hold our answer has to reflect the fact that we are dealing with an open world where m our module may be linked with arbitrary untrusted code to model the open world we consider pairs of modules m m where m is the module whose code is supposed to satisfy the assertion and m is another module which exercises the functionality of m we call our module m the internal module and m the external module which represents potential attackers or adversaries we can now answer the question m a holds if for all further potentially ad versarial modules m and in all runtime configurations which may be observed as arising from the execution of the code of m combined with that of m the assertion a is satisfied more formally we define m a if m arising m m m m a module m represents all possible clients of m as it is arbitrarily chosen it reflects the open world nature of our specifications the judgement m m a means that assertion a is satisfied by m m and as in traditional specification languages 31 37 satisfaction is judged in the context of a runtime configuration but in addition it is judged in the context of the internal and external modules these are used to find abstract functions defining ghost fields as well as method bodies needed when judging validity of temporal assertions such as will we distinguish between internal and external modules this has two uses first chainmail includes the external o assertion to require that an object belongs to the external module as in the bank account s assertion 2 and 3 in section 2 second we adopt a version of visible states semantics 45 25 38 treating all executions within a module as atomic we only record runtime configurations which are external to module m i e those where the executing object i e the current receiver comes from module m execution has the form m m where we ignore all intermediate steps with receivers internal to m in the next section we shall outline the underlying programming language and define the judgment m m and the set arising m m 4 2 an underlying programming language loo the meaning of chainmail assertions is parametric with an underlying object oriented programming language with modules as repositories of code classes with fields meth ods and ghostfields objects described by classes a way to link modules into larger ones and a concept of program execution 5 we have developed loo a minimal such object oriented language which we out line in this section we describe the novel aspects of loo and summarise the more conventional parts relegating full and mostly unsurprising definitions to appendix a 5 we believe that chainmail can be applied to any language with these features 10 s drossopoulou j noble et al modules are central to loo as they are to chainmail as modules are repositories of code we adopt the common formalisation of modules as maps from class identifiers to class definitions c f appendix def 11 we use the terms module and component in an analogous manner to class and object respectively loo is untyped this has sev eral reasons many popular programming languages are untyped the external module might be untyped and so it is more general to consider everything as untyped finally a solution that works for an untyped language will also apply to a typed language the converse is not true class definitions consist of field method and ghost field declarations c f appendix def 12 method bodies are sequences of statements which can be field read or field assignments object creation method calls and return statements fields are private in the sense of c they can only be read or written by methods of the current class this is enforced by the operational semantics c f fig 4 we discuss ghost fields in the next section runtime configurations contain all the usual information about execution snap shots the heap and a stack of frames each frame consists of a continuation contn describing the remaining code to be executed by the frame and a map from variables to values values are either addresses or sets of addresses the latter are needed to deal with assertions which quantify over sets of objects as e g 1 and 2 from section 2 we define one module execution through a judgment of the form m in the appendix fig 4 we define a module linking operator so that m m is the union of the two modules provided that their domains are disjoint c f appendix def 18 as we said in section 4 1 we distinguish between the internal and external module we consider execution from the view of the external module and treat execution of methods from the internal module as atomic for this we define two module execution based on one module exe cution as follows definition 1 given runtime configurations and a module pair m m we define execution where m is the internal and m is the external module as below m m if there exist n 2 and runtime configurations 1 n such that 1 and n m m i i 1 for 1 i n 1 class this 6 dom m and class this 6 dom m class this i dom m for 2 i n 2 in the definition above class x looks up the class of the object stored at x c f appendix def 15 for example for 4 as in section 3 whose next statement to be ex ecuted is a 2 deposit a 3 360 we would have a sequence of configurations 41 4 n 5 so that the one module execution gives mba 2 4 41 42 4 n 5 this would correspond to an atomic evaluation in the two module exe cution mba 2 m 4 5 see fig 3 where blue stands for this m 1 and orange for this m 2 two module execution is related to visible states semantics 45 as they both filter configurations with the difference that in visible states semantics execution is unfiltered holistic specifications for robust programs 11 1 2 3 4 5 6 7 8 9 2 5 6 7 9 1 3 4 8 b a c figure 3 two module execution def 1 a m 1 m 2 b m 1 m 2 c m 2 m 1 and configurations are only filtered when it comes to the consideration of class invari ants while two module execution filters execution the lemma below says that linking is associative and commutative and preserves both one module and two module exe cution lemma 1 properties of linking for any modules m m m and m and runtime configurations and we have m m m m m m and m m m m m and m m is defined implies m m m m implies m m m m we can now answer the question as to which runtime configurations are pertinent when judging a module s adherence to an assertion initial configurations are those whose heap have only one object of class object and whose stack have one frame with arbitrary continuation arising configurations are those that can be reached by two module execution starting from any initial configuration definition 2 initial and arising configurations are defined as follows initial if consists of a single frame with dom this and there exists some address such that bthisc and dom and object arising m m 0 initial 0 m m 0 5 assertions chainmail assertions details in appendix b 3 consist of pure expressions e com parisons between expressions classical assertions about the contents of heap and stack the usual logical connectives as well as our holistic concepts in this section we fo cus on the novel holistic features of chainmail permission control time space and viewpoint as well as our wish to support some form of recursion while keeping the logic of assertions classical 12 s drossopoulou j noble et al 5 1 satisfaction of assertions access control space viewpoint permission expresses that an object has the potential to call methods on another object and to do so directly without help from any intermediary object this is the case when the two objects are aliases or the first object has a field pointing to the second object or the first object is the receiver of the currently executing method and the second object is one of the arguments or a local variable interpretations of variables and paths b c are defined in the usual way appendix def 15 definition 3 permission for any modules m m variables x and y we define m m x accessy if bxc and byc are defined and bxc byc or bx fc byc for some field f or bxc bthisc and byc bzc for some variable z and z appears in contn in the last disjunct where z is a parameter or local variable we ask that z appears in the code being executed contn this requirement ensures that variables which were introduced into the variable map in order to give meaning to existentially quantified assertions are not considered control expresses which object is the process of making a function call on another object and with what arguments the relevant information is stored in the continuation cont on the top frame definition 4 control for any modules m m variables x y z 1 zn we define m m x callsy m z 1 zn if bxc byc bz 1 c bznc are defined and bthisc bxc and contn u m v 1 vn for some u v 1 vn and byc buc and bzic bvic for all i thus x callsy m z 1 zn expresses the call y m z 1 zn will be executed next and that the caller is x viewpoint is about whether an object is viewed as belonging to the internal mode this is determined by the class of the object definition 5 viewpoint for any modules m m and variablex we define m m external x if bxc is defined and class bxc dom m m m internal x if bxc is defined and class bxc dom m space is about asserting that some property a holds in a configuration whose objects are restricted to those from a give set s this way we can express that the objects from the set s have authority over the assertion a in order to define validity of a ins in a configuration we first define a restriction operation s which restricts the objects from to only those from s holistic specifications for robust programs 13 definition 6 restriction of runtime configurations the restriction operator applied to a runtime configuration and a variable s is defined as follows s if dom bsc and dom for example if we take 2 from fig 2 in section 2 and restrict it with some set s 4 such that bs 4 c 2 91 1 2 3 4 11 then the restriction 2 s 4 will look as on the right 1 bank 91 2 acc 3 acc 4 acc 11 nd note in the diagram above the dangling pointers at objects 1 11 and 91 remin iscent of the separation of heaps into disjoint subheaps as provided by the operator in separation logic 53 the difference is that in separation logic the separation is provided through the assertions where a a holds in any heap which can be split into disjoint and where satisfiesa and satisfiesa that is ina a the split of the heap is determined by the assertions a and a and there is an implicit requirement of disjointness while in s the split is determined by s and no disjointness is required we now define the semantics of a ins definition 7 space for any modules m m assertions a and variable s we define m m a ins if m m s a the set s in the assertion a ins is related to framing from implicit dynamic frames 57 in an implicit dynamic frames assertion accx f a the frame x f prescrives which locations may be used to determine validity of a the difference is that frames are sets of locations pairs of address and field while our s es are sets of addresses more importantly implicit dynamic frames assertions whose frames are not large enough are badly formed while in our work such assertions are allowed and may hold or not e g mba 2 m n a 2 balance n ins 4 5 2 satisfaction of assertions time to deal with time we are faced with four challenges a validity of assertions in the future or the past needs to be judged in the future configuration but using the bindings from the current one b the current configuration needs to store the code being executed so as to be able to calculate future configurations c when considering the future we do not want to observe configurations which go beyond the frame currently at the top of the stack d there is no undo operator to deterministically enumerate all the previous configurations consider challenge a in some more detail the assertion will x f 3 is satisfied in the current configuration 1 if in some future configuration 2 the field f of the object that is pointed at by x in the current configuration 1 has the value 3 that is if bbxc 1 fc 2 3 even if in that future configuration x denotes a different object i e if bxc 1 6 bxc 2 to address this we define an auxiliary concept the operator where 14 s drossopoulou j noble et al 1 2 adapts the second configuration to the top frame s view of the former it returns a new configuration whose stack comes from 2 but is augmented with the view from the top frame from 1 and where the continuation has been consistently renamed this allows us to interpret expressions in 2 but with the variables bound according to 1 e g we can obtain that value of x in configuration 2 even if x was out of scope in 2 definition 8 adaptation for runtime configurations 1 2 1 2 3 2 2 if 3 contn 2 zs 2 zs 2 zs 7 2 zs 2 zs 1 7 1 zs 1 where 1 1 2 2 2 2 1 1 2 contn 2 2 and zs 1 dom 1 zs 2 dom 2 and zs is a set of variables with the same cardinality as zs 2 and all variables in zs are fresh in 1 and in 2 that is in the new frame 2 from above we keep the same continuation as from 2 but rename all variables with fresh names zs and combine the variable map 1 from 1 with the variable map 2 from 2 while avoiding names clashes through the renaming zs 7 2 zs 2 the consistent renaming of the continuation allows the correct modelling of execution as needed for the semantics of nested time assertions as e g in will x f 3 will x f 5 having addressed challenge a we turn our attention to the remaining challenges we address challenge b by storing the remaining code to be executed in cntn in each frame we address challenge c by only taking the top of the frame when considering future executions finally we address challenge d by considering only configurations which arise from initial configurations and which lead to the current configuration definition 9 time assertions for any modules m m and assertion a we define m m next a if m m m m a and where is so that m m will a if m m m m a and where is so that m m prev a if 1 2 initial 1 m m 1 2 m m 2 m m 2 a m m was a if 1 initial 1 m m 1 2 m m 1 2 m m 2 m m 2 a in general will a ins is different from will a ins namely in the former assertion s must contain the objects involved in reaching the future configuration as well as the objects needed to then establish validity of a in that future configuration in the latter assertion s need only contain the objects needed to establish a in that future configuration for example revisit fig 2 and take s 1 to consist of objects 1 2 4 93 and 94 and s 2 to consist of objects 1 2 4 assume that 5 is like 1 that the next call in 5 is a method on u 94 whose body obtains the address of a 4 by making a call on 93 to which it has access and the address of a 2 to which it has access and then makes the call a 2 deposit a 4 360 assume also that a 4 s balance is 380 then mba 1 5 will changes a 2 balance ins 1 mba 1 5 6 will changes a 2 balance ins 2 mba 1 5 will changes a 2 balance ins 2 holistic specifications for robust programs 15 5 3 properties of assertions we define equivalence of assertions in the usual way assertionsa anda are equivalent if they are satisfied in the context of the same configurations and module pairs i e a a if m m m m a if and only if m m a we can then prove that the usual equivalences hold e g a a a a and x a x a our assertions are classical e g a a false and m m a and m m a a implies m m a this desirable property comes at the loss of some expected equivalences e g in general e false and e are not equivalent more in appendix b 5 4 modules satisfying assertions finally we define satisfaction of assertions by modules a module m satisfies an asser tion a if for all modules m in all configurations arising from executions of m m the assertion a holds definition 10 for any module m and assertion a we define m a if m arising m m m m a 6 examplar driven design examplars the design of chainmail was guided by the study of a sequence of exem plars taken from the object capability literature and the smart contracts world 1 bank 49 bank and account as in section 2 with two different implementations 2 erc 20 61 ethereum based token contract 3 dao 13 16 ethereum contract for decentralised autonomous organisation 4 dom 21 59 restricting access to browser domain object model we present these exemplars as appendices 1 our design was also driven by work on other examples such as the membrane 18 the mint purse 40 and escrow 19 24 model we have constructed a coq model 2 of the core of the chainmail specifica tion language along with the underlying loo language our formalism is organised as follows 1 theloo language a class based object oriented language with mutable references 2 chainmail the full assertion syntax and semantics defined in definitions 1 2 3 4 5 6 7 8 9 and 10 3 loo properties secondary properties of the loo language that aid in reasoning about its semantics 4 chainmail properties the core properties defined on the semantics of chainmail 16 s drossopoulou j noble et al in the associated appendix see appendix g we list and present the properties of chainmail we have formalised in coq we have proven that chainmail obeys much of the properties of classical logic while we formalise most of the underlying semantics we make several assumptions in our coq formalism i the law of the excluded middle a property that is well known to be unprovable in constructive logics and ii the equal ity of variable maps and heaps down to renaming coq formalisms often require fairly verbose definitions and proofs of properties involving variable substitution and renam ing and assuming equality down to renaming saves much effort more details of the formal foundations of chainmail and the model are also in appendices 1 7 related work behavioural specification languages hatcliff et al 26 provide an excellent survey of contemporary specification approaches with a lineage back to hoare logic 28 meyer s design by contract 38 was the first popular attempt to bring verification techniques to object oriented programs as a whole cloth language design in eiffel several more recent specification languages are now making their way into practical and educational use including jml 31 spec 5 dafny 32 and whiley 51 our approach builds upon these fundamentals particularly leino shulte s formulation of two state invariants 33 and summers and drossopoulou s considerate reason ing 58 in general these approaches assume a closed system where modules can be trusted to cooperate in this paper we aim to work in an open system where modules invariants must be protected irrespective of the behaviour of the rest of the system defensive consistency in an open world we cannot rely on the kindness of strangers rather we have to ensure our code is correct regardless of whether it interacts with friends or foes attackers only have to be lucky once while secure systems have to be lucky always 6 miller 39 40 defines the necessary approach as defensive consistency an object is defensively consistent when it can defend its own invariants and provide correct service to its well behaved clients despite arbitrary or malicious misbehaviour by its other clients defensively consistent modules are particularly hard to design to write to understand and to verify but they make it much easier to make guarantees about systems composed of multiple components 46 object capabilities and sandboxes capabilities as a means to support the develop ment of concurrent and distributed system were developed in the 60 s by dennis and van horn 20 and were adapted to the programming languages setting in the 70 s 44 object capabilities were first introduced 40 in the early 2000 s and many recent stud ies manage to verify safety or correctness of object capability programs google s caja 42 applies sandboxes proxies and wrappers to limit components access to ambient authority sandboxing has been validated formally maffeis et al 35 develop a model of javascript demonstrate that it obeys two principles of object capability systems and show how untrusted applications can be prevented from interfering with the rest of the system recent programming languages 27 11 54 including newspeak 10 dart 9 grace 8 30 and wyvern 36 have adopted the object capability model holistic specifications for robust programs 17 verification of object capability programs murray made the first attempt to formalise defensive consistency and correctness 46 murray s model was rooted in counterfac tual causation 34 an object is defensively consistent when the addition of untrust worthy clients cannot cause well behaved clients to be given incorrect service murray formalised defensive consistency very abstractly over models of concurrent object capability systems in the process algebra csp 29 without a specification language for describing effects such as what it means for an object to provide incorrect service both miller and murray s definitions are intensional describing what it means for an object to be defensively consistent drossopoulou and noble 22 48 have analysed miller s mint and purse example 40 and discussed the six capability policies as proposed in 40 in 23 they sketched a specification language used it to specify the six policies from 40 showed that sev eral possible interpretations were possible and uncovered the need for another four fur ther policies they also sketched how a trust sensitive example the escrow exchange could be verified in an open world 24 their work does not support the concepts of control time or space as in chainmail but it offers a primitive expressing trust swasey et al 21 have deployed powerful theoretical techniques to address similar problems they show how step indexing kripke worlds and representing objects as state machines with public and private transitions can be used to reason about object capabilities devriese have demonstrated solutions to a range of exemplar problems in cluding the dom wrapper replicated in our section f and a mashup application their distinction between public and private transitions is similar to the distinction between internal and external objects more recently swasey et al 59 designed ocpl a logic for object capability pat terns that supports specifications and proofs for object oriented systems in an open world they draw on verification techniques for security and information flow separ ating internal implementations high values which must not be exposed to attacking code from interface objects low values which may be exposed ocpl supports de fensive consistency they use the term robust safety from the security community 7 via a proof system that ensures low values can never leak high values to external at tackers this means that low values can be exposed to external code and the behaviour of the system is described by considering attacks only on low values they use that lo gic to prove a number of object capability patterns including sealer unsealer pairs the caretaker and a general membrane schaefer et al 55 have recently added support for information flow security us ing refinement to ensure correctness in this case confidentiality by construction by enforcing encapsulation all these approaches share similarity with techniques such as ownership types 15 50 which also protect internal implementation objects from ac cesses that cross encapsulation boundaries banerjee and naumann demonstrated that these systems enforce representation independence a property close to robust safety some time ago 4 chainmail differs from swasey schaefer s and devriese s work in a number of ways they are primarily concerned with mechanisms that ensure encapsulation aka confinement while we abstract away from any mechanism via the external predic ate they use powerful mathematical techniques which the users need to understand 18 s drossopoulou j noble et al in order to write their specifications while the chainmail users only need to under stand first order logic and the holistic operators presented in this paper finally none of these systems offer the kinds of holistic assertions addressing control flow change or temporal operations that are at the core of chainmail s approach scilla 56 is a minimalistic typed functional language for writing smart contracts that compiles to the ethereum bytecode scilla s semantic model is restricted assuming actor based communication and restricting recursion thus facilitating static analysis of scilla contracts and ensuring termination scilla is able to demonstrate that a number of popular ethereum contracts avoid type errors out of gas resource failures and pre servation of virtual currency scilla s semantics are defined formally but have not yet been represented in a mechanised model finally the recent verx tool is able to verify a range of specifications for solidity contracts automatically 52 similar to chainmail verx has a specification language based on temporal logic verx offers three temporal operators always once prev but only within a past modality while chainmail has two temporal operators both existen tial but with both past and future modalities verx specifications can also include pre dicates that model the current invocation on a contract similar to chainmail s calls can access variables and compute sums only over collections chainmail is strictly more expressive as a specification language including quantification over objects and sets so can compute arbitrary reductions on collections and of course specifications for permission access space in and viewpoint external which have no ana logues in verx unlike chainmail verx includes a practical tool that has been used to verify a hundred properties across case studies of twelve solidity contracts 8 conclusions in this paper we have motivated the need for holistic specifications presented the spe cification language chainmail for writing such specifications and outlined the formal foundations of the language to focus on the key attributes of a holistic specification language we have kept chainmail simple only requiring an understanding of first order logic we believe that the holistic features permission control time space and viewpoint are intuitive concepts when reasoning informally and were pleased to have been able to provide their formal semantics in what we argue is a simple manner 9 acknowledgments this work is based on a long standing collaboration with mark m miller and toby murray we have received invaluable feedback from alex summers bart jacobs mi chael jackson members of wg 2 3 and the fase 2020 reviewers the work has been supported by the nz marsden grants xxxx and yyy and also research gifts from agoric the ethereum foundation and facebook references 1 holistic specifications paper with appendices https www dropbox com s l 7 ztnlyugm 0 weio examples pdf dl 0 accessed 2019 10 30 holistic specifications for robust programs 19 2 zip file of coq proofs https www dropbox com s dvv 0 f 93 f 3 p 65 dgt coq zip dl 0 ac cessed 2019 10 30 3 ahmed a dreyer d rossberg a state dependent representation independence in popl 2009 4 banerjee a naumann d a ownership confinement ensures representation independence for object oriented programs j acm 52 6 894 960 nov 2005 5 barnett m leino k r m schulte w the spec programming system an overview in cassis pp 49 69 lncs springer 2005 6 bbc on this day 1984 tory cabinet in brighton bomb blast 2015 online accessed 15 october 2015 7 bengtson j bhargavan k fournet c gordon a d maffeis s refinement types for secure implementations acm trans program lang syst 33 2 8 1 8 45 feb 2011 8 black a bruce k homer m noble j grace the absence of inessential difficulty in onwards 2012 9 bracha g the dart programming language dec 2015 10 bracha g the newspeak language specification version 0 1 feb 2017 newspeaklan guage org 11 burtsev a johnson d kunz j eide e van der merwe j e capnet security and least authority in a capability enabled cloud in proceedings of the 2017 symposium on cloud computing socc 2017 santa clara ca usa september 24 27 2017 pp 128 141 2017 12 chalin p kiniry j r leavens g t poll e beyond assertions advanced specification and verification with jml and esc java 2 in formal methods for components and objects 4 th international symposium fmco 2005 amsterdam the netherlands november 1 4 2005 revised lectures pp 342 363 2005 https doi org 10 1007 11804192 16 ht tps doi org 10 1007 11804192 16 13 christoph jentsch decentralized autonomous organization to automate governance mar 2016 https download slock it public dao whitepaper pdf 14 clarke d drossopoulou s ownership encapsulation and the disjointness of type and effectr in oopsla acm 2002 15 clarke d g potter j m james noble ownership types for flexible alias protection in oopsla acm 1998 16 coindesk understanding the dao attack 2016 www coindesk com understanding dao hack journalists 17 community s solidity https solidity readthedocs io en develop 18 van cutsem t membranes in javascript 2012 available from prog vub ac be tvcutsem invokedynamic js membranes 19 cutsem t v s m trustworthy proxies virtualizing objects with invariants in ecoop 2013 20 dennis j b horn e c v programming semantics for multiprogrammed computations comm acm 9 3 1966 21 devriese d birkedal l piessens f reasoning about object capabilities with lo gical relations and effect parametricity in ieee euros p pp 147 162 2016 ht tps doi org 10 1109 eurosp 2016 22 22 drossopoulou s noble j the need for capability policies in ftfjp 2013 23 drossopoulou s noble j towards capability policy specification and verification may 2014 ecs victoria ac nz main technicalreportseries 24 drossopoulou s noble j miller m swapsies on the internet first steps towards reason ing about risk and trust in an open world in plas 2015 25 guttag j v horning j j larch languages and tools for formal specification springer 1993 20 s drossopoulou j noble et al 26 hatcliff j leavens g t leino k r m m ller p parkinson m j behavioral interface specification languages acm comput surv 44 3 16 2012 27 hayes i j wu x meinicke l a capabilities for java secure access to resources in aplas pp 67 84 2017 28 hoare c a r an axiomatic basis for computer programming comm acm 12 576 580 1969 29 hoare c a r communicating sequential processes prentice hall 1985 30 jones t homer m james noble bruce k b object inheritance without classes in ecoop pp 13 1 13 26 2016 31 leavens g t poll e clifton c cheon y ruby c cok d r m ller p kiniry j chalin p jml reference manual february 2007 iowa state univ www jmlspecs org 32 leino k r dafny an automatic program verifier for functional correctness in lpar 16 springer april 2010 33 leino k r m schulte w using history invariants to verify observers in esop 2007 34 lewis d causation journal of philosophy 70 17 1973 35 maffeis s mitchell j taly a object capabilities and isolation of untrusted web applic ations in proc of ieee security and privacy 2010 36 melicher d shi y potanin a aldrich j a capability based module system for author ity control in ecoop pp 20 1 20 27 2017 37 meyer b eiffel the language prentice hall 1992 38 meyer b object oriented software construction second edition prentice hall second edn 1997 39 miller m s cutsem t v tulloh b distributed electronic rights in javascript in esop 2013 40 miller m s robust composition towards a unified approach to access control and con currency control ph d thesis baltimore maryland 2006 41 miller m s morningstar c frantz b capability based financial instruments from ob ject to capabilities in financial cryptography springer 2000 42 miller m s samuel m laurie b awad i stay m safe active content in sanitized javascript 2008 code google com p google caja 43 mitre organisation cwe 830 inclusion of web functionality from an untrusted source 2019 https cwe mitre org data definitions 830 html 44 morris jr j h protection in programming languages cacm 16 1 1973 45 m ller p poetzsch heffter a leavens g t modular invariants for layered object struc tures science of computer programming 62 253 286 2006 46 murray t analysing the security properties of object capability patterns ph d thesis university of oxford 2010 47 murray t sison r engelhardt k covern a logic for compositional verification of information flow control in euros p 2018 48 noble j drossopoulou s rationally reconstructing the escrow example in ftfjp 2014 49 noble j potanin a murray t miller m s abstract and concrete data types vs object capabilities in m ller p schaefer i eds principled software development 2018 50 noble j potter j vitek j flexible alias protection in ecoop jul 1998 51 pearce d groves l designing a verifying compiler lessons learned from developing whiley sci comput prog 2015 52 permenev a dimitrov d tsankov p drachsler cohen d vechev m verx safety verification of smart contracts in ieee symp on security and privacy 2020 53 reynolds j c separation logic a logic for shared mutable data structures in lics pp 55 74 ieee computer society 2002 54 rhodes d disney t flanagan c dynamic detection of object capability violations through model checking in dls pp 103 112 2014 holistic specifications for robust programs 21 55 schaefer i runge t kn ppel a cleophas l kourie d g watson b w towards confidentiality by construction in leveraging applications of formal methods verific ation and validation modeling 8 th international symposium isola 2018 limassol cyprus november 5 9 2018 proceedings part i pp 502 515 2018 56 sergey i nagaraj v johannsen j kumar a trunov a chan k safer smart contract programming with scilla in oopsla 2019 57 smans j jacobs b piessens f implicit dynamic frames toplas 2012 58 summers a j drossopoulou s considerate reasoning and the composite pattern in vmcai 2010 59 swasey d garg d dreyer d robust and compositional verification of object capabil ity patterns in oopsla 2017 60 talpin j p jouvelot p the type and effect discipline in lics pp 162 173 1992 61 the ethereum wiki erc 20 token standard dec 2018 ht tps theethereum wiki w index php erc 20 token standard 22 s drossopoulou j noble et al a foundations programming language a 1 modules and classes loo programs consist of modules which are repositories of code since we study class based oo languages in this work code is represented as classes and modules are map pings from identifiers to class descriptions definition 11 modules we define module as the set of mappings from identifiers to class descriptions the latter defined in definition 12 module m m identifier classdescr classes as defined below consist of field method definitions and ghost field declar ations loo is untyped and therefore fields are declared without types method signa tures and ghost field signatures consist of sequences of parameters without types and no return type method bodies consist of sequences of statements these can be field read or field assignments object creation method calls and return statements all else e g booleans conditionals loops can be encoded field read or write is only allowed if the object whose field is being read belongs to the same class as the current method this is enforced by the operational semantics c f fig 4 ghost fields are defined as implicit side effect free functions with zero or more parameters they are ghost in formation i e they are not directly stored in the objects and are not read written during execution when such a ghostfield is mentioned in an assertion the corresponding func tion is evaluated more in section b 2 note that the expressions that make up the bodies of ghostfield declarations e are more complex than the terms that appear in individual statements from now on we expect that the set of field and the set of ghostfields defined in a class are disjoint definition 12 classes class descriptions consist of field declarations method de clarations and ghostfield declarations classdescr class classid fielddecl methdecl ghosdecl fielddecl field f methdecl method m x stmts stmts stmt stmt stmts stmt x f x x x f x x m x x new c x return x ghostdecl ghost f x e e true false null x e e if e then e else e e f e x f m identifier where we use metavariables as follows x varid f fldid m methid c classid and x includes this we define a method lookup function m which returns the corresponding method definition given a class c and a method identifier m and similarly a ghostfield lookup function g holistic specifications for robust programs 23 definition 13 lookup for a class identifier c and a method identifier m m m c m m p 1 pn stmts if m c classc methodm p 1 pn stmts undefined otherwise g m c f f p 1 pn e if m c classc ghostm p 1 pn e undefined otherwise a 2 the operational semantics of loo we will now define execution of loo code we start by defining the runtime entities and runtime configurations which consist of heaps and stacks of frames the frames are pairs consisting of a continuation and a mapping from identifiers to values the continuation represents the code to be executed next and the mapping gives meaning to the formal and local parameters definition 14 runtime entities we define addresses values frames stacks heaps and runtime configurations we take addresses to be an enumerable set addr and use the identifier addr to indicate an address values v are either addresses or sets of addresses or null v null addr p addr continuations are either statements as defined in definition 12 or a marker x for a nested call followed by statements to be executed once the call returns continuation stmts x stmts frames consist of a code stub and a mapping from identifiers to values codestub ident v alue stacks are sequences of frames objects consist of a class identifier and a partial mapping from field identifier to values object classid fieldid v alue heaps are mappings from addresses to objects addr object runtime configurations are pairs of stacks and heaps note that values may be sets of addresses such values are never part of the execu tion of loo but are used to give semantics to assertions next we define the interpreta tion of variables x and field look up x f in the context of frames heaps and runtime configurations these interpretations are used to define the operational semantics and also the validity of assertions later on in definitions 3 7 definition 15 interpretations we first define lookup of fields and classes where is an address and f is a field identifier f fldmap f if fldmap class c if c we now define interpretations as follows 24 s drossopoulou j noble et al bxc x bx fc v if x fldmap and fldmap f v for ease of notation we also use the shorthands below bxc bxc bx fc bx fc class class class x class bxc in the definition of the operational semantics of loo we use the following notations for lookup and updates of runtime entities definition 16 lookup and update of runtime configurations we define convenient shorthands for looking up in runtime entities assuming that is the tuple stub varmap we use the notation contn to obtain stub assuming a value v and that is the tuple stub varmap we define contn 7 stub for updating the stub i e stub varmap we use x 7 v for updat ing the variable map i e stub varmap x 7 v assuming a heap a value v and that c fieldmap we use f 7 v as a shorthand for updating the object i e 7 c fieldmap f 7 v execution of a statement has the form m and is defined in figure 4 definition 17 execution of one or more steps is defined as follows the relation m it is defined in figure 4 m holds if i or ii there exists a such that m and m a 3 module linking when studying validity of assertions in the open world we are concerned with whether the module under consideration makes a certain guarantee when executed in conjunc tion with other modules to answer this we need the concept of linking other modules to the module under consideration linking is an operation that takes two modules and creates a module which corresponds to the union of the two we place some condi tions for module linking to be defined we require that the two modules do not contain implementations for the same class identifiers definition 18 module linking the linking operator module module module is defined as follows m m m aux m if dom m dom m undefined otherwise and where for all c m aux m c m c if c dom m and m c otherwise some properties of linking are described in lemma 1 in the main text for the proof 1 and 2 follow from definition 18 3 follows from 18 and the fact that if a lookup m is defined for m then it is also defined for m m and returns the same method and similar result for class lookup holistic specifications for robust programs 25 methcall os contn x x 0 m x 1 xn stmts bx 0 c m m class m m p 1 pn stmts 1 stmts 1 this 7 p 1 7 bx 1 c pn 7 bxnc m contn 7 x stmts varassgn os contn x y f stmts class y class this m contn 7 stmts x 7 by fc fieldassgn os contn x f y stmts class x class this m contn 7 stmts bxc f 7 byc objcreate os contn x new c x 1 xn stmts new in f 1 fn are the fields declared in m c m contn 7 stmts x 7 7 c f 1 7 bx 1 c fn 7 bxnc return os contn returnx stmts or contn returnx contn x stmts m contn 7 stmts x 7 bxc figure 4 operational semantics 26 s drossopoulou j noble et al a 4 module pairs and visible states semantics a module m adheres to an invariant assertion a if it satisfies a in all runtime config urations that can be reached through execution of the code of m when linked to that of any other module m and which are external to m we call external to m those configur ations which are currently executing code which does not come from m this allows the code in m to break the invariant internally and temporarily provided that the invariant is observed across the states visible to the external client m we have defined two module execution in the main paper def 1 in that definition n is allowed to have the value 2 in this case the final bullet is trivial and there exists a direct external transition from to our definition is related to the concept of visible states semantics but differs in that visible states semantics select the configurations at which an invariant is expected to hold while we select the states which are considered for executions which are expected to satisfy an invariant our assertions can talk about several states through the use of the will and was connectives and thus the intention of ignoring some intermediate configurations can only be achieved if we refine the concept of execution we have defined initial and arising configurations in definition 2 note that there are infinitely many different initial configurations they will be differing in the code stored in the continuation of the unique frame holistic specifications for robust programs 27 b foundations specification language we now define the syntax and semantics of expressions and holistic assertions the novel holistic features of chainmail permission control time space and view point as well as our wish to support some form of recursion while keeping the logic of assertions classical introduced challenges which we discuss in this section b 1 syntax of assertions definition 19 assertions assertions consist of pure expressions e classical asser tions about the contents of heap stack the usual logical connectives as well as our holistic concepts e true false null x e e if e thene elsee e f e a e e e e classid e s a a a a a a a x a s set a x a s set a x access y x callsx m x next a will a prev a was a s ina external x x f m identifier expressions support calls with parameters e f e these are calls to ghostfield functions this supports recursion at the level of expressions therefore the value of an expression may be undefined either because of infinite recursion or because the expression accessed undefined fields or variables assertions of the form e e are satisfied only if both e and e are defined because we do not support recursion at the level of assertions assertions from a classical logic e g a a is a tautology we will discuss evaluation of expressions in section b 2 standard assertions about heap stack and logical connectives in b 3 we have discussed the treatment of permis sion control space and viewpoint in the main text in the definitions 3 7 in section 5 1 the treatment of time in definitions 8 9 in the main text section 5 2 we will discuss properties of assertions in lemmas 2 3 the judgement m m a expresses that a holds in m m and and while m m 6 a expresses that a does not hold in m m and b 2 values of expressions the value of an expression is described through judgment m e v defined in figure 5 we use the configuration to read the contents of the top stack frame rule var val or the contents of the heap rule field heap val we use the module m to find the ghost field declaration corresponding to the ghost field being used the treatment of fields and ghost fields is described in rules field heap val field ghost val and field ghost val 2 if the field f exists in the heap then its 28 s drossopoulou j noble et al value is returned field heap val ghost field reads on the other hand have the form e 0 f e 1 en and their value is described in rule field ghost val the lookup func tion g defined in the obvious way in the appendix def 13 returns the expression constituting the body for that ghost field as defined in the class of e 0 we return that expression evaluated in a configuration where the formal parameters have been substi tuted by the values of the actual parameters ghost fields support recursive definitions for example imagine a module m 0 with a class node which has a field called next and which had a ghost field last which finds the last node in a sequence and is defined recursively as if this next null then this else this next last and another ghost field acyclic which expresses that a sequence is acyclic defined recursively as if this next null then true else this next acyclic the relation is partial for example assume a configuration 0 where acyc points to a node whose field next has value null and cyc points to a node whose field next has the same value as cyc then m 0 0 acyc acyclic true but we would have no value for m 0 0 cyc last nor for m 0 0 cyc acyclic notice also that for an expression of the form e f both field heap val and field ghost val 2 could be applicable rule field heap val will be applied if f is a field of the object at e while rule field ghost val will be applied if f is a ghost field of the object at e we expect the set of fields and ghost fields in a given class to be disjoint this allows a specification to be agnostic over whether a field is a physical field or just ghost in formation for example assertions 1 and 2 from section 2 talk about the balance of an account in module mba 1 appendix c where we keep the balances in the account objects this is a physical field in mba 2 also in appendix c where we keep the balances in a ledger this is ghost information b 3 satisfaction of assertions standard we now define the semantics of assertions involving expressions the heap stack and lo gical connectives the semantics are unsurprising except perhaps the relation between validity of assertions and the values of expressions definition 20 interpretations for simple expressions for a runtime configuration variables x or s we define its interpretation as follows bxc x if bsc s if bx fc bxc f if definition 21 basic assertions for modules m m configuration we define m m e if m e true holistic specifications for robust programs 29 true val m true true false val m false false null val m null null var val m x x field heap val m e f v m e f v field ghost val 2 m e f v m e f v field ghost val m e 0 m ei vi i 1 n g m class f f p 1 pn e m p 1 7 v 1 pn 7 vn e w v m e 0 f e 1 en v if true val m e true m e 1 v m if e then e 1 else e 2 v if false val m e false m e 2 v m if e then e 1 else e 2 v equals true val m e 1 v m e 2 v m e 1 e 2 true equals false val m e 1 v m e 2 v v 6 v m e 1 e 2 false figure 5 value of expressions m m e e if there exists a value v such that m e v and m e v m m e classid if there exists an address such that m e and class classid m m e s if there exists a value v such that m e v and v bsc satisfaction of assertions which contain expressions is predicated on termination of these expressions continuing our earlier example m 0 m 0 acyc acyclic holds for any m while m 0 m 0 cyc acyclic does not hold and m 0 m 0 cyc acyclic false does not hold either in general when m m e holds then m m e true holds too but when m m e does not hold this does not imply that m m e false holds finally an assertion of the form e 0 e 0 does not always hold for example m 0 m 0 cyc last cyc last does not hold we now define satisfaction of assertions which involve logical connectives and ex istential or universal quantifiers in the standard way definition 22 assertions with logical connectives and quantifiers for modules m m assertions a a variables x y s and configuration we define m m s set a if m m q 7 r a s q for all sets of addresses r dom and all q free in and a 30 s drossopoulou j noble et al m m s set a if m m q 7 r a s q for some set of addresses r dom and q free in and a m m x a if z 7 a x z for all dom and some z free in and a m m x a if m m z 7 a x z for some dom and z free in and a m m a a if m m a implies m m a m m a a if m m a and m m a m m a a if m m a or m m a m m a if m m a does not hold satisfaction is not preserved with growing configurations for example the assertion x x account x balance 100 may hold in a smaller configuration but not hold in an extended configuration nor is it preserved with configurations getting smaller consider e g x x account x balance 100 again with our earlier example m 0 m 0 cyc acyclic true and m 0 m 0 cyc acyclic false and also m 0 m 0 cyc last cyc last hold we define equivalence of assertions in the usual sense two assertions are equivalent if they are satisfied in the context of the same configurations similarly an assertion entails another assertion iff all configurations which satisfy the former also satisfy the latter definition 23 equivalence and entailments of assertions a j a if m m m m a implies m m a a a if a j a and a j a lemma 2 assertions are classical 1 for all runtime configurations assertions a and a and modules m and m we have 1 m m a or m m a 2 m m a a if and only if m m a and m m a 3 m m a a if and only if m m a or a 4 m m a a never holds 5 m m a and m m a a implies m m a proof the proof of part 1 requires to first prove that for all basic assertions a either m m a or m m 6 a we prove this using definition 21 then we prove for all possible assertions by induction of the structure of a and the definitions 22 and also definitions 3 4 5 7 and 9 using the definition of m m a from definition 22 we conclude the proof of 1 for parts 2 5 the proof goes by application of the corresponding definitions from 22 compare also with appendix g holistic specifications for robust programs 31 lemma 3 assertions are classical 2 for assertions a a and a the following equivalences hold 1 a a false 2 a a true 3 a a a a 4 a a a a 5 a a a a a a 6 a a a a a a a 7 a a a a a a a 8 a a a a 9 a a a a 10 x a x a 11 s set a s set a 12 x a x a 13 s set a s set a proof all points follow by application of the corresponding definitions from 22 com pare also with appendix g 32 s drossopoulou j noble et al c exemplar bank account class bank method newaccount amt if amt 0 then return new account this amt class account field balance field mybank method deposit src amt if amt 0 src mybank this mybank src balance amt then this balance this balance amt src balance src balance amt method makeaccount amt if amt 0 this balance amt then this balance this balance amt return new account this mybank amt figure 6 mba 1 implementation of bank and account version 1 in this section we revisit the bank account example from 2 and show two dif ferent implementations derived from noble et al 49 both implementations satisfy the three functional specifications and the holistic assertions 1 2 and 3 shown in section 2 the first version gives rise to runtime configurations as 1 shown on the left side of fig 2 while the second version gives rise to runtime configurations as 2 shown on the right side of fig 2 in the main text in this code we use more syntax than the minimal syntax defined for loo in def 11 as we use conditionals and we allow nesting of expressions e g a field read to be the receiver of a method call such extension can easily be encoded in the base syntax mba 1 the fist version is shown fig 6 it keeps all the information in the account object namely the account contains the pointer to the bank and the balance while the bank is a pure capability which contains no state but is necessary for the creation of new accounts in this version we have no ghost fields mba 1 the second version is shown fig 9 and 7 it keeps all the information in the ledger each node points to an account and contains the balance for this particular holistic specifications for robust programs 33 class bank field ledger a node method deposit dest src amt destnd this ledger find dest srcnd this ledger find src srcbalance srcnd getbalance if destnd null srcnd null srcbalance amt amt 0 then destnd addtobalance amt srcnc addtobalance amt method newaccount amt if amt 0 then newacc new account this this ledger new node amt this ledger newacc return newacc ghost balance acc this ledger balance acc figure 7 mba 2 implementation of bank version 2 account here balance is a ghost field of account the body of that declaration calls the ghost field function balanceof of the bank which in its turn calls the ghost field function balanceof of the node note that the latter is recursively defined note also that node exposes the function addtobalance a call to this function modifies the balance of an account without requiring that the caller has access to the account this might look as if it contradicted assertions 1 and 2 from section 2 however upon closer inspection we see that the assertion is satisfied remember that we employ a two module semantics where any change in the balance of an account is observed from one external state to another external state by definition a configuration is external if its receiver is external however no external object will ever have access to a node and therefore no external object will ever be able to call the method addtobalance in fact we can add another assertion 4 which promises that any internal object which is externally accessible is either a bank or an account 4 o o external o external o o accesso o account o bank 34 s drossopoulou j noble et al class node field balance field next field myaccount method addtobalance amt this balance this balance amt method find acc if this myaccount acc then return this else if this next null then return null else return this next find acc method getbalance return balance ghost balance acc if this myaccount acc then this balance else if this next null then 1 else this next find acc figure 8 mba 2 implementation of node version 2 class account field mybank method deposit src amt this mybank deposit this src amt method makeaccount amt if amt 0 this balance amt then newacc this mybank makenewaccount 0 newacc deposit this amt return newacc ghost balance this mybank balance this figure 9 mba 2 implementation of account version 2 holistic specifications for robust programs 35 d examplar authorising erc 20 erc 20 61 is a widely used token standard which describes the basic functionality ex pected by any ethereum based token contract it issues and keeps track of participants tokens and supports the transfer of tokens between participants transfer of tokens can take place only provided that there were sufficient tokens in the owner s account and that the transfer was instigated by the owner or by somebody authorized by the owner we specify this in chainmail as follows a decrease in a participant s balance can only be caused by a transfer instigated by the account holder themselves i e p calls transfer or by an authorized transfer instigated by another participant p i e p calls transferfrom who has authority for more than the tokens spent i e e allowed p p m e erc 20 p object m m nat e balance p m m next e balance p m p p object p callse transfer p m e allowed p p m p callse transferfrom p m that is to say if next configuration witnesses a decrease of p s balance by m then the current configuration was a call of transfer instigated by p or a call of transferfrom instigated by somebody authorized by p the term e allowed p p means that the erc 20 variable e holds a field called allowed which maps pairs of participants to numbers such mappings are supported in solidity 17 we now define what it means for p to be authorized to spend up to m tokens on p s behalf at some point in the past p gave authority to p to spend m plus the sum of tokens spent so far by p on the behalf of p e erc 20 p p object m nat e allowed p p m prev p callse approve p m e allowed p p m p callse transferfrom p p callse approve p p object m nat e allowed p p m m p callse transferfrom p m in more detail p is allowed to spend up to m tokens on their behalf of p if in the previous step either a p made the call approve on e with arguments p and m or b p was allowed to spend up to m tokens for p and did not transfer any of p s tokens nor did p issue a fresh authorization or c p was authorized for m m and spent m 36 s drossopoulou j noble et al thus the holistic specification gives to account holders an authorization guarantee their balance cannot decrease unless they themselves or somebody they had authorized instigates a transfer of tokens moreover authorization is not transitive only the account holder can authorise some other party to transfer funds from their account authorisa tion to spend from an account does not confer the ability to authorise yet more others to spend also with traditional specifications to obtain the authorization guarantee one would need to inspect the pre and post conditions of all the functions in the contract and determine which of the functions decrease balances and which of the functions affect authorizations in the case of the erc 20 one would have to inspect all eight such specifications given in appendix d 1 where only five are relevant to the question at hand in the general case e g the dao the number of functions which are unrelated to the question at hand can be very large more importantly with traditional specifications nothing stops the next release of the contract to add e g a method which allows participants to share their authority and thus violate the authorization guarantee or even a super user from skimming 0 1 from each of the accounts holistic specifications for robust programs 37 d 1 example erc 20 the traditional specification we compare the holistic and the traditional specification of erc 20 as we said earlier the holistic specification gives to account holders an authorization guarantee their balance cannot decrease unless they themselves or somebody they had authorized instigates a transfer of tokens moreover authorization is not transitive only the account holder can authorise some other party to transfer funds from their account authorisation to spend from an account does not confer the ability to authorise yet more others to spend also with traditional specifications to obtain the authorization guarantee one would need to inspect the pre and post conditions of all the functions in the contract and determine which of the functions decrease balances and which of the functions affect authorizations in figure 10 we outline a traditional specification for the erc 20 we give two speficiations for transfer another two for tranferfrom and one for all the remaining functions the first specification says e g that if p has sufficient tokens and it calls transfer then the transfer will take place the second specification says that if p has insufficient tokens then the transfer will not take place we assume that in this specification language any entities not mentioned in the pre or post condition are not affected similarly we would have to give another two specifications to define the behaviour of if p is authorized and executes transferfrom then the balance decreases but they are implicit about the overall behaviour and the necessary conditions e g what are all the possible actions that can cause a decrease of balance 38 s drossopoulou j noble et al e erc 20 p p object m m m nat e balance p m m e balance p m this p e transfer p m e balance p m e balance p m m e erc 20 p p object m m m nat e balance p m m m e transfer p m e balance p m e erc 20 p p p object m m m m nat e balance p m m e allowed p p m m e balance p m this p e transferfrom p p m e balance p m e balance p m m e allowed p p m e erc 20 p p object m m m nat this p e balance p m m m e allowed p p m m m e transferfrom p p m e balance p m e allowed p p m e erc 20 p p object m nat this p e approve p m e allowed p p m e erc 20 m nat p balance m k e balanceof p k m e balanceof p m e erc 20 m nat e allowed p p m k e allowance p p k m e allowed p p m e erc 20 m nat p dom e balance e balance p m k e totalsupply k m figure 10 classical specification for the erc 20 holistic specifications for robust programs 39 e examplar defending the dao the dao decentralised autonomous organisation 13 is a famous ethereum con tract which aims to support collective management of funds and to place power directly in the hands of the owners of the dao rather than delegate it to directors unfortunately the dao was not robust a re entrancy bug exploited in june 2016 led to a loss of 50 m and a hard fork in the chain 16 with holistic specifications we can write a succinct requirement that a dao contract should always be able to repay any owner s money any contract which satisfies such a holistic specification cannot demonstrate the dao bug our specification consists of three requirements first that the dao always holds at least as much money as any owner s balance to express this we use the field balances which is a mapping from participants s addresses to numbers such mapping valued fields exist in solidity but they could also be taken to be ghost fields 12 d dao p any m nat d balances p m d ether m second that when an owner asks to be repaid she is sent all her money d dao p any m nat d balance p m p callsd repay will d callssend p m third that the balance of an owner is a function of the its balance in the previous step or the result of it joining the dao or asking to be repaid etc d dao p m nat d balance p m prev p callsd repay m 0 prev p callsd join m more cases are needed to reflect the financing and repayments of proposals but they can be expressed with the concepts described so far the requirement that d holds at least m ether precludes the dao bug in the sense that any contract satisfying that spec cannot exhibit the bug a contract which satisfies the spec is guaranteed to always have enough money to satisfy all repay requests this guarantee holds regardless of how many functions there are in the dao in contrast to preclude the dao bug with a classical spec one would need to write a spec for each of the dao functions currently 19 a spec for each function of the auxiliary contracts used by the dao and then study their emergent behaviour these 19 dao functions have several different concerns who may vote for a pro posal who is eligible to submit a proposal how long the consultation period is for deliberating a proposal what is the quorum how to chose curators what is the value of a token of these groups of functions only a handful affect the balance of a participant holistic specifications allow us to concentrate on aspect of dao s behaviour across all its functions 40 s drossopoulou j noble et al f examplar attenuating the dom attenuation is the ability to provide to third party objects restricted access to an ob ject s functionality this is usually achieved through the introduction of an intermediate object while such intermediate objects are a common programming practice the term was coined and the practice was studied in detail in the object capabilities literature e g 40 the key structure underlying a web browser is the domain object model dom a recursive composite tree structure of objects that represent everything display in a browser window each window has a single dom tree which includes both the page s main content and also third party content such as advertisements to ensure third party content cannot affect a page s main content specifications for attenuation for the dom were proposed in devriese et al 21 this example deals with a tree of dom nodes access to a dom node gives access to all its parent and children nodes and the ability to modify the node s properties however as the top nodes of the tree usually contain privileged information while the lower nodes contain less crucial third party information we want to be able to limit access given to third parties to only the lower part of the dom tree we do this through a wrapper which has a field node pointing to a node and a field height which restricts the range of nodes which may be modified through the use of the particular wrapper namely when you hold a wrapper you can modify the property of all the descendants of the height th ancestors of the node of that particular wtrapper in figure 11 we show an example of the use of wrapper objects attenuating the use of nodes the function usingwrappers takes as parameter an object of unknown provenance here called unknwn on lines 2 7 we create a tree consisting of nodes n 1 n 2 n 6 depicted as blue circles on the right hand side of the figure on line 8 we create a wrapper of n 5 with height 1 this means that the wrapper w may be used to modify n 3 n 5 and n 6 i e the objects in the green triangle while it cannot be used to modify n 1 n 2 and 4 i e the objects within the blue triangle on line 8 we call a function named untrusted on the unknown object and pass w as argument even though we know nothing about the unknown object or its untrusted func tion and even though the call gives to unknown access to w which in turn has transitive access to all node s in the tree we know that line 100 will not affect the property fields of the nodes n 1 n 2 and n 4 thus the assertion on line 12 is guaranteed to suc ceed the question is how do we specify wrapper so as to be able to make such an argument a specification of the class wrapper in the traditional style e g 31 consists of pairs of pre and post conditions for each of the functions of that class each such pair gives a sufficient condition for some effect to take place for example the call w setproperty i prp where i is smaller than w height is a sufficient con dition to modify property of the i th parent of w node but we do not know what other ways there may be to modify a node s property in other words we have not specified the necessary conditions in our example holistic specifications for robust programs 41 method usingwrappers unknwn n 1 node null fixed n 2 node n 1 robust n 3 node n 2 const n 4 node n 3 volatile n 5 node n 4 variable n 6 node n 5 ethereal w wrapper n 5 1 unknwn untrusted w assert n 2 property robust n 5 n 1 n 6 n 2 n 4 n 3 unknwn w figure 11 wrappers protecting nodes the necessary condition for the modification of nd property for some nd of class node is either access to some node in the same tree or access to a w of class wrapper where the w height th parent of w is an ancestor of nd with such a specification we can prove that the assertion on line 12 will succeed and more importantly we can ensure that all future updates of the wrapper abstract data type will uphold the protection of the node data to give a flavour of chainmail we use it express the requirement from above s set nd node o object will changes nd property ins o o s o node o wrapper nd node o accessnd w wrapper k n o accessw nd parntk w node parntw height that is if the value of nd property is modified changes at some future point will and if reaching that future point involves no more objects than those from set s i e ins then at least one o of the objects in s is not a node nor a wrapper and o has direct access to some node o accessnd or to some wrap per w and the w height th parent of w is an ancestor of nd that is parntk w node parntw height note that our access is intransitive x access y holds if either x has a field pointing to y or x is the receiver and y is one of the arguments in the executing method call 42 s drossopoulou j noble et al g coq formalism in this section we present the properties of chainmail that have been formalised in the coq model table 1 refers to proofs that can be found in the associated coq formalism 2 lemma 1 and 3 properties of linking 1 modulelinking associative 2 modulelinking commutative 1 3 modulelinking commutative 2 4 linking preserves reduction lemma 2 1 a a false 2 a a true 3 a a a a 4 a a a a 5 a a a a a a 1 sat and nsat equiv false 2 3 and commutative 4 or commutative 5 or associative lemma 3 1 a a false 2 a a true 3 a a a a 4 a a a a 5 a a a a a a 6 a a a a a a a 7 a a a a a a a 8 a a a a 9 a a a a 10 x a x a 11 s a s a 12 x a x a 13 s a s a 1 sat and nsat equiv false 2 3 and commutative 4 or commutative 5 or associative 6 and distributive 7 or distributive 8 neg distributive and 9 neg distributive or 10 not ex x all not 11 not ex all not 12 not all x ex not 13 not all ex not table 1 chainmail properties formalised in coq