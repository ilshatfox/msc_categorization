genomic problems involving copy number profiles complexity and algorithms genomic problems involving copy number profiles complexity and algorithms manuel lafond department of computer science universite de sherbrooke sherbrooke quebec j 1 k 2 r 1 canada manuel lafond usherbrooke ca binhai zhu gianforte school of computing montana state university bozeman mt 59717 usa bhz montana edu peng zou gianforte school of computing montana state university bozeman mt 59717 usa peng zou student montana edu abstract recently due to the genomic sequence analysis in several types of cancer the genomic data based on copy number profiles cnp for short are getting more and more popular a cnp is a vector where each component is a non negative integer representing the number of copies of a specific gene or segment of interest the motivation is that in the late stage of certain types of cancer the genomes are progressing rapidly by segmental duplications and deletions hence obtaining the exact sequences is becoming more difficult instead in this case the number of copies of important genes can be predicted from expression analysis and carries important biological information therefore a lot of research have been started to analyze the genomic data represented in cnp s in this paper we present two streams of results the first is the negative results on two open problems regarding the computational complexity of the minimum copy number generation mcng problem posed by qingge et al in 2018 the minimum copy number generation mcng is defined as follows given a string s over a gene set with n and a cnp c compute a string t from s with the minimum number of segmental duplications and deletions such that cnp t c it was shown by qingge et al that the problem is np hard if the duplications are tandem and they left the open question of whether the problem remains np hard if arbitrary duplications are used we answer this question affirmatively in this paper in fact we prove that it is np hard to even obtain a constant factor approximation this is achieved through a general purpose lemma on set cover reductions that require an exact cover in one direction but not the other which might be of independent interest we also prove that the corresponding parameterized version is w 1 hard answering another open question by qingge et al the other result is positive and is based on a new and more general problem regarding cnp s the copy number profile conforming cnpc problem is formally defined as follows given two cnp s c 1 and c 2 compute two strings s 1 and s 2 with cnp s 1 c 1 and cnp s 2 c 2 such that the distance between s 1 and s 2 d s 1 s 2 is minimized here d s 1 s 2 is a very general term which means it could be any genome rearrangement distance like reversal transposition and tandem duplication etc we make the first step by showing that if d s 1 s 2 is measured by the breakpoint distance then the problem is polynomially solvable we expect that this will trigger some related research along the line in the near future 2012 acm subject classification theory of computation keywords and phrases computational genomics cancer genomics copy number profiles np hardness approximation algorithms fpt algorithms funding this research was partially supported by nserc of canada ar x iv 2 00 2 04 77 8 v 1 cs d s 1 2 f eb 2 02 0 mailto manuel lafond usherbrooke ca mailto bhz montana edu mailto peng zou student montana edu 2 genomic problems involving copy number profiles 1 introduction in cancer genomics research intra tumor genetic heterogeneity is one of the central problems 9 10 14 understanding the origins of cancer cell diversity could help cancer prognostics 3 8 and also help explain drug resistance 2 4 it is known for some types of cancers such as high grade serous ovarian cancer hgsoc that heterogeneity is mainly acquired through endoreduplications and genome rearrangements these result in aberrant copy number profiles cnps nonnegative integer vectors representing the numbers of genes occurring in a genome 11 to understand how the cancer progresses an evolutionary tree is certainly desirable and producing a valid evolutionary tree based on these genomic data becomes a new problem in 13 schwarz et al proposed a way to construct a phylogenetic tree directly from integer copy number profiles the underlying problem being to convert cnps into one another using the minimum number of duplications deletions 15 in 12 another fundamental problem was proposed the motivation is that in the early stages of cancer when large numbers of endoreduplications are still rare genome sequencing is still possible however in the later stage we might only be able to obtain genomic data in the form of cnps this leads to the problem of comparing a sequenced genome with a genome with only copy number information given a genome g represented as a string and a copy number profile c the minimum copy number generation mcng problem asks for the minimum number of deletions and duplications needed to transform g into any genome in which each character occurs as many times as specified by c qingge et al proved that the problem is np hard when the duplications are restricted to be tandem and posed several open questions 1 is the problem np hard when the duplications are arbitrary 2 does the problem admit a decent approximation 3 is the problem fixed parameter tractable fpt in this paper we answer all these three open questions we show that mcng is np hard to approximate within any constant factor and that it is w 1 hard when parameterized by the solution size the inapproximability follows from a new general purpose lemma on set cover reductions that require an exact cover in one direction but not the other the w 1 hardness uses a new set cover variant in which every optimal solution is an exact cover these set cover extensions can make reductions to other problems easier and may be of independent interest we also consider a new fundamental problem called copy number profile conforming cnpc which is defined as follows given two cnp s c 1 and c 2 compute two strings genomes s 1 and s 2 with cnp s 1 c 1 and cnp s 2 c 2 such that the distance between s 1 and s 2 d s 1 s 2 is minimized the distance d s 1 s 2 could be general which means it could be any genome rearrangement distance such as reversal transposition and tandem duplication etc we make the first step by showing that if d s 1 s 2 is measured by the breakpoint distance then the problem is polynomially solvable 2 preliminaries a genome g is a string i e a sequence of characters all of which belong to some alphabet the characters of g can be interpreted as genes or segments we use genome and string interchangeably in this paper when the context is clear a substring of g is a sequence of contiguous characters that occur in g and a subsequence is a string that can be obtained from g by deleting some characters we write g p to denote the character at position p of g the first position being 1 and we write g i j for the substring of g from positions i to j inclusively for s we write g s to denote the subsequence of g obtained by removing all occurrences of s lafond zhu and zou 3 we represent an alphabet as an ordered list s 1 s 2 sm of distinct characters slightly abusing notation we may write s if s is a member of this list we write ns g to denote the number of occurrences of s in a genome g a copy number profile or cnp on is a vector c c 1 c that associates each character si of the alphabet with a non negative integer ci n we may write c s to denote the number associated with s in c we write c s to denote the cnp obtained from c by setting c s 0 the copy number profile cnp of genomeg denoted cnp g is the vector of occurrences of all characters of formally 1 cnp g ns 1 g ns 2 g nsm g for example if a b c and g abbcbbcca then cnp g 2 4 3 and c a 2 deletions and duplications on strings we now describe the two string events of deletion and duplication both are illustrated in figure 1 sequence operations g 1 abbc cab cab del 4 6 g 2 a bbcc ab dup 2 5 6 g 3 abbcca bbcc b figure 1 three strings or toy genomes g 1 g 2 and g 3 from g 1 to g 2 a deletion is applied to g 1 4 6 from g 2 to g 3 a duplication is applied to g 2 2 5 with the copy inserted after position 6 given a genome g a deletion on g takes a substring of g and removes it deletions are denoted by a pair i j of the positions of the substring to remove applying deletion i j to g transforms g into g 1 i 1 g j 1 n a duplication on g takes a substring of g copies it and inserts the copy anywhere in g except inside the copied substring a duplication is defined by a triple i j p where g i j is the string to duplicate and p 0 1 i 1 j n is the position after which we insert inserting after 0 prepends the copied substring to g applying duplication i j p to g transforms g into g 1 p g i j g p 1 n an event is either a deletion or a duplication if g is a genome and e is an event we write g e to denote the genome obtained by applying e on g given a sequence e e 1 ek of events we define g e g e 1 e 2 ek as the genome obtained by successively applying the events of e to g we may also write g e 1 ek instead of g e 1 ek the most natural application of the above events is to compare genomes i definition 1 let g and g be two strings over alphabet the genome to genome distance between g and g denoted dgg g g is the size of the smallest sequence of events e satisfying g e g we also define a distance between a genome g and a cnp c which is the minimum number of events to apply to g to obtain a genome with cnp c 1 note that in the theory of formal languages the cnp of a string is called the parikh vector 4 genomic problems involving copy number profiles i definition 2 let g be a genome and c be a cnp both over alphabet the genome to cnp distance between g and c denoted dgcnp g c is the size of the smallest sequence of events e satisfying cnp g e c the above definition leads to the following problem which was first studied in 12 the minimum copy number generation mcng problem instance a genome g and a cnp c over alphabet task compute dgcnp g c qingge et al proved that the mcng problem is np hard when all the duplications are restricted to be tandem 12 in the next section we prove that this problem is not only np hard but also np hard to approximate within any constant factor 3 hardness of approximation for mcng in this section we show that the dgcnp distance is hard to approximate within any constant factor this result actually holds if only deletions on g are allowed this restriction makes the proof significantly simpler so we first analyze the deletions only case we then extend this result to deletions and duplications both proofs rely on a reduction from set cover recall that in set cover we are given a collection of sets s s 1 s 2 sn over universe u u 1 u 2 um si s si and we are asked to find a set cover of s having minimum cardinality a set cover of s is a subset s s such that s s s u if s is a set cover in which no two sets intersect then s is called an exact cover there is one interesting feature or constraint of our reduction g which transforms a set cover instance s into a mcng instance g s a set cover s only works on g s if s is actually an exact cover and a solution for g s can be turned into a set cover for s that is not necessarily exact thus we are unable to reduce directly from either set cover nor its exact version we provide a general purpose lemma for such situations and our reductions serve as an example of its usefulness the proof relies on a result on t set cover the special case of set cover in which every given set contains at most t elements it is known that for any constant t 3 the t set cover problem is hard to approximate within a factor ln t c ln ln t for some constant c not depending on t 16 i lemma 3 let b be a minimization problem and let g be a function that transforms any set cover instance s into an instance g s of b in polynomial time assume that both the following statements hold any exact cover s of s of cardinality at most k can be transformed in polynomial time into a solution of value at most k for g s any solution of value at most k for g s can be transformed in polynomial time into a set cover of s of cardinality at most k then unless p np there is no constant factor approximation algorithm for b proof suppose for contradiction that b admits a factor b approximation for some constant b choose any constant t such that t set cover is hard to approximate within factor ln t c ln ln t and such that b ln t c ln ln t note that t might be exponentially larger than b but is still a constant now let s be an instance of t set cover over the universe u u 1 um consider the intermediate reduction g that transforms s into another t set cover instance g s lafond zhu and zou 5 s 1 1 2 3 s 2 1 3 4 s 3 2 3 5 g s 1 1 2 3 s 2 1 3 4 s 3 2 3 5 c 1 c 2 1 c 3 2 c 4 c 5 0 figure 2 an example of our construction with s s 1 s 2 s 3 and u 1 2 3 4 5 s s s s since t is a constant g s has o s sets and this can be carried out in polynomial time now define s g s and consider the instance b g s g g s by the assumptions of the lemma a solution for b of value k yields a set cover s for s clearly s can be transformed into a set cover for instance s for each s s there exists s s such that s s so we get a set cover for s by adding this corresponding superset for each s s thus b yields a set cover of s with at most k sets in the other direction consider a set cover s s 1 sk of s with k sets this easily translates into an exact cover of s with k sets by taking the collection s 1 s 2 s 1 s 3 s 1 s 2 sk k 1 i 1 si by the assumptions of the lemma this exact cover can then be transformed into a solution of value at most k for instance b therefore s has a set cover of cardinality at most k if and only if b has a solution of value at most k since there is a correspondence between the solution values of the two problems a factor b approximation for b would provide a factor b ln t c ln ln t approximation for t set cover j 3 1 constructing genomes and cnps from set cover instances all of our hardness results rely on lemma 3 we need to provide a reduction from set cover to mcng and prove that both assumptions of the lemma are satisfied this reduction is the same for deletions only and deletions and duplications given s and u we construct a genome g and a cnp c as follows an example is illustrated in figure 2 the alphabet is s u where s si si s and u ui ui u thus there is one character for each set of s and each element of u here each si is a character that will serve as a separator between characters to delete for a set si s define the string q si as any string that contains each character of u u si exactly once we put g s 1 q s 1 s 2 q s 2 sn q sn i e g is the concatenation of the strings si q si as for the cnp c put c si 1 for each si s c u f u 1 for each u u where f u si s u si is the number of sets from s that contain u notice that in g each s already has the correct copy number whereas each u needs exactly one less copy our goal is thus to reduce the number of each u by 1 this concludes the construction of mcng instances from set cover instances we know focus on the hardness of the deletions only case 6 genomic problems involving copy number profiles 3 2 warmup the deletions only case suppose that we are given a set cover instance s and u and let g and c be the genome and cnp respectively as constructed above i lemma 4 given an exact cover s for s of cardinality k one can obtain a sequence of k deletions transforming g into a genome with cnp c proof denote s si 1 sik consider the sequence of k deletions that deletes the substrings q si 1 q sik i e the sequence first deletes the substring q si 1 then deletes q si 2 and so on until q sik is deleted since si 1 sik is an exact cover this sequence removes exactly one copy of each u u and does not affect the s characters thus the k deletions transform g into a genome with the desired cnp c j i lemma 5 given a sequence of k deletions transforming g into a genome with cnp c one can obtain a set cover for s of cardinality at most k proof suppose that the deletion events e e 1 ek transform g into a genome g with cnp c note that no ei deletion is allowed to delete a set character si s as there is only one occurrence of si in g and c si 1 thus all deletions remove only u characters in other words each ej in e either deletes a substring of g between some si and si 1 with 1 i n or ej deletes a substring after sn moreover exactly one of each u occurrences gets deleted from g call si s affected if there is some event of e that deletes at least one character between si and si 1 with 1 i n and call sn affected if some event of e deletes characters after sn let s si s si is affected then s k since each deletion affects at most one si and there are k deletion events moreover s must be a set cover because each u u has at least one occurrence that gets deleted and thus at least one set containing u that is included in s this concludes the proof j we have shown that all the assumptions required by lemma 3 are satisfied the inapproximability follows i theorem 6 assuming p 6 np there is no polynomial time constant factor approximation algorithm for mcng when only deletions are allowed we mention without proof that the reduction should be adaptable to the duplication only case by putting c u f u 1 for each u u the real deal deletions and duplications we now consider both deletions and duplications the reduction uses the same construction as in section 3 1 thus we assume that we have a set cover instance s over u and a corresponding instance of mcng with genome g and cnp c in that case we observe the following lemma 4 still holds whether we allow deletion only or both deletions and duplications thus we only need to show that the second assumption of lemma 3 holds unfortunately this is not as simple as in the deletions only case the problem is that some duplications may copy some u and si occurrences and we lose control over what gets deleted and over what si each u corresponds to in particular some si might now get deleted which did not occur in the deletions only case nevertheless the analogous result can be shown to hold lafond zhu and zou 7 i lemma 7 given a sequence of k events deletions and duplications transforming g into a genome with cnp c one can obtain a set cover for s of cardinality at most k due to space constraints we redirect the reader to the appendix for the proof in a nutshell given a sequence of events from g to a genome with cnp c the idea is to find for each u u one occurrence of u in g that we have control over more precisely even though that occurrence of u might spawn duplicates all its copies and copies of copies and so on will eventually get deleted the si character preceding this u character indicates that si can be added to a set cover the crux of the proof is to show that this u character exists for each u u and that their corresponding si form a set cover of size at most k we arrive to our main inapproximability result which again follows from lemma 3 i theorem 8 assuming p 6 np there is no polynomial time constant factor approximation algorithm for mcng in the next section we prove that the mcng problem parameterized by the solution size is w 1 hard this answers another open question in 12 we refer readers for more details on fpt and w 1 hardness to the book by downey and fellows 5 4 w 1 hardness for mcng since set cover is w 2 hard naturally we would like to use the ideas from the above reduction to prove the w 2 hardness of mcng however the fact that we use t set cover with constant t in the proof of lemma 3 is crucial and t set cover is in fpt on the other hand the property that is really needed in the instance of this proof and in out mcng reduction is that we can transform any set cover instance into an exact cover we capture this intuition in the following and show that set cover instances that have this property are w 1 hard to solve an instance of set cover with exact cover or set cover ec for short is a pair i s k where k is an integer and s is a collection of sets forming a universe u in this problem we require that s satisfies the property that any set cover for s of size at most k is also an exact cover we are asked whether there exists a set cover for s of size at most k in which case this set cover is also an exact cover therefore set cover ec is a promise problem i lemma 9 the set cover ec problem is w 1 hard for parameter k proof we show w 1 hardness using the techniques introduced by fellows et al which is coined as multicolored clique 6 in the multicolored clique problem we are given a graph g an integer k and a coloring c v g k such that no two vertices of the same color share an edge we are asked whether g contains a clique of k vertices noting that such a clique must have a vertex of each color this problem is w 1 hard w r t k given an instance g k c of multicolored clique we construct an instance i s k of set cover ec we put k k k 2 for i k let vi v v g c v i and for each pair i j k let eij uv e g u vi v vj the universe u of the set cover ec instance has one element for each color i one element for each pair i j of distinct colors and two elements for each edge one for each direction of the edge that is u k k 2 u v v g v g uv e g 8 genomic problems involving copy number profiles u 1 v 1 v 1 u 1 u 1 v 2 v 2 u 1 u 2 v 3 v 3 u 2 su 1 v 1 su 1 v 2 su 2 v 3 su 1 su 2 sv 1 sv 2 sv 3 i j i j figure 3 a graphical example of the constructed sets for the uij elements of a graph not shown with eij u 1 v 1 u 1 v 2 u 2 v 3 where the ul s are in vi and the vl s in vj sets have a gray background edges represent containment the i j lines are dotted only for better visualization thus u k k 2 2 e g for two colors i j k we will denote uij u v v u u vi v vj uv eij i e we include in uij both elements corresponding to each uv eij now for each color class i k and each vertex u vi add to s the set su i u v v n u where n u is the set of neighbors of u in g then for each i j k and for each edge uv eij add to s the set suv i j x y uij x u v the idea is that suv can cover every element of uij except those ordered pairs whose first element is u or v then if we do decide to include suv in a set cover it turns out that we will need to include su and sv to cover these missing ordered pairs see figure 3 for an example for instance if we include su 2 v 3 in a cover the uncovered u 2 v 3 and v 3 u 2 can be covered with su 2 and sv 3 we show that g has a multicolored clique of size k if and only if s admits a set cover of size k note that we have not shown yet that s k is an instance of set cover ec i e that any set cover of size at most k is also an exact cover this will be a later part of the proof first suppose that g has a multi colored clique c v 1 vk where vi vi for each i k consider the collection s sv 1 svk svivj vi vj c 1 i j k the cardinality of s is k k 2 k each element i u k is covered since we include a set svi for each color each element i j u k 2 is covered since we include a set svivj for each color pair i j with i j consider an element xi yj u v g v g where xi vi and yi vj note that either i j or j i is possible and that vivj e g if xi vi vj then svivj covers xi yj if xi vi then svi covers xi vj and if xi vj then svj covers xi vj thus s is a set cover and is of size at most k for the converse direction suppose that s is a set cover for s of size at most k k k 2 note that to cover the elements of u k s must have at least one set su such that u vi for each color class i k moreover to cover the elements of u k 2 s must have at least one set suv such that u vi v vj for each i j k pair we deduce that s has exactly k k 2 sets hence for color i k there is exactly one set su in s for which u vi and for each i j pair there is exactly one suv set in s for which u vi v vj we claim that c u su s is a multi colored clique we already know that c contains one vertex of each color now suppose that some u v c do not share an edge lafond zhu and zou 9 where u vi v vj and i j let sxy be the set of s that covers i j with x vi y vj since uv is not an edge but xy is we know that u 6 x or v 6 y or both moreover sxy does not cover the x y and y x elements of uij and we know that at least one of these is not covered by su nor sv if u 6 x then none covers x y if v 6 y then none covers y x but x y uij and su sv and sxy are the only sets of s that have elements of uij contradicting that s is a set cover this shows that c is a multi colored clique it remains to show that s is an exact cover observe that no two distinct su and sv sets in s can intersect because u and v must be of a different color and no two distinct suv and sxy sets in s can intersect because u v and x y must be from two different color pairs suppose that su sxy s do intersect and say that x vi y vj and i j then all elements in su sxy are of the form u v for some v choose any such u v if u is of color i then u 6 x since otherwise by construction sxy could not contain u v but when u 6 x no set of s covers the element x y it is not su nor sxy the only two possibilities if u is of color j then u 6 y since again sxy could not contain u v in this case no set of s covers y x we reach a contradiction and deduce that s is an exact cover j it is now almost immediate that mcng is w 1 hard with respect to the natural parameter namely the number of events to transform a genome g into a genome with a given profile c proof in appendix i theorem 10 the mcng problem is w 1 hard now that we have finished presenting the negative results on mcng an immediate question is whether we could obtain some positive result on a related problem in the next section we present some positive result for an interesting variation of mcng 5 the copy number profile conforming problem we define the more general copy number profile conforming cnpc problem as follows i definition 11 given two cnp s c 1 u 1 u 2 un and v 2 v 1 v 2 vn the cnpc problem asks to compute two strings s 1 and s 2 with cnp s 1 c 1 and cnp s 2 c 2 such that the distance between s 1 and s 2 d s 1 s 2 is minimized let i ui m 1 i vi m 2 we assume that m 1 and m 2 are bounded by a polynomial of n this assumption is needed as the solution of our algorithm could be of size max m 1 n 2 we simply say c 1 c 2 are polynomially bounded note that d s 1 s 2 is a very general distance measure i e it could be any genome rearrangement distance like reversal transposition and tandem duplication etc or their combinations e g tandem duplication deletion in this paper we use the breakpoint distance and the adjacency number which is defined as follows these definitions are adapted from angibaud et al 1 and jiang et al 7 which generalize the corresponding concepts on permutations 17 given two sequences a a 1 a 2 an and b b 1 b 2 bm if ai ai 1 bj bj 1 we say that aiai 1 and bjbj 1 are matched to each other in a maximum matching of 2 substrings in a and b a matched pair is called an adjacency and an unmatched pair is called a breakpoint in a and b respectively then the number of breakpoints in a resp b is denoted as db a b resp db b a and the number of common adjacencies between a and b is denoted as a a b for example if a acbdcb b abcdabcd then a a b 3 and there are 2 and 4 breakpoints in a and b respectively 10 genomic problems involving copy number profiles coming back to our problem we define d s 1 s 2 db s 1 s 2 db s 2 s 1 from the definitions we have db s 1 s 2 db s 2 s 1 2 a s 1 s 2 m 1 1 m 2 1 or db s 1 s 2 db s 2 s 1 m 1 m 2 2 a s 1 s 2 2 hence the problem is really to maximize a s 1 s 2 i definition 12 given n dimensional vectors u u 1 u 2 un and w w 1 w 2 wn with ui wi 0 and ui wi n we say w is a sub vector of u if wi ui for i 1 n also denote this relation as w u henceforth we simply call u w integer vectors with the understanding that no item in a vector is negative i definition 13 given two n dimensional integer vectors u u 1 u 2 un and v v 1 v 2 vn with ui vi 0 and ui vi n we say w is a common sub vector of u and v if w is a sub vector of u and w is also a sub vector of v i e w u and w v finally w is the maximum common sub vector of u and v if there is no common sub vector w 6 w of u and v which satisfies w w u or w w v an example is illustrated as follows we have u 3 2 1 0 5 v 2 1 3 1 4 w 2 1 0 0 3 and w 2 1 1 0 4 both w and w are common sub vectors for u and v w is not the maximum common sub vector of u and v since w w while w is given a cnp u u 1 u 2 un and alphabet x 1 x 2 xn for i 1 2 we use s u to denote the multiset of letters genes corresponding to u more precisely ui denotes the number of xi s in s u similarly given a multiset of letters z we use s z to denote a string where all the letters in z appear exactly once counting multiplicity i e z s z s z is similarly defined when z is a cnp we present algorithm 1 as follows 1 compute the maximum common sub vector v of c 1 and c 2 2 given the gene alphabet compute s v s c 1 and s c 2 let x s c 1 s v and y s v 2 s v 3 if s v then return two arbitrary strings s c 1 and s c 2 as s 1 and s 2 exit otherwise continue 4 find x y x y and x 6 y such that x s v and y s v and exactly one of x y is in x say x x and the other is in y say y y if such an x y cannot be found then return two strings s 1 and s 2 by concatenating letters in x and y arbitrarily at the ends of s v respectively exit otherwise continue 5 compute an arbitrary sequence s v with the constraint that the first letter is x and the last letter is y then obtain s 1 s v x and s 2 y s v is the concatenation operator 6 finally insert all the elements in x x arbitrarily at the two ends of s 1 to obtain s 1 and insert all the elements in y y arbitrarily at the two ends of s 2 to obtain s 2 7 return s 1 and s 2 let a b c d e also let c 1 2 2 2 4 1 and c 2 4 4 1 1 1 we walk through the algorithm using this input as follows 1 the maximum common sub vector v of c 1 and c 2 is v 2 2 1 1 1 lafond zhu and zou 11 2 compute s v a a b b c d e s c 1 a a b b c c d d d d e and s c 2 a a a a b b b b c d e compute x c d d d and y a a b b 3 identify d and a such that d s v and a s v and d x while a y 4 compute s v dabbcea s 1 dabbcea d and s 2 a dabbcea 5 insert elements in x d c d d arbitrarily at the right end of s 1 to obtain s 1 and insert all the elements in y a a b b at the right end of s 2 to obtain s 2 6 return s 1 dabbcea d cdd and s 2 a dabbcea abb i theorem 14 let c 1 c 2 be polynomially bounded the number of common adjacencies generated by algorithm 1 is optimal with a value either n or n 1 where n n i 1 vi with the maximum common sub vector of c 1 and c 2 being v v 1 v 2 vn proof first note that if v is a 0 vector or s v then there will not be any adjacency in s 1 and s 2 henceforth we discuss s v 6 notice that a common adjacency between s 1 and s 2 must come from two letters which are both in s v that naturally gives us n 1 adjacencies where n s v which can be done by using the letters in s v to form two arbitrary strings s 1 and s 2 for which s v is a common substring if x y can be found such that x y s v and x 6 y and one of them is in x say x x and the other is in y say y y then obviously we could obtain s 1 s v x and s 2 y s v which are substrings of s 1 and s 2 respectively clearly there are n s v adjacencies between s 1 and s 2 and also s 1 and s 2 to see that this is optimal first suppose that no x y pair as above can be found this can only occur when there are no two components i j in c 1 c 1 1 c 1 i c 1 j c 1 n c 2 c 2 1 c 2 i c 2 j c 2 n and in the maximum common sub vector v v 1 vi vj vn of c 1 and c 2 which satisfy that min c 1 i c 2 i vi 6 0 and max c 1 i c 2 i 6 vi and min c 1 j c 2 j vj 6 0 and max c 1 j c 2 j 6 vj if this condition holds then all the components i in s c 1 v and s c 2 v i e c 1 i vi and c 2 i vi have the property that at least one of the two is zero and vi 0 therefore except for the letters corresponding to v no other adjacency can be formed as any string with cnp v has n characters at most n 1 adjacencies can be formed if an x y pair can be found let b and let vb be the minimum copy number of b in c 1 or c 2 i e vb min c 1 b c 2 b assume this minimum occurs in c 1 w l o g there can be at most 2 vb adjacencies involving b in c 1 and thus at most 2 vb adjacencies in common involving vb summing over every b the sum of common adjacencies counted for each character individually is at most b 2 vb 2 n since each adjacency is counted twice in this sum the number of common adjacencies is at most n j note that if we only want the breakpoint distance between s 1 and s 2 then the polynomial boundness condition of c 1 and c 2 can be withdrawn as we can decide whether x y exists by searching directly in the cnps vectors 6 concluding remarks in this paper we answered two recent open questions regarding the computational complexity of the minimum copy number generation problem our technique could be used for other combinatorial optimization problems where the solution involves set cover whose solution must also be an exact cover we also present a polynomial time algorithm for the copy number profile conforming cnpc problem when the distance is the classical breakpoint distance in some sense the breakpoint distance is static and we leave open the question for solving or approximating cnpc with any dynamic rearrangement distance like reversal duplication deletion etc 12 genomic problems involving copy number profiles references 1 sebastien angibaud guillaume fertin irena rusu annelyse thevenin and stephane vialette on the approximability of comparing genomes with duplicates j graph algorithms and applications 13 1 19 53 2009 2 sl cooke j temple s macarthur ma zahra lt tan raf crawford cky ng m jimenez linan e sala and jd brenton intra tumour genetic heterogeneity and poor chemoradiother apy response in cervical cancer british journal of cancer 104 2 361 2011 3 susanna l cooke and james d brenton evolution of platinum resistance in high grade serous ovarian cancer the lancet oncology 12 12 1169 1174 2011 4 prue a cowin joshy george sian fereday elizabeth loehrer peter van loo carleen cullinane dariush etemadmoghadam sarah ftouni laura galletta michael s anglesio et al lrp 1 b deletion in high grade serous ovarian cancers is associated with acquired chemotherapy resistance to liposomal doxorubicin cancer research 72 16 4060 4073 2012 5 rodney downey and michael fellows parameterized complexity springer science business media 2012 6 michael fellows danny hermelin frances rosamond and stephane vialette on the para meterized complexity of multiple interval graph problems theoretical computer science 410 1 53 61 2009 7 haitao jiang chunfang zheng david sankodd and binhai zhu scaffold filling under the breakpoint and related distances ieee acm trans bioinformatics and comput biology 9 4 1220 1229 2012 8 carlo c maley patricia c galipeau jennifer c finley v jon wongsurawat xiaohong li carissa a sanchez thomas g paulson patricia l blount rosa ana risques peter s rabinovitch et al genetic clonal diversity predicts progression to esophageal adenocarcinoma nature genetics 38 4 468 2006 9 andriy marusyk vanessa almendro and kornelia polyak intra tumour heterogeneity a looking glass for cancer nature reviews cancer 12 5 323 2012 10 nicholas navin alexander krasnitz linda rodgers kerry cook jennifer meth jude kendall michael riggs yvonne eberling jennifer troge vladimir grubor et al inferring tumor progression from genomic heterogeneity genome research 20 1 68 80 2010 11 cancer genome atlas research network et al integrated genomic analyses of ovarian carcinoma nature 474 7353 609 2011 12 letu qingge xiaozhou he zhihui liu and binhai zhu on the minimum copy number generation problem in cancer genomics in proceedings of acm bcb 2018 pages 260 269 acm 2018 13 roland f schwarz anne trinh botond sipos james d brenton nick goldman and florian markowetz phylogenetic quantification of intra tumour heterogeneity plos computational biology 10 4 e 1003535 2014 14 sohrab p shah ryan d morin jaswinder khattra leah prentice trevor pugh angela burleigh allen delaney karen gelmon ryan guliany janine senz et al mutational evolution in a lobular breast tumour profiled at single nucleotide resolution nature 461 7265 809 2009 15 ron shamir meirav zehavi and ron zeira a linear time algorithm for the copy number transformation problem in proceedings of cpm 2016 lipics volume 54 pages 16 1 16 13 schloss dagstuhl leibniz zentrum fuer informatik 2016 16 luca trevisan non approximability results for optimization problems on bounded degree instances in proceedings of 33 rd acm symp on theory of comput stoc 01 pages 453 461 acm 2001 17 g a watterson w j ewens t e hall and a morgan the chromosome inversion problem j theoretical biology 99 1 1 7 1982 lafond zhu and zou 13 appendix proof of lemma 7 we need some new notation and intermediate results before proving the lemma let e e 1 ek be a sequence of events transforming genome g into another genome g we would like to distinguish each position of g in order to know which specific character of g is at the origin of a character of g to that end we augment each individual character of g with a unique identifier which is its position in g that is let g g 1 g 2 gn define a new alphabet g 11 g 22 gnn and define the genome g g 11 g 22 gnn here two characters gi and gj may be identical but gii and gjj are two distinct characters we call the augmented alphabet and g the augmented genome of g for instance if g aabcb and a b c then a 1 a 2 b 3 c 4 b 5 and g a 1 a 2 b 3 c 4 b 5 since g and g have the same length we may apply the sequence e on g resulting in a genome g g e on alphabet now g may contain some characters of multiple times owing to duplications but if we remove the superscript identifier from the characters of g we obtain g the idea is that the identifiers on the characters of g tell us precisely where each character of g comes from in g and thus g i definition 15 let g and g be genomes and let e an event sequence such that g g e let g be the augmented genome of g and let g i gi be the character at position i if there is at least one occurrence of gi in g e then position i is called important with respect to e otherwise position i is called unimportant with respect to e roughly speaking position i is unimportant if it eventually gets deleted and any character that was copied from position i from a duplication also gets deleted as well as a copy of this copy and so on in other words position i has no descendant in g when applying e first we prove some general properties that will be useful recall that g s removes all occurrences of s from g and c s puts c s 0 i proposition 16 let g be a genome over alphabet let c be a cnp and let s then dgcnp g s c s dgcnp g c proof let e e 1 ek be any optimal sequence of events changing g into a genome g satisfying cnp g c it is straightforward to see that e can be adapted to a sequence e e 1 e k that transforms g s into g s it suffices to ensure that each e i affects the same characters as ei with the exception of the s characters we omit the details thus dgcnp g s c s k dgcnp g c j i proposition 17 let g and g be two genomes with dgg g g k and let e be a sequence of k events transforming g into g suppose that position p is unimportant w r t e and let g be the genome obtained from g by replacing g p by any other character then dgg g g dgg g g proof let g g p let h g and suppose that g is identical to g except that g p h let g be the augmented g with g p gp moreover let g be the augmented g so that g p hp then the only difference between g e and g e is that the occurrences of gp in g e are replaced by hp in g e but since p is unimportant g e has no occurrence of gp meaning that g e g e thus by removing the superscript identifiers from either g or g we obtain g implying that g e g it follows that dgg g g dgg g g j 14 genomic problems involving copy number profiles the next technical lemma states that if a genome alternates between positions to keep and positions to delete n times then we need n events to remove the unimportant ones i lemma 18 let x y be an alphabet defined by two disjoint sets x x 1 xn and y let g y 0 x 1 y 1 x 2 y 2 xnyn be a genome on where for all i n yi is a non empty string over alphabet y and y 0 is a possibly empty string on alphabet y moreover let c be a cnp such that c xi 1 for all xi x and c y 0 for all y y then dgcnp g c n with equality when y 0 is empty proof it is easy to see that d g c n when y 0 is empty since one can delete every yi substring one by one thus we only need to show that dgcnp g c n whether y 0 is empty or not which we prove by induction over n when n 1 this is obvious as we need to at least delete the y 1 segment for n 1 take any sequence of events e e 1 ek that transforms g into a genome g with cnp g c and let g g e 1 if e 1 is a deletion then e 1 cannot have deleted an xi character because there would be 0 left whereas c xi 1 and we cannot create new copies of xi once its number of occurrences is 0 thus e 1 could only delete some or all characters from a single yi substring i 0 n let y i be the possibly empty substring that remains from yi after the e 1 deletion note that if i 0 then y i is preceded by the xi x character define x xi if i 0 and x x 1 if i 0 consider the genome g x it has the form y 0 x 1 y 1 yi 1 y i xi 1 yi 1 xnyn if i 0 and the form y 0 y 1 x 2 y 2 xnyn if i 0 in either case the xi s and y substring alternate n 1 times and we may use induction on g x to deduce that dgcnp g x c x n 1 moreover by proposition 16 dgcnp g x c x dgcnp g c thus dgcnp g c dgcnp g c 1 n 1 1 n as desired so suppose that e 1 is a duplication in g each occurrence of an xi x character is followed by a y character except at most possibly one in other words after a duplication there can be at most one position p such that both g p and g p 1 are in x which happens when we insert a duplicated substring between some xi and yi or when we insert a duplicated substring between some yi and xi 1 if it is the case that g p and g p 1 are in x then put xi g p if no such position p exists then choose xi x arbitrarily now consider the string g xi in g xi each x character is preceded and followed by a y substring possibly with the exception of x 1 which might have no preceding character by proposition 16 we know that dgcnp g xi c xi dgcnp g c we cannot use induction on g xi yet as it is possible that some character in x xi has two occurrences in g xi owing to the e 1 duplication and thus we do not have the form required for induction suppose that xj x x 1 does have two occurrences in g xi let e be an optimal sequence of events turning g xi into a genome g with copy number profile c xi since c xj 1 only one position of g xi containing character xj is important w r t e so take the unimportant position of g xi having character xj and replace it by any character from y yielding another genome g by proposition 17 dgcnp g c xi dgcnp g xi c xi we repeat this for every xj x xi having two occurrences and call the resulting genome g we note that dgcnp g c xi dgcnp g xi c xi after relabeling if needed g has the form y 0 x 1 y 1 x 2 y 2 xn 1 yn 1 using induction we know that n 1 dgcnp g c xi dgcnp g xi c xi dgcnp g c the lemma then follows from the fact that dgcnp g c dgcnp g c 1 j this allows us to prove the required assumption lafond zhu and zou 15 i lemma 7 given a sequence of k events deletions and duplications transforming g into a genome with cnp c one can obtain a set cover for s of cardinality at most k proof suppose that the events e e 1 ek transform g into a genome g with cnp c we construct a set cover for s of cardinality k for a position p with g p u u define pred p as the first s character to the left of position p to be precise if p is the largest integer satisfying g p s and p p then pred p g p note that since g 1 s 1 pred p is well defined notice that by construction if g p u and s pred p then u s the set of pred p of unimportant positions p will correspond to our set cover which we now prove by separate claims b claim 1 for each u u there is at least one position p of g such that g p u and such that p is unimportant w r t e proof if we assume this is not the case then each of the f u positions p of g having g p u has a descendant in g implying that g has at least f u copies of u and thereby contradicting that g complies with c u f u 1 j given that the claim holds let p p 1 pm be any set of positions of g such that for each i m g pi ui and pi is unimportant w r t e choosing arbitrarily if there are multiple choices for pi define p pred pi pi p and s si s si p b claim 2 s is a set cover proof for each ui u there is an unimportant position pi p such that g pi ui moreover pred pi is some character s such that s p and such that ui s since s s it follows that each ui is covered j it remains to show that s has at most k sets denote p p p g p p let g be the subsequence of g obtained by keeping only the positions in p i e if we denote p p 1 p l with p 1 p 2 p l then g g p 1 g p 2 g p l furthermore define the cnp c such that c si 1 for all si p c si 0 for all si s p and c u 0 for all u u note that g has the form s 1 d 1 s 2 d 2 sr dr for some r where the di s are substrings over alphabet u this is the same form as in lemma 18 b claim 3 dgcnp g c k proof let g be the genome obtained by replacing every position p of g by some dummy character except for the positions of p thus if we remove all the occurrences we obtain g since g and g have the same length we can apply the e events on g let g g e and let l be the number of occurrences of in g recall that p contains only positions p such that g p p or such that p is unimportant w r t e and g p u it follows that if a position q is important w r t e then g q p moreover for any s p g has as many occurrences of s as in g e in other words g has one occurrence of each s p and the rest is filled with let c be the cnp satisfying c l c si c si 1 for every si p and c x 0 for any other character x then clearly c cnp g which implies dgcnp g c k since e transforms g into g moreover by proposition 16 dgcnp g c dgcnp g c k the claim follows from the observation that g g and c c j 16 genomic problems involving copy number profiles observe that g and c have the required form for lemma 18 with p important positions and so dgcnp g c p it follows from claim 3 that k dgcnp g c p s we have thus constructed a set cover s for s of cardinality at most k which completes the proof j proof of theorem 10 let s k be a set cover ec instance construct a genome g and copy number vector c from s as described in section 3 1 we show that s admits a set cover of size k if and only if dgcnp g c k if s admits a set cover s of size k then s is also an exact cover and by lemma 4 one can apply k deletions on g to obtain the desired vector c conversely lemma 5 a sequence of k events for g c show that s has a set cover of size at most k 1 introduction 2 preliminaries 3 hardness of approximation for mcng 3 1 constructing genomes and cnps from set cover instances 3 2 warmup the deletions only case 4 w 1 hardness for mcng 5 the copy number profile conforming problem 6 concluding remarks