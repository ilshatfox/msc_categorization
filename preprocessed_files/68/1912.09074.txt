abcde agile block chain dapp engineering lodovica marchesi michele marchesi roberto tonelli dmi university of cagliari abstract cryptocurrencies and their foundation technology the blockchain are reshaping finance and economics allowing a decentralized approach enabling trusted applications with no trusted counterpart more recently the blockchain and the programs running on it called smart contracts are also finding more and more applications in all fields requiring trust and sound certifications some people have come to the point of saying that the blockchain revolution can be compared to that of the internet and the web in their early days as a result all software development revolving around the blockchain technology is growing at a staggering rate the feeling of many software engineers about such huge interest in blockchain technologies is that of unruled and hurried software development a sort of competition on a first come first served basis which does not assure neither software quality nor that the basic concepts of software engineering are taken into account this paper tries to cope with this issue proposing a software development process to gather the requirement analyze design develop test and deploy blockchain applications the process is based on several agile practices such as user stories and iterative and incremental development based on them however it makes also use of more formal notations such as some uml diagrams describing the design of the system with additions to represent specific concepts found in blockchain development the method is described in good detail and an example is given to show how it works keywords blockchain smart contracts blockchain oriented software engineering uml dapp design 1 introduction the so called decentralized applications or dapps are one of the main new trends of software development dapps typically run on a blockchain the technology originally introduced to manage the bitcoin digital currency 1 blockchain software runs in a network of peer to peer nodes so it is naturally decentralized redundant and transparent a few years after the introduction of bitcoin in 2009 developers and managers realized that a blockchain can be also the ideal environment for a decentralized computer this led to the introduction of ethereum blockchain a network whose nodes are also able to run turing complete programs 2 called smart contracts scs following and idea of nick szabo 3 scs are general computer programs though with some specific features the main idea behind them is that they can be used for the automated enforcement of contractual obligations without having to trust a central authority and without space and time constraints so there is a huge wave of interest in scs and applications of the blockchain especially in the financial realm some authors even said that we should think about the blockchain as another class of thing like the internet 4 and that the wide adoption of blockchain technology has the potential of reshaping the current financial services technical infrastructure 5 this interest led to a huge amount of money flooding into blockchain ventures during 2017 this steady inflow of money paired with the limited amount of available digital money a feature that most digital currencies have by design made the price of bitcoin and other digital currencies spike at the end of the year this peak was mainly ignited by the initial coin offers ico phenomenon where a startup publishes a white paper describing their idea and gathers digital money by issuing a token which is a second level digital currency managed by a sc 6 this email address lodo marchesi gmail com marchesi unica it roberto tonelli dsf unica it lodovica marchesi michele marchesi roberto tonelli preprint submitted to a software engineering journal december 20 2019 ar x iv 1 91 2 09 07 4 v 1 cs s e 1 9 d ec 2 01 9 token can then be immediately traded on an exchange a pseudo bank running on the web which allows to exchange digital currencies against traditional money or against other digital currencies the enthusiasm for this new idea the ever increasing prices and profits and the fear of missing out fomo led to many billions usd pouring into tokens at the beginning of 2018 the bubble deflated with the global capitalization of digital currencies going from more than 800 billion usd on january 7 2018 to about 115 billion usd on february 2019 during 2019 however a renewed interest to digital currencies lead their global market cap back to about 200 billion usd as of september huge inflows of money and venture capital were also poured into blockchain initiatives not linked to digital currencies these are the so called permissioned blockchains or distributed ledgers dl intended to be run by a set of nodes chosen by invitation all the initiatives behind blockchain technology new digital currencies with their own blockchain exchanges and other web based ventures using digital money ico startups applications running on permissioned blockchains or dls are based on developing a new software system this often led to a run to be the first on the market as always happens with new technology waves with quick application development neglecting good development practices and often even basic testing and security assessment some big disasters quickly followed with a total of literally billions of usd at least at the nominal exchange rate of digital currencies stolen or lost several exchanges were hacked since the beginning of bitcoin trading for a total of various billion equivalent usd for a list up to 2017 see 7 also scs were often exploited taking advantage of their novelty and of the hurried software development 8 9 overall the scenario looks that of a competition on a first come first served basis where the basic principles and practices of software engineering se are not taken into account the quality of the resulting software is accordingly compromised it is well known that to develop a reliable and maintainable software system one needs to follow an explicit development process and use sound se practices among the latters in the context of blockchain development we stress the importance of requirement elicitation system design specific notations and security assessment in essence we need blockchain oriented software engineering bose 10 in this paper we present a development process for applications based on smart contracts running on a blockchain which are usually called dapps decentralized applications the process covers all the standard phases of software life cycle requirement elicitation design implementation security assessment and testing and ongoing maintenance we call the process abcde agile block chain dapp engineering abcde is an agile software development process meaning that is follows the principles of agile manifesto 11 however we had to complement the agile process with a more formal approach using uml diagrams with a specific notation for scs and a specific checklist for security assessment the first question we had to answer regarding abcde is why a new process why not use an existing process waterfall or agile for dapp development the answer to this question stems from the observation that a sc is very peculiar software it runs on all the nodes hosting a blockchain and its execution has the strong constraint that all outputs and state changes resulting from sc execution must be the same in all nodes consequently a sc is strictly forbidden to access the external word it can answer to external messages belonging to its public interface and can send messages to other scs running on the same blockchain no other kind of interaction with the external world is allowed this fact implies that any dapp is intrinsically divided in two subsystems the scs running on a blockchain and the applications allowing users and devices to interact with the scs another specificity of sc realm is the need to introduce new concepts with respect to traditional programming like those of address to refer to scs of signed transaction to send a message starting from a given address of gas needed to run a sc of digital money owned by and transferred between scs of oracle a sc able to provide data coming from the external world without violating the constraint described above moreover referring to solidity the programming language of ethereum which is presently the most used blockchain actually running scs there are further specific concepts such as those of modifier a boolean function acting as a guard to the execution of another function of library contract and there are constraints on the use of typical structures of object oriented programming languages for instance inheritance is limited and the available collections are just arrays and mappings finally two papers by chakraborty bosu et al 12 13 present the results of a survey among blockchain developers they found that the prevalent opinion is that blockchain development is different from traditional one due to the strict and non conventional security and reliability requirements and to other unique characteristics of the dapp development domain such as immutability difficulty in upgrading the software and so on more information on this survey is presented in sec 3 2 this specificity led us to conclude that a new method is needed for dapp development in fact abcde is not entirely new but it is a significant extension to classical agile methods such as scrum 14 with respect to scrum abcde does not only describe how the development should be managed but also introduces specific practices such as the use of modified uml diagrams to describe scs and checklists for security assessment other agile practices such as simplicity test driven development 15 refactoring 16 collective code ownership pair programming are encouraged if the team feels they are useful but are not prescribed by abcde the main characteristic of abcde is the split of dapp development in two flows which are carried on concur rently after a common start the first flow is the specification and development of the scs the second flow is about the development of the software applications which allow external actors to interact with the scs in this paper we also introduce a notation augmenting some uml diagrams use case sequence and class diagrams to account for sc specificity in the context of solidity language the dapp design when other languages to develop scs are used can be represented with different uml extensions in this paper we limit ourselves to solidity the proposed abcde methods has been tested on some real dapp development projects carried on at our de partment and at some firms we are consultant of the remainder of this paper is organized as follows in section 2 we describe the architecture of a dapp and introduce the specific issues and practices needed for dapp development in section 3 we present the related work in the same or similar fields section 4 describes the proposed abcde process in every detail including the mod ifications of some uml diagrams to cope with solidity concepts security assessment and what is needed to extend the notation to other languages for sc development a simplified example drawn from a real case is presented in section 5 together with reporting on actual uses of abcde finally section 6 presents the conclusions and future work ideas 2 background 2 1 decentralized applications we define as dapp decentralized application a software system that uses distributed ledger technology dlt typically a blockchain 1 as a central hub to store and exchange information through smart contracts scs note that it is not a blockchain software able to manage a new cryptocurrency or other applications that is software enabling blockchain nodes which needs different kinds of of development practices not the subject of this work a blockchain is a distributed data structure managed by a set of connected nodes characterized by the following elements it is redundant each node holds a copy of the blockchain it is append only once written the information cannot be changed or deleted the blockchain state is changed by sending transactions to the network in public blockchains everyone can send a transaction all transactions are checked by the reached nodes invalid ones are ignored the valid transactions are typically recorded in sequentially ordered blocks hence the name blockchain whose creation is managed by a consensus algorithm among the nodes all transactions are sent from an unique address which is in turn computed from a public key only the owner of the private key associated with it can sign the transactions coming from this address using asymmetric cryptography validating them if the blockchain is able to execute scs a transaction can create a sc or execute one of its public functions in this case the function is executed by all nodes when the transaction is evaluated the execution of the program is the execution of the transaction 1 from now on we ll use the terms dlt and blockchain interchangeably 3 a dapp is usually composed of scs deployed on a blockchain and of software able to create and send transac tions to them this software usually provides a user interface running on a pc or on a mobile device additional information could be stored on a server and further business logic could be executed on this most present real applications of dapps and scs are intended for the management of digital currencies or tokens that have a true monetary value the use of dapps has been introduced also for other scopes like notarization of information identity management voting games and betting goods provenance certification and many others 17 figure 1 the ethereum blockchain running a sc the same sc bytecode is executed by each node in this paper we will use as a reference ethereum whose scs were the first to exhibit a turing complete capability and is presently the most used blockchain to develop scs 18 just to quote some figures as of october 1 2019 there were 1533 out of 1720 active tokens 2 managed by ethereum scs worth more than 8 billion usd at current prices 19 moreover as of november 2019 2654 dapps were running on ethereum out of a total of 3169 surveyed dapps 20 these figures are about public blockchains data on dapps running on permissioned blockchains are more difficult to find but ethereum is very popular also for this kind of dapps open source dlts such as hyperledger and corda are also widely used the ethereum virtual machine evm able to execute sc ethereum bytecode runs on all nodes of the ethereum blockchain 21 in practice the scs are written in high level languages hll nowadays the most popular hll for ethereum is called solidity other languages such as flint and vyper can be used but their adoption is still far behind solidity fig 1 shows a sketch of the ethereum blockchain with the architecture of its nodes running a sc the original ethereum software running the node is written in c or go language a compatible implementation written in rust language parity is also available 2 we define as active a token whose market cap is over 100 000 usd 4 as written in the introduction scs run in an isolated environment the results of their execution must be the same whatever node they run in consequently they cannot get information from the external world which mutates with time and cannot initiate a computation autonomously for instance at given times scs can only access and change their state and send messages to other scs the state of a sc is permanently stored in the blockchain using storage variables another sc specificity is their immutability once a sc is deployed it is in the blockchain forever it cannot be modified or erased though it can be forever disabled scs are created by special transactions creating a sc and changing its state costs units of gas which must be paid in ether the digital currency of the ethereum blockchain each sc has a unique ethereum address that is used to send messages to it in solidity a sc can inherit from other scs it has a public interface that is a set of functions that can be called through a transaction the call of a public function of a sc is called a message sending a message to a sc can be performed either by posting a transaction coming from an address or by executing code of the same or of another sc in the former case the transaction must be accepted by the network and it will take time and a bigger amount of gas in the latter case the execution is immediate and the cost is lower a sc can receive and send ethers from and to another sc or an address a function belonging to a sc can change its state can call functions belonging to other scs including itself and can create and send a transaction to an address or to another sc in the latter case the transaction is executed immediately a function which returns a value without changing the state of its sc or sending a transaction is executed immediately by the evm and costs nothing this kind of function is said of type view figure 2 a typical architecture of an ethereum dapp application the app system is shown on the right the blockchain with its scs on the left a typical dapp architecture is shown in fig 2 it is composed of a software system running on mobile devices and or on servers possibly on the cloud exchanging information with users and external devices which we call app system its user interface ui typically runs on a web browser it can have a server component to store data that cannot be stored in the blockchain and to perform business computations in ethereum the app system typically communicates with the blockchain using the web 3 js javascript library which manages the creation and dispatch of transactions the other component are the scs running on the blockchain in a not trivial system it is composed of various scs deployed on the blockhain and identified by their ethereum address 5 2 2 agility and dapp development nowadays the developments of dapps worldwide share some common characteristics several teams involved are typically working on ico projects which gathered money through tokens and are about applications of blockchain technology other projects are promoted by startups trying to take advantage of the novelty of dapps to develop disruptive solutions or to get a niche where to thrive in both cases they are typically small self organizing co located teams where experts of system requirements are highly available other characteristics of dapp development is that dapps typically are not life critical applications though some of them can be mission critical however the time to market and the ability to get an early feedback from the users and the stakeholders are essential though often the requirements of the dapp initially are only vaguely defined and are subject to change all these features make dapp development an ideal candidate for tha use of agile methods ams in fact ams are suited for small self organizing teams possibly co located working on projects whose requirements can change 11 ams are considered to be able to deliver quickly and often as needed by dapp projects the most used am is presently scrum which is iterative and incremental with short iterations 1 4 weeks 14 scrum does not prescribe specific software development practices but is focused on the process in short scrum as most other ams typically performs requirement elicitation through user stories uss that are short descriptions of how the system answers to inputs from users or from external devices 22 uss are mostly gathered at the beginning of the development but can be modified and augmented at any time the project advances iteratively implementing a subset of the uss at each iteration the person in charge of choosing this subset and explaining their uss to the team is the product owner other agile practices that are well suited to dapp development and that can be used in the proposed process if the team chooses them are test driven design this practice prescribes writing the tests before the code 23 using an automated test suite that can be run whenever needed for the app system this is the preferred technique because it guarantees that the unit tests are always present and their development is not indefinitely postponed if the team is under pressure for scs written in solidity at the moment the most popular testing environment is truffle 24 continuous integration the practice of merging all developer working copies to a shared mainline even several times a day developing dapps this practice is critical and it should be practiced both on the app system and the scs checking at each merging also how the two systems interact through transactions this practice requires a development environment provided of a working test blockchain possibly simulated to deploy scs and to test all interactions collective code ownership this practice allows every developer to intervene on whatever code s he considers appropriate to modify with small dynamic teams as typically happens with dapp development this practice should clearly be applied however often the team members expert in sc development differ from those expert in app system so their spheres of influence remain separate refactoring this is the attitude to intervene on the code whenever and wherever it can be improved improving its design without introducing new features this practice needs to have an automated test suite that can be run when the refactoring is made to assess the absence of unwanted side effects this is especially needed with the complex architecture of dapps whose components interacts through transactions information radiators cards boards burndown charts making visible the status of a project using boards that can be observed by everyone and updated in real time is an practice that is common to all agile projects and that can obviously greatly benefit also dapp development coding standards the practice of strictly following the same coding standard throughout the code with proper differentiation between app system code and scs should be applied to all projects developed following sound se practices however the dynamicity of the teams and the push to quickly develop applications make neces sary that the project manager or the scrum master ensures that this practice is strictly followed 6 pair programming pp this practice is strictly enforced in pure extreme programming teams 25 in our approach we suggest to use pp in the case the software to be developed is critical is not yet well understood or there are new team members to train on the job 2 3 security assessment in the previous section we made the case for using agile practices for developing dapps however many dapps deal with direct digital currency or token usage that is with entities that have a direct real monetary value in other cases they may deal with contractual issues again with strong economic implications as in the case of document certification supply chain management voting systems therefore in most cases dapps are business critical and very strict security requirements should be assured code inspection security patterns and thorough tests must be applied to get a reasonable security level abcde proposed security assessment will be described in detail in section 4 3 3 related work se for dapp development sometime called blockchain oriented software engineering bose is still in its in fancy the first call for bose was made in 2017 by porru et al they highligh the need for new professional roles enhanced security and reliability novel modeling languages and specialized metrics and propose new direc tions for blockchain oriented software engineering focusing on collaboration among large teams testing activities and specialized tools for the creation of smart contracts 10 they also suggest the adaptation of existing design notations such as uml the unified modelling language 26 to unambiguously specify and document dapps the book by xu et al is perhaps the most complete overview of the engineering aspects of blockchains to date 27 among others it deals with some se issues such as the evaluation of the suitability to use a dapp or not the selection and configuration of the proper blockchain solution public permissioned private a collection of patterns for the design of blockchain based applications and even model driven generation of sc code some of the topics of the book were introduced previously in 28 wessling et al propose a method to find how the architecture of an application could benefit from blockchain technology they identify the actors involved and how they trust each others to derive a high level hybrid architecture of a blockchain based application 29 fridgen et al propose an approach for eliciting use cases in the context of blockchain applications applying action design research method their method is evaluated in four distinct case studies regarding banking insurance automotive and construction 30 jurgelaitis et al propose a method based on model driven architecture which could be used for describing blockchain based systems using a general language in order to facilitate blockchain development process 31 a paper by beller and hejderup 32 is worth mentioning though it does not really advocate to use se practices to develop blockchain applications instead it is about how blockchain technology could solve two core se prob lems continuous integration ci services such as travis ci and package managers such as apt get the use of scs to manage agile development including the automated compensation of developers when their software passes acceptance tests was also proposed by lenarduzzi et al 33 34 chakraborty et al using an online survey got answers from 156 active blockchain software bcs developers finding that standard software engineering methods including testing and security best practices need to be adapted with more seriousness to address unique characteristics of blockchain and mitigate potential threats 12 the same authors published an extended version of the same research further highlighting that there is a need for an array of new or improved tools such as customized ide for bcs development tasks debuggers for smart contracts testing support easily deployable simulators and bcs domain specific design notations 13 they found that most bcs developers feel that bcs development is different from traditional one due to the strict and non conventional security and reliability requirements and to other unique characteristics of the dapp development domain e g immutability difficulty in upgrading the software operations on a complex secured distributed and decentralized network as anticipated in the introduction these findings confirm the expedience to devise a software engineering process such as abcde for bcs development 7 regarding dapp security many publicly available documents and scientific papers have been already published among the most recent ones the survey of praitheeshan et al analyzes the literature about ethereum sc secu rity summarizing the main security attacks against scs their key vulnerabilities the security analysis methods and tools 35 they classify analysis methods in static analysis dynamic analysis and formal verification and discuss the relative pros and cons of these classes also providing a large bibliography with 160 references huang et al deal with sc security in a broader way considering also hyperledger security and performing a survey from a software lifecycle perspective 36 after a classification of security issues in scs both in ethereum and hyperledger fabric they consider the securities activities according to the various phases of dapp development design implementation testing before deployment and runtime monitoring quoting several references and giving practical advice these two papers together include references to virtually all the work which have been published about sc security to date various papers have been published to suggest upgrades of unified modeling language 26 notation to enable it to better represent specific application fields baumeister et al described an extension of uml for hypermedia design through the addition of a new navigational structure model and new stereotypes 37 baresi et al extend and customize uml with web design concepts borrowed from the hypermedia design model hypermedia elements are described through appropriate uml stereotypes 38 rocha and ducasse 39 study sc design and compare three complementary software engineering models entity relationship diagrams uml and bpmn to better represent sc concepts they propose a simple addition to uml class diagrams that is a small chain icon in the uml class representing a contract as a notation to more easily identify it as a blockchain artifact 4 proposed method for dapp development 4 1 overall process our approach abcde takes into account the substantial difference between developing traditional software the app system and developing scs and separates the two activities for both developments abcde takes advantage of on an agile approach because agile methods are suited to develop systems whose requirements are not completely understood since the beginning or tend to change as it is the case of dapps however a more formal approach with respect to agile development is also added to address the security and maintenance issues which are very important in dapp development the steps of the proposed abcde design method which is currently focused on ethereum blockchain and solidity language are shown in fig 3 as uml activity diagram note that most steps are in fact performed many times because the approach is iterative and incremental in deeper detail the proposed development process is the following 1 goal of the system write 10 30 words summing up the goal and display them in a place that is visible to the whole team this is a practice that as far as we know was introduced by coad and yourdon in their 1991 book on object oriented analysis 40 and that we always found useful it has some similarities with the sprint goal that scrum method prescribes to find and make visible to the team at the beginning of each iteration 14 but here the goal is found for the whole system 2 find the actors identify the actors who will interact with the dapp system the actors are human roles and external systems or devices that exchange information with the dapp to build 3 user stories the system requirements are expressed as user stories uss 22 to be able to follow the classical agile approach for project management used in extreme programming 25 and scrum 14 in this step the dapp system under development should be considered in full the decision to develop it using a blockchain a set of servers possibly in the cloud or another architecture is not important at this point we found useful though not mandatory to use a uml use case diagram to graphically show the relationships among the actors and the uss if the decision is taken to implement the system using a blockchain and related scs the following steps are taken 4 divide the system in two subsystems 4 1 the scs running on the blockchain 4 2 the app system that is the external system that interacts with the blockchain creating and sending transactions and monitoring the events that may happen when a sc executes a function 8 figure 3 the proposed abcde process shown as a uml activity diagram 5 design of the scs this step is about designing the scs using in our case the solidity language this activity has very peculiar characteristics with respect to standard software design as highlighted by 12 the activity is not performed in a single step for the whole sc system but is performed through iterations that include coding and delivering increments of scs which are the uss chosen for each iteration its sub steps are the following 5 1 replay steps 2 and 3 finding actors and uss by focusing only on actors directly interacting with the scs if external scs are used by the scs of the system under development they should be included among the actors for each us defined in this step define also the related acceptance test s 5 2 define broadly the scs composing the sc subsystem stating their responsibilities to store information and the messages they should respond to for non trivial systems you will typically need various interact ing scs consider also the use of inheritance for abstracting common features of scs describe in detail the interfaces of the libraries and of the external scs used uml class diagrams with proper additions will be used as shown later in sec 4 2 5 3 define the flow of messages and ether transfers among scs external scs and the app system use uml sequence diagrams to document these interactions if they are non trivial if needed define the state changes of scs using uml statecharts 5 4 define in detail the data structure of the scs their external interface application binary interface abi and the relevant events that can be raised by the functions of the sc 9 5 5 define the internal private functions and the modifiers special functions that are executed before the functions that apply them and that usually test the preconditions needed before the function can be safely executed 5 6 define the tests and perform the security assessment practices this is a very important step because as already explained above most scs are very critical and deal with money section 4 3 in the followings describes in deeper detail the security assessment we use for ethereum scs 6 coding and testing the sc system following the agile approach the sc system is built and tested incremen tally we advocate following a scrum approach 14 because it is very effective and popular among developers in scrum a subset of uss are implemented at each iteration however also a lean kanban approach is feasi ble implementing the uss in a continuous flow with the work in progress controlled by the kanban board 41 the coding and testing activities are 6 1 incrementally write and test the scs with an agile approach scrum or kanban owing to the strict security requirements typically this activity cannot be performed in a strict incremental way just imple menting one us after another instead starting from the data structure and interfaces of scs the overall kernel sc architecture is implemented and tested first this can be accomplished by using special user stories which are not the description of the interaction with users but are about the implementation of the architecture of the system then complementary uss can be added 6 2 perform the security assessment of the code written for the increment see section 5 6 3 write automated unit tests uts and acceptance tests ats for the scs and uss implemented respec tively add the new tests to the test suite the most used testing environments for solidity is truffle 24 run the whole test suite to make sure that the additions did not break the system 7 design of the external interaction subsystem app system this step is about designing the app system which interacts with the users and devices send messages to the blockchain and can manage its own repositories data bases and or documents this activity is very similar to designing a standard web application it just adds another actor the blockchain which can receive but cannot send messages and queries note that also in this case we must be very careful about security aspects in fact often the hacks of dapps systems are made exploiting app system weaknesses rather that scs ones 7 1 redefine the actors and the uss for the app system starting from those gathered in steps 2 and 3 adding the new actors represented by the scs that interact with the app system define the acceptance tests of the app system 7 2 design the high level architecture of the app system including server and client tiers and detail the way it accesses the blockchain the access can be done setting up and running one or more nodes of the blockchain through an external provider or using a standard wallet 7 3 define the ui of the app system typically with a responsive approach so that it can run on both mobile terminals and pcs having a fancy ui is of paramount importance to achieve the market success of the whole system we suggest to perform ui design using well known standard approaches such as usage centered design 42 and interaction design 43 7 4 define how the app system is decomposed in modules their interfaces and the flow of messages between them define if needed the state diagrams of the modules and the actions they take when events are raised by scs define the structure and memorization of permanent data select which data are anchored to the blockchain by notarization of their hash digest define the structure of the data or classes of the app system including the flow of data and control between modules the interactions with the scs must be consistent with the analysis of step 5 3 since we use and agile approach this design activity is not performed up front but through iterations that include coding and delivering increments of the app system that is implementation of the uss chosen for the iteration as the app system is created the need of additions or updates to the architecture may arise due to the above quoted security requirements this design phase must be quite detailed and made consistently with the corresponding activities of scs design uml class and sequence diagrams can help to design and document this system 7 5 perform a security assessment of the external system as described below in sec 4 3 8 coding and testing the app system in parallel to the scs system the app system is built and tested also in this case we advocate following a scrum approach alternatively the team may chose a lean kanban 10 approach of course the same approach should be used for both scs and app system development we stress that if the developments of scs and app system are made iteratively every two or three iterations the results of the two branches must be integrated as shown in fig 3 if a continuous flow lean kanban approach is performed the integration should happen at the completion of every us in both branches the activities happening in parallel are 8 1 incrementally implement the uss of app system with an agile approach scrum or kanban this step belongs to the right flow of abcde see fig 3 and does not differ from the implementation of a web application using scrum or kanban 8 2 perform the security assessment of the code written for the increment 8 3 write automated unit tests uts and acceptance tests ats for the uss implemented add the new tests to the test suite run the whole test suite to make sure that the additions did not break the system 9 integrate test and deploy the dapp system the integration of scs with app system is performed every 2 3 development iterations of both systems 4 2 uml diagrams for scs nowadays the most popular blockchain for dapp development is ethereum and the most used language is so lidity this language is object oriented oopl because contracts are defined similarly to classes they have internal variables and public and private functions each sc can inherit from one or more other contracts with respect to a standard oopl solidity adds specific concepts like events and modifiers and exhibits limitations in the types available for the sc data structure and in the management of collections of data the only collections available so far are the array and the mapping in the followings we will describe an adaptation of uml diagrams specific for solidity 0 5 possible modifications and extensions for other sc languages will be discussed in the section about future developments when designing and documenting scs graphic diagrams can be very useful to highlight the connections and the exchange of messages to this purpose we advocate the use of a subset of uml diagrams being uml the universal standard for software design diagrams however some specific concepts have to be introduced to account for peculiar sc features luckily uml has an extensibility mechanism called stereotype which can be used to introduce new concepts through tagging the uml diagrams we considered and modified to model scs are class diagrams and sequence diagrams also uml statecharts can be used to graphically represent the various states of a sc or of a app system module and its transitions statecharts however do not need any specific stereotype we already suggested to use also the use case diagrams to model actors and related uss in place of use cases the class diagram enables to represent the structure and relationships of scs table 1 shows the stereotypes we introduced in uml class diagrams in order to tag the sc specifities and their description in solidity there are no classes but scs are very similar to classes a sc has a data structure composed of variables and functions able to access these variables solidity source code can be used only for creating a sc this is accomplished by using a special kind of transaction the other two kinds of transactions are the transfer of ethers and the invocation of a function on an existing sc message a piece of solidity code can include several scs but a creation transaction can create at most one sc so the other scs can be used to be inherited from the created contract or to specify the functions that are called on other existing scs in the same blockchain accessed through their address these relationships among scs can be effectively captured by a uml class diagram to address the need to manage complex data solidity has the struct construct similar to c c and java in uml class diagram we represent structs as classes with a proper stereotype and with no bottom operation compart ment a specific concept of solidity are events raised when something relevant happens they can be caught by observer programs able to act correspondingly remember that scs cannot directly invoke functions of external systems an other peculiar concept of solidity are the modifiers these are boolean functions called before a function is executed they are able to check constraints and possibly to stop the function execution the last four stereotypes of table 1 are about solidity collections owing to the limitations of blockchain storage solidity allows only two kinds of collections the array and the mapping these stereotypes denote the kind of collec tion used for multiple variables of a data structure middle compartment of uml class symbol or for implementing 11 table 1 additions to uml class diagram stereotypes stereotype position description contract class symbol upper compartment denotes a sc interface ditto a kind of contract holding only function declarations library contract ditto a contract taken from a standard library enum ditto a list of possible values assigned to some variable the values are listed in the middle compartment the bottom compartment holding operations must be empty or ab sent struct ditto a record defined in the data structure of a contract and used thereof able to hold heterogeneous data the fields are listed in the middle compartment the bottom com partment must be empty or absent event class symbol middle compartment an event that can be raised by the sc signalling some thing relevant to external observers modifier class symbol bottom compartment a particular kind of guard function called before another function array class symbol middle compartment or role of an association a multiple variable or 1 n relationship which is imple mented using an array mapping ditto the multiple variable or 1 n relationship is implemented using a generic mapping mapping ad dress ditto a multiple variable or 1 n relationship which is imple mented using a mapping from an ethereum address to the value mapping uint ditto a multiple variable or 1 n relationship which is imple mented using a mapping from a unsigned integer to the value an association aggregation or composition the array is an ordered set of values indexed by their position as in most computer languages in solidity new values can be added to it but not removed the corresponding stereotype is array the mapping is able to store key value pairs the keys being stored as hash values of the actual keys given a key a mapping can efficiently retrieve the value but it is unable to iterate on its elements both keys and values given the importance of the mapping in solidity we introduced three stereotypes to represent a mapping denoted by the homonymous keyword the first is the generic mapping the second is the mapping having an ethereum address as key which is very used the third refers to a common solidity pattern using as keys positive sequential integers so that it is possible to iterate over them the other uml diagram very useful to represent the interactions among scs and external actors is the sequence diagram these diagrams are used in uml to model messaging in a blockchain the relevant messages are related to the transactions which in turn are sent from external actors or from scs to other scs remember that messages are synonyms of calls of public functions a specific characteristic of ethereum is that messages sent to a sc through a transaction take time typically 15 20 seconds or more to be answered however if a message is sent to another sc during the execution of a function of a given sc the time delay is negligible this happens because the evm during the execution of the calling function is able to locate in the blockchain and call any other sc to explicitly show this difference which can be very important for security gas consumption and response time we introduced the stereotypes trans msg and direct msg tagging the message calls sent through a transaction and directly by a sc respectively note that the fact that uml sequence diagrams explicitly represent the flow of time from top to bottom of the diagram can also be 12 used to quantify the timing difference between the two kinds of messages another peculiarity of ethereum is that a sc function which does not change the blockchain is called a view function and can be called immediately and at no cost again this is because the evm can locate the sc in the blockchain verify that the function is view and call it very quickly and using a negligible amount of resources all other messages are executed only if proper gas is paid another kind of message that can be sent is the transfer of ethers from an address to another to represent this transfer we use the return message of uml a dashed arrow tagged with the stereotype ethers our sequence diagrams represent the message exchange among external actors and scs all called participants in a given scenario the messages among external actors follow the usual uml notation an external actors however can also send ethers to another the messages with at least a sc as sender or receiver belong to the following types transaction characterized by coming from an external participant to a sc it is validated and inserted in a block by miners internal function call a message sent by a sc to another sc that modifies the blockchain thus costing gas it is represented as the usual synchronous or asynchronous message of uml sequence diagrams sc creation if sent by an external participant it is a transaction if by another sc it is an internal call in both cases it implies the call of the constructor of the new sc in uml notation creation is represented drawing the message arrow directly into the participant box representing the new sc view function call a message to a sc which does not modify the blockchain and costs no gas it is denoted by view or pure stereotype and can be sent by both kinds of participant fallback function call the fallback function is a special function of each sc which is called whenever a function or an ether transfer fail this function implements recovery procedures but can also be used to call whatever function of another contract through the proxy pattern for this reason we deem important to have a specific fallback stereotype note that the above discussed characteristics are specific of ethereum evm irrespectively of the specific high level language used to code the scs table 2 reports the stereotypes we introduced in uml sequence diagrams to identify the participants sending messages each having a unique address and the kinds of messages they exchange table 2 the stereotypes added to uml sequence diagrams stereotype position description person participant box a human role who posts transactions bearing messages through wallet or some application system ditto an external software system able to send transactions to the blockchain device ditto an iot device able to send transactions to the blockchain contract ditto a sc belonging to the system external contract ditto a sc external to the system oracle ditto a particular type of sc which holds information coming from the external world provided by a trusted provider account ditto an ethereum address just holding ethers it can only receive or send ethers when its owner activates the transfer trans msg message the message is sent using an ethereum transaction direct msg message the message is sent by a sc so it is executed immediately view or pure message the function called is of type view or pure so it costs no gas fallback message call to the fallback function only called by a sc on itself ethers return mes sage the dashed arrow represents a transfer of ethers and is can be shown also as a stand alone message 13 4 3 security assessment for smart contracts assessing and defining patterns of good programming practice for smart contracts for granting security in dapps is still in its infancy and is an ongoing area of research nevertheless based on the programmers experience and on recent exploited weaknesses very in famous and critical also for the amount of real money involved some major advices for security assessment in smart contracts have been identified and discussed among the the solidity developers community in fact ethereum and blockchain ecosystem are highly new and still somewhat experimental in addition scs are often designed to handle and transfer significant amount of money in cryptocurrency but easily exchangeable to real money therefore it is necessary that they correctly achieve their purposes but it is also crucial that their execution is secure against attacks the critical issues regarding the safety of a dapp can be divided in three areas issues related to blockchain itself the blockchain itself could be attacked it is known for instance that blockchains using proof of work for block generation are subject at least theoretically to the so called 51 attack those based on proof of stake are vulnerable to other types of attack for example to fake stake attack using ethereum technology the use of the main net lowers the probability of a 51 attack given the number and the computing power fielded by the miners instead using ethereum classic blockchain a fork derived from ethereum in 2016 the probability is higher because its miners computer power is much lower using a permissioned blockchain for instance ethereum parity proof of authority there is no 51 attack but the blockchain security depends on the honesty and reliability of the validating members and on their control over their respective it services clearly this kind of attacks are are more a problem of design choice of the technology to be used than of proper dapp design so their prevention go beyond the scope of this paper issues related to scs the most critical part of a dapp are the scs whose bytecode is publicly available and exposed to all possible exploits moreover developers often lack a full knowledge about implementation and usage of scs due to the the fact that this technology is in its early stage it is evolving fast and is different from traditional development in literature there are several analyses of possible vulnerabilities related to both ethereum virtual machine and solidity language 36 35 44 these are a good starting point for providing a checklist of patterns to verify the scs under development issues related to the app system the app system is composed of the server and client side of the dapp interacting with the scs on one side and with human roles and iot devices and other systems on the other side it must be designed and implemented with care but it is somewhat less critical provided that all best practices related to the security of web applications are used a special emphasis must be made to safeguard the access to the private keys of the various actors we will not cover general web security practices in this paper in the following of this section we focus on security assurance practices regarding sc design and coding which are the most critical and less studied among the issues cited above 4 3 1 general concepts of dapp security the first and foremost concept in security management is to have a security mindset the development team s and the whole organization must be fully aware of the importance of security and protection from attacks since abcde is an agile process it is based on principles and practices such as maximize communication short iterations refactoring continuous testing simplicity intention revaling code use of simple tools all these practices are also good for security but agile means incremental development where uss are continuously completed and tested this greatly helps productivity but might be at the expense of security a good starting point to focus on security are the top 10 proactive controls of owasp organization 45 those most relevant for dapp security ordered by importance are c 1 define security requirements this looks straightforward but it is not you must explicitly define the security requirements needed for your system the requirements can be written as uss or as non functional features and should have acceptance tests in the form of test cases to confirm these requirements have been implemented 14 c 2 leverage security frameworks and libraries don t write everything from scratch but reuse software that is security hardened is coming from trusted sources and is maintained up to date c 5 validate all inputs this should be performed for user inputs on server side because client side validation can be bypassed also let the sc itself perform validation of key data sent to it through messages c 6 implement digital identity in a dapp environment digital identities are guaranteed by addresses and by the ownership of the relative private key so this control is quite straightforward c 7 enforce access controls sc can check access levels of addresses through a mapping and act accordingly c 8 protect data everywhere in particular be aware that data stored in a sc are always accessible to read independently of their visibility c 10 handle all errors and exceptions it is known that even small mistakes in error handling or forgetting to handle errors can lead to catastrophic failures in distributed systems this is particularly true for scs specifically related to sc security are the general guidelines reported in 46 section general philosophy which complement owasp ones here will just report a short description and give the names of related security patterns reported below this list 1 prepare for failure be able to respond to errors also in the context of scs which cannot be changed once deployed this is related to patterns emergency stop rate limit balance limit and proxy 2 rollout carefully try your best to catch and fix the bugs before the sc is fully released test contracts thoroughly and add tests whenever new attack vectors are discovered 3 keep scs simple complexity increases the risk of errors so ensure that scs and functions are small and modular reuse scs that are proven prefer clarity to performance 4 keep up to date keep track of new security developments and upgrade to the latest version of any tool or library as quickly as possible 5 be aware of blockchain properties while your previous programming experience is also applicable to sc programming there are several pitfalls to be aware of 4 3 2 security in the design phase in the design phase developers must be aware of and use security patterns as reported in references 47 48 49 which we refer to table 6 shows the main security patterns table 3 main security patterns id name description ref cei check effect interaction when performing a function in a sc first check all the preconditions then apply the effects to the contract s state and finally interact with other contracts never alter this sequence 47 es emergency stop also known as circuit breaker incorporate an emergency stop functionality into the sc that can be triggered by an authenticated party to disable sensitive functions this is very useful in the case of major bug or security issue 47 sb speed bump slow down contract sensitive tasks so when malicious actions occur the damage is limited and more time to counteract is available for instance limit the amount of money a user can withdraw per day or impose a delay before withdrawals 47 rl rate limit regulate how often a task can be executed within a period of time to limit the number of messages sent to a sc and thus its computational load 47 15 mu mutex a mutex is a mechanism to restrict concurrent access to a resource utilize it to hinder an external call from re entering its caller function again 47 bl balance limit limit the maximum amount of funds held within a sc 47 gc guard check ensure that all requirements on a sc state and on function inputs are met use properly assert require and revert to check user inputs sc state invariants 50 wf withdrawal from contracts also known as pull over push when you need to send ethers or tokens to an address don t send them directly instead authorize the address owner to withdraw the funds and let s he perform the job 51 50 au authorization restrict the execution of code according to the caller address this is accomplished using mappings of addresses and is typically checked using modifiers 48 or oracle an oracle is a sc providing data from outside the blockchain which are in turn fed to the oracle by a trusted source here the security risk lies in how actually the source can be trusted 48 rn randomness not really a pattern but some guidelines to simulate randomness in a deterministic environment like that of scs it is possible to query an oracle to use values not predictable a priori as the hash of a block not yet created 48 tc time constraint a time constraint specifies when an action is permitted depending on the time registered in the block holding the transaction it is used in speed bump and rate limit patterns 48 te termination used when the life of a sc has come to an end this can be done by inserting ad hoc code in the contract or calling selfdestruct function usually only the contract owner is authorized to terminate a contract 48 mh math a logic which computes some critical operations protecting from over flows underflows or other undesired characteristics of finite arithmetic 48 pd proxy delegate proxy patterns are a set of scs working together to facilitate upgrading of scs despite their intrinsic immutability a proxy is used to refer to another sc whose address can be changed this approach also ensure that blockchain resources are used sparingly thus saving gas 49 50 our approach consists in using two security checklists one to be performed during and after design and design upgrades the other during coding phases the aim is to verify that all security patterns and practices concerning known problems are applied these practices are complementary to the agile practices reported in sections 2 2 and 4 1 depending on the size of the project and the number of scs the checklist can be unique for the system or you may use a separate checklist for each sc subsystem tables 4 and 5 present the security assurance practices we propose they describe the checks to be performed a short description of the vulnerability vulnerabilities and how to avoid it them and one or more references to learn more about the problem from these tables it is easy to extract two checklists to be used to perform security assurance during the design and the coding of the sc system respectively 16 table 4 security assurance checklist for the design phase to check description ref related pat terns re entrancy functions that could be called recursively before the first invo cations is finished this may cause destructive consequences ensure state committed before an external call 8 46 cei mu dependencies use audited and trustworthy dependencies to existing scs and ensure that newly written code is minimized by using libraries 46 multiple inheritance caution solidity uses the c 3 linearization this means that when a contract is deployed the compiler will linearize the inheritance from right to left multiple overrides of a function in complex inheritance hierarchies could potentially interact in tricky ways 46 include a fail safe mechanism it is important to have some way to update the contract in the case some bugs will be discovered for example it is possible to have a contract forwarding calls and data to the latest version of the contract es sb rl pd limit the amount of ether if the code the compiler or the platform has a bug the funds stored in your smart contract may be lost so limit the maximum amount check that all money transfers are performed through explicit withdrawals made by the beneficiary rl bl wf be careful with ran domness random number generation in a deterministic system is very difficult do not rely on pseudo randomness for important mechanisms current best solutions include hash commit reveal schemes ie one party generates a number publishes its hash to commit to the value and then reveals the value later and randao 36 section iii a 7 be careful with timestamp be aware that the timestamp of a block can be manipulated by a miner all direct and indirect uses of timestamp should be an alyzed and verified if the scale of your time dependent event can vary by 30 seconds and maintain integrity it is safe to use a timestamp this include thing like ending of auctions regis tration periods etc do not use the block number property as a timestamp 35 section iv c tc never assume that a contract has zero balance be aware of coding an invariant that strictly checks the balance of a contract an attacker can forcibly send ether to any account and this cannot be prevented 46 transaction order ing miners have the power to alter the order of transactions arriving in short times inconsistent transactions orders with respect to the time of invocations can cause race conditions 35 section iv b tc 4 3 3 security in the coding phase during coding one major class of problems derives from external calls namely from functions which recur to others sc code for completing their execution in fact a sc can call another sc exploiting the execution of code contained in the latter contract the pattern can be recursive so the called sc can in turn perform an external call and so on as a consequence external calls must be treated like calls to untrusted software they should be avoided or minimized because some malicious code could be introduced somewhere in a sc belonging to this path and any external call represents a security risk a typical risk of such contract interaction is reentrancy namely the called contract can call back the calling function before the overall function execution has been completed this pattern has 17 been performed in the dao attack when it is not possible to avoid external calls label all the potentially unsafe variables functions and contracts interfaces as untrusted also follow the check effect interaction pattern another important tool for sc security and error handling is the use of assert require and revert guard functions they are a very powerful security tool and are the subject of security pattern guard check presented in table 6 in general use assert to check for invariants to validate state after making changes to prevent wrong conditions if an assert statement fails something very wrong happened and you need to fix the code use require when you want to validate user inputs state conditions preceding an execution or the response of an external call use revert to handle the same type of cases as require but with more complex logic 46 the most important tool to achieve security and correctness however is to apply thorough automated tests this is even more crucial when writing scs because it is difficult or impossible to update a sc abcde does not prescribe the use ofspecific testing practices such as test driven design but highlights the importance of testing presently the most popular testing framework for ethereum dapps is truffle whose website also provides documentation on how to test scs and app system code see 24 section testing your contracts the checklist for security assessment in the coding phase is reported in table 5 table 5 security assurance checklist for the coding phase to check description ref related pat terns external calls if possible avoid them when using low level call functions address call callcode delegatecall and send make sure to handle the possibility that the call will fail by checking the return value also avoid combining multiple ether transfers in a single transaction mark untrusted interactions name the vari ables methods and contract interfaces of the functions that call external contracts in a way that makes it clear that interacting with them is potentially unsafe 46 cei mu gc wf prevent overflow and underflow if a balance reaches the maximum uint value it will circle back to zero similarly if a uint is made to be less than zero it will cause an underflow and get set to its maximum value one simply solution is to use a library like safemath sol by openzeppelin 35 section iii c mh gc beware of rounding errors all integer divisions round down to the nearest integer check that truncation does not produce unexpected behaviour locked funds incorrect results 46 mh gc validate inputs to external and public functions make sure the requirements are verified and check for argu ments 35 section iv f gc prevent unbounded loops the gas consumed increases with each iteration until it hits the block s gaslimit stopping the execution 50 tx origin it is a global variable that returns the address of the message sender do not use tx origin as an authorization mechanism 52 section 3 1 fallback functions fallback functions are called when a contract receive a message without arguments and when no other function matches you should keep them simple and check that the data is empty to avoid malicious invocation 46 35 section iv a cei mu gc check if built in vari ables or functions were overridden it is currently possible to override built in globals in solidity such as this allows scs to override the functionality of built ins such as msg and revert although this is intended it can mislead users of a sc so the whole sc code must be checked 46 gc 18 use interface type in stead of the address for type safety when a function takes a contract address as an argument it is better to pass an interface or contract type rather than raw ad dress if the function is called elsewhere within the source code the compiler it will provide additional type safety guarantees 46 gc enforce invariants with assert an assert guard triggers when an assertion fails for instance an invariant property changing you can verify it with a call to as sert assert guards should be combined with other techniques such as pausing the contract and allowing upgrades otherwise you may end up stuck with an assertion that is always failing 46 gc lock pragmas to spe cific compiler version contracts should be deployed with the same compiler version and flags that they have been tested with so locking the version helps avoid the risk of undiscovered bugs 46 fix compiler warn ings take warnings seriously and fix them always use the latest ver sion of the compiler to be notified about all recently introduced warnings 51 testing be sure to have a 100 text coverage and cover all critical edge cases with unit tests do not deploy recently written code espe cially if it was written under tight deadline 4 4 gas optimization besides security another important factor of scs that must be carefully designed since the beginning is their cost creating scs and writing permanent data in a public blockchain can be very costly so it is important to keep them to a minimum and to limit the transactions that write or modify these data also the messages exchanged among the app system and the scs and among scs must be properly designed and well documented table 6 shows some specific patterns that can be used to save gas note that in ethereum the maximum size of the bytecode of a sc is restricted to 24 kbytes by the standard eip 170 see section 13 4 2 of 27 for serious scs that size limit can be hit easily so many of the gas saving patterns are useful also to make a sc viable table 6 main gas saving patterns id name description ref pd proxy delegate when you need to call external scs do not include their code include their interface and use the proxy pattern which uses the fallback function to call the sc functions this is the same pat tern also shown in table 6 49 ls limit storage limit data stored in the blockchain store non permanent data in memory avoid changing storage data during computations change them only after all the calculations 53 pk pack your variables in ethereum you pay gas for every storage slot of 256 bits you use you can pack as many variables as you want in it but you must order their declaration properly use integers smaller than 256 bits only if you have many to pack if not using 256 bits integers avoids the needed conversion to 256 bits which costs gas remember that elements in memory and call data are not packed use datatype bytes 32 rather than bytes or string if possible limit constant strings for instance those used in require to explicit the error to fit in 32 bytes 53 19 dv delete variables no more needed if you don a z t need a variable anymore delete it using the delete keyword in ethereum you get a gas refund for free ing up storage space 53 ni do not initialize vari ables with default values all variables are initialized to zeroes at no cost do not explicitly initialize them to zero or a value is given to them anyway when they are used 53 mp use mappings to manage lists of data use mappings with integer key and not arrays this is known to save blockchain space 53 ep execution paths thoroughly examine all possible execution paths looking for code whose execution can be spared avoid repetitive checks of variables logical operators and evaluate only the first operand if the second is not needed so order them to maximize the probability that only one operand is computed 53 le limit external calls limit calls to other scs note that calling external functions is cheaper than calling public functions the cheapest calls how ever are those to internal functions 53 lm limit modifiers the code of modifiers is inlined inside the modified function thus costing gas internal functions on the other hand are not inlined but called as separate functions they are very slightly more expensive in run time but save a lot of redundant bytecode in deployment if used more than once 53 ul use libraries the bytecode of external libraries is not made part of your sc thus saving gas however calling them is costly and has security issues use libraries for complex tasks 53 el event log if the app system needs to retrieve information about past events that is not useful for sc execution let the app directly access the event log in the blockchain note that if the event happened far in time the time to retrieve it may be long 53 5 experimental validation the development process which later was named abcde was first devised in 2018 54 and since then it has been used in several project carried on in our university group and in firms we are consulting among the projects which were developed or which are in development we may quote a system to trace the provenance of foods a supply chain management system a system to manage temporary job contracts a voting system which was used to reward the best presentation at a conference another one managing voting in firm shareholders and board of directors meetings a system to manage energy exchange in local networks of electricity producers and consumers a system to automate agile software development 34 the feedback of dapp developers using abcde method was generally positive and was used to improve the method especially concerning security and gas optimization practices here we present as an example of abcde usage a simplified version of a dapp application aiming to implement a decentralized exchange dex for tokens managed on ethereum blockchain a dex is a system enabling the exchange of different tokens between two holders who interact directly without intermediaries we started from the well known 0 x protocol project the subject of a successful ico held in 2017 the specification of the dex can be found in the 0 x whitepaper 55 we present a simplified version of the whole system in particular we dropped the part related to the protocol token section 4 of the whitepaper moreover for the sake of brevity we will not present the coding phases phases 6 8 and 9 but we stop at the end the design phases phases 5 and 7 the steps of abcde are presented below 20 1 goal of the system to manage a decentralized exchange able to enable pairs of erc 20 and erc 721 token holders to exchange their tokens at an agreed rate on the ethereum blockchain 2 actors the system has the following actors trader owner of tokens wishing to post an offer or to accept a posted offer maker a trader who posts an offer to sell a given amount of her his tokens in exchange to tokens of another type at a given exchange rate taker a trader who accepts the offer of a maker relayer a system which facilitates signaling between market participants by hosting and propagating an order book of the offers dex smart contract s on the ethereum blockchain which accept orders signed by both a maker and taker and activate the exchange of tokens token a sc on the ethereum blockchain managing a given token according to the erc 20 or erc 721 protocols figure 4 the user stories of the dex system specification 3 user stories fig 4 shows the actors and the uss they are involved in using a uml use case diagram where the use cases are in fact uss note that these uss just specify the dex and do not depend on the specific technology used to implement it except for the ethereum blockchain which the dex necessarily has to interact with here we have no room to show the uss in detail so we refer the readers to the above quoted whitepaper 55 instead in fig 5 we show the uml class diagram derived by an analysis of the given uss this diagram is not bound to a specific implementation of the relayer system but just shows schematically the entities the data structures and the operations emerging from the uss of fig 4 4 divide the system into sc and app subsystems in this case the subdivision is trivial because the relayer system is a typical web application whereas the dex and the tokens are smart contracts by design the 21 figure 5 the standard uml class diagram derived from the uss uss of the external app subsystem are the same of those reported in fig 4 except the last one execute the order which is carried on solely by scs as regards the blockchain subsystem the us to implement are basically the messages to submit an order or to cancel an order sent by a taker to the dex in practice the actual implementation of the dex contracts made by 0 x team is very complex due to the strict security requirements and to the many checks that must be made before performing the actual token transfer 5 design of the sc subsystem the sc system is very complex and a detailed description of its architecture is well beyond the scope of this paper we report in fig 6 just a simplified uml class diagrams showing some of the actual scs to show some of the specific stereotypes used to document an sc system as described in section 4 2 the modifiers and the events enforcing the constraints relevant for the dex are shown in table 7 and table 8 respectively fig 7 shows a uml sequence diagram representing the interactions among most actors of the systems when a taker accepts an order seen in the relayer s book and sends it to the dex for execution including the messages exchanged among the scs 6 omitted 7 design of app system the app system is composed of the software able to present the present offers of tokens posted by the takers and of the software used by takers and makers respectively to post modify or delete offers and to accept offers the latter software must be provided of a wallet able to store ethers and send transactions to ethereum blockchain the design of this subsystem includes that of its user interfaces the system is fairly complex and the wallets must be designed and implemented using strong security practices we will not dig further into this subsystem because except for the wallet it is a standard web based system 22 figure 6 the modified uml diagram showing the structure of the required scs of the dex system 8 omitted 9 omitted 6 conclusion and future work despite the huge effort presently ongoing in developing dapps software engineering practices are still poorly applied in software development of blockchain systems the field is in fact still in its infancy and tools or techniques for modeling and managing the peculiarities a software developer must face when dealing with blockchain oriented software systems are still matter for researchers tools and techniques of traditional software engineering have not yet been adapted and modified to adhere to this new software paradigm a sound software engineering approach might greatly help in overcoming many of the issues plaguing blockchain development providing developers with instruments similar to those typically used in traditional software engineering to afford architectural design security issues testing planes and strategies and to improve software quality and maintenance researchers in software engineering have a big opportunity to start studying a field that is very important and brand new exploiting concepts tools instruments and ideas already consolidated in software engineering and chang ing and adapting them to this new software technology this work whose a first version was presented in 54 moves toward this direction providing a full modeling of interactions among traditional software and blockchain environment including class diagrams statecharts us a z s diagrams sequence diagrams smart contracts diagrams all specialized for blockchain application development it also provides a general scheme for managing blockchain development processes and a simplified example of a distributed exchange smart contract taken from a real set of scs implementing a dex 23 table 7 the modifiers of the scs modifier action notes onlyowner enforces that the sender of the message is the owner of the contract inherited by ownable standard contract nonreentrant enforces that the message is not recursively sent onlyauthorized enforces that the sender of the message belongs to a list of authorized addresses managed by the same sc table 8 the events of the scs event action notes fill an order has been filled in the dex cancel an order has been cancelled in the dex cancelupto an order has been partially cancelled from the dex authorizedaddressadded an address has been added to the list of authorized ones authorizedaddressremoved an address has been removed from the list of authorized ones we believe that our work can be really valuable to blockchain firms including ico startups that could develop a competitive advantage using se bose practices since the beginning the proposed method has also the potential to be applied to other sc environments such as hyperledger ripple and others and we are exploring these extensions 7 acknowledgments this work was partially founded by the aind project native digital administrations and enterprises funded by sardinia region pia call 2013 e u p o fesr 2007 2013 n 3706 rep n 316 22 04 2016 references 1 s nakamoto bitcoin a peer to peer electronic cash system 2008 url https bitcoin org bitcoin pdf last accessed august 15 2019 2 g wood ethereum a secure decentralised generalised transaction ledger 2014 url https ethereum github io yellowpaper paper pdf last accessed updated version august 15 2019 3 n szabo smart contracts formalizing and securing relationships on public networks first monday 2 1997 url https ojphi org ojs index php fm article view 548 4 m swan blockchain blueprint for a new economy o reilly media inc 2015 5 m biella v zinetti blockchain technology and applications from a financial perspective unicredit tehcnical report 2016 6 g fenu l marchesi m marchesi r tonelli the ico phenomenon and its relationships with ethereum smart contract environment in blockchain oriented software engineering iwbose 2018 international workshop on ieee pp 26 32 7 u chohan the problems of cryptocurrency thefts and exchange shutdowns technical report discussion paper series notes on the 21 st century school of business and economics university of new south wales canberra 2018 8 n atzei m bartoletti t cimoli a survey of attacks on ethereum smart contracts sok in m maffei m ryan eds principles of security and trust springer berlin heidelberg 2017 pp 164 186 9 g destefanis m marchesi m ortu r tonelli a bracciali r hierons smart contracts vulnerabilities a call for blockchain software engineering in 2018 international workshop on blockchain oriented software engineering iwbose 10 s porru a pinna m marchesi r tonelli blockchain oriented software engineering challenges and new directions in proceedings of the 39 th international conference on software engineering companion ieee press pp 169 171 11 k beck m beedle a van bennekum a cockburn w cunningham m fowler j grenning j highsmith a hunt r jeffries et al manifesto for agile software development 2001 12 p chakraborty r shahriyar a iqbal a bosu understanding the software development practices of blockchain projects a survey in esem 2018 october 11 a s 12 2018 oulu finland acm 13 a bosu a iqbal r shahriyar p chakraborty understanding the motivations challenges and needs of blockchain software developers a survey empirical software engineering 24 2019 2636 2673 14 k schwaber m beedle agile software development with scrum pearson 2001 15 k beck test driven development by example addison wesley professional 2002 16 m fowler refactoring improving the design of existing code 2 nd edition addison wesley professional 2018 17 z zheng s xie h n dai x chen h wang blockchain challenges and opportunities a survey international journal of web and grid services 14 2018 352 375 24 figure 7 the uml sequence diagram showing a taker accepting an offer and sending it to the dex for execution 18 s tikhomirov ethereum state of knowledge and research perspectives in international symposium on foundations and practice of security springer pp 206 221 19 coinmarketcap website 2019 url https coinmarketcap com tokens last accessed august 12 2019 20 state of the dapps website 2019 url https www stateofthedapps com stats last accessed november 16 2019 21 c dannen introducing ethereum and solidity springer 2017 22 m cohn user stories applied for agile software development addison wesley professional 2004 23 d janzen h saiedian test driven development concepts taxonomy and future direction computer 38 2005 43 50 24 truffle website 2019 url https www trufflesuite com last accessed october 6 2019 25 k beck extreme programming explained embrace change addison wesley professional 2000 26 j rumbaugh g booch i jacobson the unified modeling language reference manual addison wesley 2017 27 x xu i weber m staples architecture for blockchain applications springer 2019 28 x xu i weber m staples l zhu j bosch l bass c pautasso p rimba a taxonomy of blockchain based systems for architecture design in software architecture icsa 2017 ieee international conference on ieee pp 243 252 29 f wessling c ehmke m hesenius v gruhn how much blockchain do you need towards a concept for building hybrid dapp architectures in wetseb 2018 1 st international workshop on emerging trends in software engineering for blockchain 30 g fridgen j lockl s radszuwill a rieger a schweizer n urbach a solution in search of a problem a method for the development of blockchain use cases in 24 th americas conference on information systems amcis new orleans usa august 2018 31 m jurgelaitis v drungilas l ceponiene r butkiene e vaiciukynas modelling principles for blockchain based implementation of business or scientific processes in proceedings of the international conference on information technologies ivus 2019 pp 43 47 32 m beller j hejderup blockchain based software engineering in proceedings of the 41 th international conference on software engineering companion ieee press pp 53 56 33 v lenarduzzi i lonesu m marchesi r tonelli blockchain applications for agile methodologies in proceedings of the 19 th international conference on agile software development companion xp 2018 acm new york ny usa 2018 pp 30 1 30 3 34 m marchesi g destefanis v lenarduzzi m lunesu m ortu a pinna r tonelli agile software development automated by blockchain smart contracts in proceedings of the software engineering conference russia secr 2019 acm new york ny usa 2019 25 35 p praitheeshan l pan j yu j liu r doss security analysis methods on ethereum smart contract vulnerabilities a survey arxiv preprint arxiv 1908 08605 2019 36 y huang y bian r li l zhao p shi smart contract security a software lifecycle perspective ieee access 7 2019 37 h baumeister n koch l mandel towards a uml extension for hypermedia design in international conference on the unified modeling language springer pp 614 629 38 l baresi f garzotto p paolini extending uml for modeling web applications in system sciences 2001 proceedings of the 34 th annual hawaii international conference on ieee pp 10 pp 39 h rocha s ducasse preliminary steps towards modeling blockchain oriented software in wetseb 2018 1 st international workshop on emerging trends in software engineering for blockchain 40 p coad e yourdon p coad object oriented analysis volume 2 yourdon press englewood cliffs nj 1991 41 d j anderson kanban successful evolutionary change for your technology business blue hole press 2010 42 l l constantine l a lockwood software for use a practical guide to the models and methods of usage centered design pearson education 1999 43 h sharp y rogers j preece interaction design beyond human computer interaction 5 th edition john wiley sons 2019 44 j liu z liu a survey on security verification of blockchain smart contracts ieee access 7 2019 45 k anton j manico j bird owasp proactive controls for developers technical report open web application security project owasp 2018 46 consensys solidity best practices website 2019 url https consensys github io smart contract best practices last accessed november 2019 47 m wohrer u zdun smart contracts security patterns in the ethereum ecosystem and solidity in blockchain oriented software engineer ing iwbose 2018 international workshop on ieee pp 2 8 48 m bartoletti l pompianu an empirical analysis of smart contracts platforms applications and design patterns in b m et al ed financial cryptography and data security fc 2017 lecture notes in computer science springer cham 2017 pp 494 509 49 proxy patterns 2019 url https blog openzeppelin com proxy patterns last accessed november 2019 50 ethereum smart contract security best practices website 2019 url https ethereum contract security techniques and tips readthedocs io en latest last accessed november 2019 51 solidity website 2019 url https solidity readthedocs io en v 0 5 13 index html last accessed november 2019 52 a mense m flatscher security vulnerabilities in ethereum smart contracts in proceedings of the 20 th international conference on information integration and web based applications services iiwas 2018 acm new york ny usa 2018 pp 375 380 53 m gupta solidity gas optimization tips 2018 url https mudit blog solidity gas optimization tips last accessed november 2019 54 m marchesi m marchesi r tonelli an agile software engineering method to design blockchain applications in proceedings of the software engineering conference russia secr 2018 acm new york ny usa 2018 55 w warren a bandeali 0 x an open protocol for decentralized exchange on the ethereum blockchain 2017 url https 0 xproject com pdfs 0 x white paper pdf last accessed november 2019 26 1 introduction 2 background 2 1 decentralized applications 2 2 agility and dapp development 2 3 security assessment 3 related work 4 proposed method for dapp development 4 1 overall process 4 2 uml diagrams for scs 4 3 security assessment for smart contracts 4 3 1 general concepts of dapp security 4 3 2 security in the design phase 4 3 3 security in the coding phase 4 4 gas optimization 5 experimental validation 6 conclusion and future work 7 acknowledgments